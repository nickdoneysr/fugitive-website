<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0DEKHESMHE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0DEKHESMHE');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Fugitive Chess</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&family=Permanent+Marker&family=Exo+2&family=Cabin&family=Bubblegum+Sans&family=VCR+OSD+Mono&family=Bebas+Neue&family=Rajdhani&family=Press+Start+2P&family=MedievalSharp&family=Audiowide&family=Creepster&family=Hanalei+Fill&family=Nosifer&display=swap" rel="stylesheet">
    <style>
        /* Global reset for consistent sizing */
        * {
            box-sizing: border-box;
        }

        /* Body styling with enhancements for smoothness and accessibility */
        body {
            display: flex;
            z-index: 1;
            position: relative;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            color: #333;
            margin: 0;
            padding: 15px;
            padding-bottom: 100px;
            transition: background 0.3s ease, color 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            scroll-behavior: smooth;
        }

        /* Headings with consistent styling and animation for h1 */
        h1 {
            font-size: 48px;
            margin: 10px 0;
            text-align: center;
            animation: titlePulse 2s infinite ease-in-out;
        }

        h2 {
            font-size: 24px;
            margin: 7px 0;
            text-align: center;
            animation: titlePulse 5s infinite ease-in-out;
        }

        h3 {
            font-size: 21px;
            margin: 5px 0;
            text-align: center;
            animation: titlePulse 10s infinite ease-in-out;
        }

        f1 {
            font-size: 32px;
            margin: 10px 0;
            text-align: center;
            animation: titlePulse 10s infinite ease-in-out;
        }

        f2 {
            font-size: 16px;
            margin: 7px 0;
            text-align: center;
        }

        f3 {
            font-size: 14px;
            margin: 5px 0;
            text-align: center;
        }

        /* Keyframe animations with unique names to avoid conflicts */
        @keyframes titlePulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pulse-highlight {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        @keyframes pulse-timer {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .square {
            width: 50px; /* Example size, adjust as needed */
            height: 50px;
            display: inline-block;
            text-align: center;
            line-height: 50px;
        }

        .text {
            font-size: 24px; /* Adjust as needed */
            display: inline-block;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .glow {
            text-shadow: 0 0 6px #fff, 0 0 10px #fff, 0 0 18px #e60073;
        }

        .pulse {
            animation: pulse .1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .bounce {
            animation: bounce .3s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .shake {
            animation: shake 0.2s infinite;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        /* Section styling with consistent transitions */
        #start-page, #fugitive-menu, #game-area, #creative-mode, #tutorial-section, #settings-section, #rules-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #start-page {
            display: flex; /* Initially visible */
        }

        /* Grid layout for ad board */
        #ad-board-container {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            transition: background-color 0.5s ease;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s ease;
        }

        /* Utility classes for text and background colors */
        .text {
            font-size: 24px;
            font-weight: bold;
        }

        .text-white { color: white; }

        .bg-red { background-color: red; }
        .bg-blue { background-color: blue; }
        .bg-green { background-color: green; }
        .bg-yellow { background-color: yellow; }
        .bg-purple { background-color: purple; }
        .bg-orange { background-color: orange; }

        /* Form elements with improved accessibility */
        select {
            padding: 5px;
            font-size: 14px;
            margin: 5px 0;
            border-radius: 3px;
            width: 200px;
            background: #fff;
            border: 1px solid #333;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .button {
            padding: 8px 12px;
            margin: 4px;
            font-size: 16px;
            font-family: inherit;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            transition: background 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        button:focus, select:focus, input:focus {
            outline: 2px solid #ffd700;
            outline-offset: 2px;
            background: rgba(255, 215, 0, 0.2);
        }

        select:focus {
            outline: 2px solid #000;
            border-color: #000;
        }

        /* Canvas styling */
        canvas {
            border: 2px solid #000;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            display: none;
        }

        /* Informational text blocks */
        #level-info, #game-info, #stats, #track-info, #mode-instructions, #tutorial-info {
            margin: 5px;
            font-size: 14px;
            text-align: center;
        }

        #mode-instructions {
            max-width: 350px;
        }

        /* Modal and prompt styling */
        #custom-prompt, .custom-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f0f0f0;
            color: #fff;
            padding: 20px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            z-index: 1000;
            max-width: 400px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .custom-modal button {
            margin: 5px;
            background: #ffd700;
            color: #333;
        }

        .custom-modal button:hover {
            background: #ccac00;
        }

        /* Music controls */
        #music-controls button {
            padding: 6px 8px;
            font-size: 12px;
            margin: 0 3px;
            min-width: 55px;
            color: white;
            border: 1px solid #333;
        }

        #game-area button, #creative-mode button, #tutorial-section button {
            display: inline-block;
        }

        /* Footer styling */
        footer {
            position: relative;
            flex-direction: column;
            height: auto;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: Arial, sans-serif;
            padding: 10px;
            padding-top: 20px;
            z-index: 10;
            transition: background 0.3s ease, color 0.3s ease;
        }

        #developer-info, #logo-placeholder, #sponsor-banner {
            margin: 5px 20px;
        }

        #music-player {
            display: flex;
            align-items: center;
        }

        #track-info {
            margin-right: 10px;
        }

        #music-controls {
            display: flex;
            justify-content: center;
            margin: 0 10px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
        }

        #sponsor-banner {
            background: #eee;
            padding: 5px;
            border: 1px solid #ccc;
            text-align: center;
            font-style: italic;
        }

        /* Rules content */
        #rules-content {
            max-width: 600px;
            text-align: left;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin: 20px;
        }

        #rules-content details {
            margin-bottom: 15px;
        }

        #rules-content summary {
            font-weight: bold;
            cursor: pointer;
        }

        #rules-content ul {
            padding-left: 20px;
        }

        /* Tips & Strategy */
        #tips-strategy-section {
            max-width: 600px;
            text-align: left;
            padding: 20px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin: 20px;
        }

        #rules-content details {
            margin-bottom: 15px;
        }

        #rules-content summary {
            font-weight: bold;
            cursor: pointer;
        }

        #rules-content ul {
            padding-left: 20px;
        }

        .merchandise {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .item {
            text-align: center;
            width: 150px;
        }
        .item img {
            max-width: 100%;
            height: auto;
        }
        .sponsors a {
            display: block;
            margin: 5px 0;
        }

        /* Additional sections */
        #standard-chess-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Campaign Mode Section */
        #campaign-mode {
            margin-top: 20px;
            text-align: center;
        }

        #campaign-mode h2 {
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
        }

        /* Ensure modals are styled consistently */
        #level-selection, #campaign-completion, #campaign-failure {
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 5px;
            z-index: 1001;
            max-width: 400px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #prison-list {
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #campaign-mode h2 {
                font-size: 20px;
            }
            #campaign-mode button {
                font-size: 14px;
                padding: 6px 10px;
            }
        }

        /* Hidden announcements for accessibility */
        #game-announcements {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        /* Pulse animations applied to specific elements */
        .pulse-highlight {
            animation: pulse-highlight 1s infinite;
        }

        #timer-progress.pulsing {
            animation: pulse-timer 1s infinite;
        }

        .hint-highlight {
            background-color: rgba(0, 255, 0, 0.3);
        }

        .piece {
            position: absolute;
            transition: transform 0.5s ease;
        }

        /* Paused overlay buttons */
        #paused-overlay button {
            padding: 10px 20px;
            font-size: 18px;
            background: #ffd700;
            color: #333;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s ease;
        }

        #paused-overlay button:hover {
            background: #ccac00;
        }

        /* Tab navigation */
        .tab-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        .tab-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .tab-button {
            padding: 10px 20px;
            background: #ddd;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }

        .tab-button.active {
            background: #4CAF50;
            color: white;
        }

        .tab-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: none;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
        }

        .tab-content.active {
            display: block;
            opacity: 1;
        }

        /* Collapsible details */
        details {
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            padding: 5px;
            background: #ddd;
            border-radius: 3px;
            transition: background 0.3s ease;
        }

        details[open] summary {
            background: #4CAF50;
            color: white;
        }

        /* Section transitions */
        .section {
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .section.active {
            display: flex;
            animation: fadeIn 0.5s ease-in;
            opacity: 1;
        }

        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            canvas {
                width: 100% !important;
                height: auto !important;
            }
            #game-area, #creative-mode, #tutorial-section, #settings-section {
                padding: 10px;
            }
            .button {
                font-size: 14px;
                padding: 5px 8px;
            }
            select {
                width: 150px;
            }
            h1 { font-size: 36px; }
            h2 { font-size: 20px; }
            h3 { font-size: 16px; }
            #stats, #game-info, #mode-instructions {
                font-size: 12px;
            }
        }

        @media (max-width: 600px) {
            body { padding-bottom: 100px; }
            #game-footer {
                flex-direction: column;
                padding: 5px;
            }
            #music-player { margin: 5px 0; }
            #game-area, #standard-chess-section, #creative-mode, #tutorial-section {
                padding: 5px;
            }
            canvas {
                width: 300px !important;
                height: 300px !important;
            }
            .button {
                font-size: 14px;
                padding: 6px 10px;
            }
            select {
                width: 150px;
                font-size: 14px;
            }
            h1 { font-size: 28px; }
            h2 { font-size: 18px; }
            h3 { font-size: 16px; }
            #stats, #game-info, #mode-instructions, #tutorial-info {
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            canvas {
                width: 300px !important;
                height: 300px !important;
            }
            button {
                font-size: 12px;
                padding: 6px 8px;
            }
            select {
                width: 150px;
            }
            h1 { font-size: 28px; }
            h2, h3 { font-size: 18px; }
        }
    </style>
</head>
<body>
    <audio id="move-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/9dc739535f8a5f781346d6f6e52056561f1b62dc/move.mp3" preload="auto"></audio>
    <audio id="capture-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/9dc739535f8a5f781346d6f6e52056561f1b62dc/capture.mp3" preload="auto"></audio>
    <audio id="win-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/9dc739535f8a5f781346d6f6e52056561f1b62dc/win.mp3" preload="auto"></audio>
    <audio id="lose-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/9dc739535f8a5f781346d6f6e52056561f1b62dc/lose.mp3" preload="auto"></audio>
    <audio id="collect-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/f3af815d435475caba947118049af55a072c361e/collect.mp3" preload="auto"></audio>
    <audio id="ability-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/f3af815d435475caba947118049af55a072c361e/ability.mp3" preload="auto"></audio>
    <audio id="teleport-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/f3af815d435475caba947118049af55a072c361e/teleport.mp3" preload="auto"></audio>
    <audio id="roll-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/f3af815d435475caba947118049af55a072c361e/roll.mp3" preload="auto"></audio>
    <audio id="invalid-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/2b8f8dcaf9b1f0de8e37574154bfe0a565359b5d/invalid.mp3" preload="auto"></audio>
    <audio id="click-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/c0142f27df867b312093f36f080f0d3759dfd077/click.mp3" preload="auto"></audio>
    <audio id="tick-sound" src="https://raw.githubusercontent.com/nickdoneysr/Fugitive/d5f566f5618a7b98206459b6573833714b05d120/timertick.mp3" preload="auto"></audio>
    <header>
        <h1>Fugitive</h1>
        <h2>The King's Gambit</h2>
        <h3>Escape to Reclaim Your Throne</h3>
    </header>
    <main>
        <!-- Start Page -->
        <div id="start-page" class="section">
            <div id="ad-board-container"></div>
            <button id="btn-to-fugitive" aria-label="Go to Fugitive mode" title="Play the main Fugitive Chess mode where you escape from jail" tabindex="0">Fugitive</button>
            <button id="btn-to-standard" aria-label="Go to Standard Chess mode" title="Play classic chess against AI or another player" tabindex="0">Standard Chess</button>
            <button id="btn-to-creative" aria-label="Go to Creative mode" title="Design and play your own custom maps" tabindex="0">Creative Mode</button>
            <button id="btn-to-tutorial" aria-label="Go to Tutorial" title="Learn how to play Fugitive Chess step-by-step" tabindex="0">Tutorial</button>
            <button id="btn-to-settings" aria-label="Go to Settings" title="Adjust game settings, music, and view stats" tabindex="0">Settings</button>
            <button id="btn-to-rules" aria-label="Go to Rules" title="Read the rules for Fugitive Chess" tabindex="0">Rules</button>
            <button id="btn-to-tips-strategy" aria-label="Go to Tips & Strategy" title="View tips and strategies for playing Fugitive Chess" tabindex="0">Tips & Strategy</button>
            <button id="btn-to-store" aria-label="Go to Store" title="Browse Fugitive Chess merchandise and sponsor links" tabindex="0">Store</button>
            <button id="btn-random-start-page">Random Start</button>
            <!-- Campaign Mode Section -->
            <div id="campaign-mode">
                <h2>Campaign Mode</h2>
                <button id="start-campaign" class="button" aria-label="Start a new campaign" tabindex="0">Start Campaign</button>
                <button id="continue-campaign" class="button" aria-label="Continue an existing campaign" tabindex="0">Continue Campaign</button>
                <button id="select-level" class="button" aria-label="Select a campaign level" tabindex="0">Select Level</button>
            </div>
        </div>

        <!-- Fugitive Menu -->
        <div id="fugitive-menu" class="section">
            <h3>Fugitive Mode</h3>
            <button id="btn-play" aria-label="Start the game with selected settings" tabindex="0">Play</button>
            <button id="btn-random-start" aria-label="Start a game with random settings" tabindex="0">Random Start</button>
            <button id="btn-random-theme" aria-label="Set a random theme" tabindex="0">Random Theme</button>
            <button id="btn-back-to-start-fugitive" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <button id="btn-quick-start" aria-label="Start a game with default settings" tabindex="0">Quick Start</button>
            <button id="btn-beginner-preset" aria-label="Start with beginner settings" tabindex="0">Beginner Preset</button>
            <button id="btn-guided-setup" aria-label="Start guided setup for new players" tabindex="0">Guided Setup</button>
            <div id="guided-setup-modal" class="custom-modal" style="display: none;">
                <h3>Guided Setup</h3>
                <p id="guided-step-text"></p>
                <select id="guided-option" aria-label="Select option for guided setup"></select>
                <button id="guided-next" aria-label="Next step in guided setup">Next</button>
                <button id="guided-back" aria-label="Previous step in guided setup">Back</button>
                <button id="guided-finish" aria-label="Finish guided setup">Finish</button>
            </div>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('gameplay-options')">Gameplay Options</button>
                <button class="tab-button" onclick="openTab('visual-options')">Visual Options</button>
            </div>
            <div class="tab-container">
                <div id="gameplay-options" class="tab-content active">
                    <fieldset>
                        <legend>Gameplay Options</legend>
                        <div>Difficulty</div>
                        <select id="difficulty" title="Choose game difficulty. Higher levels increase guard numbers and aggression." aria-label="Choose game difficulty" tabindex="0">
                            <option value="pawn">Pawn</option>
                            <option value="knight" selected>Knight</option>
                            <option value="rook">Rook</option>
                            <option value="bishop">Bishop</option>
                            <option value="queen">Queen</option>
                            <option value="king">King</option>
                        </select>
                        <div id="level-info">Level 1</div>
                        <select id="level" title="Select the level (1-100). Affects guard types and numbers." aria-label="Select the level from 1 to 100" tabindex="0"></select>
                        <div>Turn Timer</div>
                        <select id="turn-timer" title="Enable a 30-second timer per turn when On." aria-label="Enable a 30-second turn timer" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Turn Limit</div>
                        <select id="turn-limit" title="Set a maximum number of turns (None, 5, 10, 15)." aria-label="Set a maximum number of turns" tabindex="0">
                            <option value="none">None</option>
                            <option value="5">5 Turns</option>
                            <option value="10">10 Turns</option>
                            <option value="15">15 Turns</option>
                        </select>
                        <div>Time Attack Mode</div>
                        <select id="time-attack" title="Enable a 30-minute total time limit across all levels when On." aria-label="Enable Time Attack mode" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>King Disarmed</div>
                        <select id="king-disarmed" title="Prevent the king from attacking guards when On." aria-label="Prevent the king from attacking guards" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Guards</div>
                        <select id="guards" title="Enable or disable guards on the board." aria-label="Enable or disable guards" tabindex="0">
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                        <div>Fog Vision</div>
                        <select id="fog-vision" title="Limit visibility to the king’s adjacent squares when On." aria-label="Limit visibility to the king’s adjacent squares" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Treasure Drops</div>
                        <select id="treasure-drops" title="Enable random treasure drops on the board when On." aria-label="Enable random treasure drops" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Hidden Items</div>
                        <select id="hidden-items" title="Make treasures invisible until collected when On." aria-label="Make treasures invisible until collected" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Arcade Mode</div>
                        <select id="arcade-mode" title="Enable point collection and scoring when On." aria-label="Enable point collection and scoring" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Hero Ability</div>
                        <select id="hero-ability" title="Enable the selected hero’s special ability when On." aria-label="Enable the selected hero’s special ability" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                        <div>Portals</div>
                        <select id="portals" title="Add 0-3 pairs of teleporting portals to the board." aria-label="Add 0 to 3 pairs of teleporting portals" tabindex="0">
                            <option value="0">Off</option>
                            <option value="1">1 Pair</option>
                            <option value="2">2 Pairs</option>
                            <option value="3">3 Pairs</option>
                        </select>
                        <div>Move Hints</div>
                        <select id="move-hints" title="Show hints towards the escape: Off, Next Move, or Full Path." aria-label="Show hints towards the escape" tabindex="0">
                            <option value="off">Off</option>
                            <option value="next">Next Move</option>
                            <option value="full">Full Path</option>
                        </select>
                        <div>Guard Aggression</div>
                        <select id="guard-aggression" title="Set guard movement frequency" aria-label="Set guard movement frequency" tabindex="0">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                        </select>
                        <div>Treasure Spawn Rate</div>
                        <select id="treasure-spawn-rate" title="Set treasure spawn frequency" aria-label="Set treasure spawn frequency" tabindex="0">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                        </select>
                    </fieldset>
                </div>
                <div id="visual-options" class="tab-content">
                    <fieldset>
                        <legend>Visual Options</legend>
                        <div>Theme</div>
                        <select id="theme" title="Choose the visual theme of the game board and UI." aria-label="Choose the visual theme" tabindex="0">
                            <!-- Options populated dynamically -->
                        </select>
                        <div>Piece Style</div>
                        <select id="piece-style" title="Select the style of game pieces" aria-label="Select the style of game pieces" tabindex="0">
                            <!-- Options populated dynamically -->
                        </select>
                        <button id="btn-custom-piece" aria-label="Create custom piece style" tabindex="0">Custom Piece</button>
                        <div>Hero</div>
                        <select id="hero-select" title="Choose a hero with a special ability (optional)." aria-label="Choose a hero with a special ability" tabindex="0"></select>
                        <div>
                            <label for="song-select">Select Song:</label>
                            <select id="song-select" title="Choose background music for the game." aria-label="Choose background music" tabindex="0">
                                <option value="">Select a song</option>
                            </select>
                        </div>
                        <div>Animations</div>
                        <select id="animations" title="Enable or disable animations" aria-label="Enable or disable animations" tabindex="0">
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    </fieldset>
                </div>
            </div>
            <button id="btn-options-help" aria-label="Show help for game options" tabindex="0">Options Help</button>
            <div id="options-help-modal" class="custom-modal" style="display: none;">
                <h3>Game Options Help</h3>
                <ul>
                    <li><strong>Difficulty</strong>: Choose game difficulty. Higher levels increase guard numbers and aggression.</li>
                    <li><strong>Level</strong>: Select the level (1-100). Affects guard types and numbers.</li>
                    <li><strong>Turn Timer</strong>: Enable a 30-second timer per turn when On.</li>
                    <li><strong>Turn Limit</strong>: Set a maximum number of turns (None, 5, 10, 15).</li>
                    <li><strong>King Disarmed</strong>: Prevent the king from attacking guards when On.</li>
                    <li><strong>Guards</strong>: Enable or disable guards on the board.</li>
                    <li><strong>Fog Vision</strong>: Limit visibility to the king’s adjacent squares when On.</li>
                    <li><strong>Treasure Drops</strong>: Enable random treasure drops on the board when On.</li>
                    <li><strong>Hidden Items</strong>: Make treasures invisible until collected when On.</li>
                    <li><strong>Arcade Mode</strong>: Enable point collection and scoring when On.</li>
                    <li><strong>Hero Ability</strong>: Enable the selected hero’s special ability when On.</li>
                    <li><strong>Portals</strong>: Add 0-3 pairs of teleporting portals to the board.</li>
                    <li><strong>Move Hints</strong>: Show hints towards the escape: Off, Next Move, or Full Path.</li>
                </ul>
                <button id="btn-close-options-help" aria-label="Close help modal" tabindex="0">Close</button>
            </div>
        </div>

        <!-- Game Area (Fugitive Gameplay) -->
        <div id="game-area" class="section">
            <div id="mode-instructions"></div>
            <div id="game-stats">
                <p>Turn: <span id="turn-count">0</span></p>
                <p>Moves Left: <span id="moves-left">0</span></p>
                <p>Score: <span id="score">0</span></p>
            </div>
            <div id="game-info" role="status" aria-live="polite">Roll Dice to Start</div>
            <div id="turn-timer-bar" style="height: 5px; background: green; width: 100%; transition: width 1s;"></div>
            <div id="timer-bar" style="width: 100%; height: 20px; background: #ccc; position: relative; display: none;">
                <div id="timer-progress" style="width: 100%; height: 100%; background: linear-gradient(to right, #4CAF50, #FFD700); transition: width 0.1s linear;"></div>
                <div id="timer-text" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); color: #000; font-weight: bold;"></div>
            </div>
            <canvas id="board" width="400" height="400"></canvas>
            <canvas id="mini-map" width="100" height="100" style="border: 1px solid #000; margin-left: 10px;"></canvas>
            <div id="stats" role="status" aria-live="polite">
                <p>Difficulty: <span id="difficulty-stat">Knight</span></p>
                <p>Rolls: <span id="rolls-stat">0</span></p>
                <p>Moves: <span id="moves-stat">0</span></p>
                <p>Guards: <span id="guards-stat">0</span></p>
                <p>Levels: <span id="levels-stat">0</span></p>
                <p>Avg Moves/Turn: <span id="avg-moves">0</span></p>
                <p>Treasures/Level: <span id="treasures-per-level">0</span></p>
                <p>Treasures: <span id="treasures-collected-stat">0/3</span></p>
            </div>
            <div>
                <button id="btn-roll" aria-label="Roll the dice to start your turn" tabindex="0">Roll Dice</button>
                <button id="btn-toggle-minimap" aria-label="Toggle mini-map size" tabindex="0">Toggle Mini-Map</button>
                <button id="btn-undo" aria-label="Undo your last move" tabindex="0">Undo</button>
                <button id="btn-menu" aria-label="Return to Fugitive menu" tabindex="0">Fugitive Menu</button>
                <button id="btn-reset" aria-label="Reset the current level" tabindex="0">Reset</button>
                <button id="btn-restart" aria-label="Restart the current level" tabindex="0">Restart</button>
                <button id="btn-save" aria-label="Save the current game state" tabindex="0">Save Game</button>
                <button id="btn-use-treasure" aria-label="Use a collected treasure" tabindex="0">Use Treasure</button>
                <div id="treasure-modal" class="custom-modal" style="display: none;">
                    <h3>Select a Treasure to Use</h3>
                    <div id="treasure-list"></div>
                    <button id="btn-close-treasure" aria-label="Close treasure selection" tabindex="0">Close</button>
                </div>
                <button id="btn-load" aria-label="Load a saved game" tabindex="0">Load Game</button>
                <button id="btn-back-to-start-game" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
                <button id="btn-pause-game" aria-label="Pause the game" tabindex="0">Pause</button>
                <div id="paused-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; color: white; font-size: 24px; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <div>Game Paused</div>
                    <button id="btn-resume-game" aria-label="Resume the game" tabindex="0">Resume</button>
                    <button id="btn-save-from-pause" aria-label="Save the game from pause" tabindex="0">Save Game</button>
                    <button id="btn-load-from-pause" aria-label="Load a saved game from pause" tabindex="0">Load Game</button>
                    <button id="btn-menu-from-pause" aria-label="Return to the main menu" tabindex="0">Main Menu</button>
                </div>
            </div>
            <button id="hintButton" aria-label="Get a hint" tabindex="0">Hint</button>
            <div class="mobile-controls" style="display: none; position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);">
                <button class="mobile-btn" id="btn-up-left">↖</button>
                <button class="mobile-btn" id="btn-up">↑</button>
                <button class="mobile-btn" id="btn-up-right">↗</button><br>
                <button class="mobile-btn" id="btn-left">←</button>
                <button class="mobile-btn" id="btn-down">↓</button>
                <button class="mobile-btn" id="btn-right">→</button><br>
                <button class="mobile-btn" id="btn-down-left">↙</button>
                <button class="mobile-btn" id="btn-down">↓</button>
                <button class="mobile-btn" id="btn-down-right">↘</button>
            </div>
            <button id="btn-help" aria-label="Show help and hotkeys" tabindex="0">Help</button>
            <div id="help-modal" class="custom-modal" style="display: none;">
                <h3>Controls & Hotkeys</h3>
                <ul id="help-list" style="text-align: left;"></ul>
                <button id="btn-close-help" aria-label="Close help modal" tabindex="0">Close</button>
            </div>
        </div>

        <!-- Campaign Mode Section -->
        <div id="campaign-mode" class="section">
            <h2>Campaign Mode</h2>
            <button id="start-campaign">Start Campaign</button>
            <button id="continue-campaign">Continue Campaign</button>
            <button id="select-level">Select Level</button>
        </div>

        <!-- Level Selection Modal -->
        <div id="level-selection" class="custom-modal" style="display: none;">
            <h3>Select Prison</h3>
            <div id="prison-list">
                <!-- Prison levels will be populated dynamically via JavaScript -->
            </div>
            <button id="close-level-selection" class="button" aria-label="Close level selection modal" tabindex="0">Close</button>
        </div>

        <!-- Campaign Completion Modal -->
        <div id="campaign-completion" class="custom-modal" style="display: none;">
            <h3>Congratulations!</h3>
            <p>You escaped from <span id="completed-prison"></span>!</p>
            <button id="continue-to-next" class="button" aria-label="Continue to the next prison" tabindex="0">Continue to Next Prison</button>
            <button id="back-to-menu" class="button" aria-label="Return to main menu" tabindex="0">Main Menu</button>
        </div>

        <!-- Campaign Failure Modal -->
        <div id="campaign-failure" class="custom-modal" style="display: none;">
            <h3>Oh No!</h3>
            <p>You were captured in <span id="failed-prison"></span>.</p>
            <button id="retry-prison" class="button" aria-label="Retry the current prison" tabindex="0">Retry</button>
            <button id="back-to-menu-failure" class="button" aria-label="Return to main menu" tabindex="0">Main Menu</button>
        </div>

        <!-- Standard Mode -->
        <div id="standard-chess-section" class="section">
            <h3>Standard Chess</h3>
            <canvas id="standard-chess-board" width="400" height="400"></canvas>
            <button id="btn-standard-play" aria-label="Start Standard Chess" tabindex="0">Play</button>
            <button id="btn-standard-random-theme" aria-label="Set a random theme" tabindex="0">Random Theme</button>
            <button id="btn-standard-quick-start" aria-label="Start a standard chess game with default settings" tabindex="0">Quick Start</button>
            <button id="btn-hint" aria-label="Get a hint" tabindex="0">Hint</button>
            <button id="btn-standard-undo" aria-label="Undo last move" tabindex="0">Undo</button>
            <button id="btn-resign" aria-label="Resign the game" tabindex="0">Resign</button>
            <button id="btn-standard-reset" aria-label="Reset the game" tabindex="0">Reset</button>
            <button id="btn-back-to-start-standard" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('standard-game-options')">Game Options</button>
                <button class="tab-button" onclick="openTab('standard-visual-options')">Visual Options</button>
            </div>
            <div class="tab-container">
                <div id="standard-game-options" class="tab-content" style="display: block;">
                    <fieldset>
                        <legend>Game Options</legend>
                        <div>Difficulty</div>
                        <select id="standard-difficulty" title="Choose AI difficulty" aria-label="Choose AI difficulty" tabindex="0">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                        <div>Opponent</div>
                        <select id="standard-opponent" title="Choose opponent type" aria-label="Choose opponent type" tabindex="0">
                            <option value="ai">AI</option>
                            <option value="human">Human</option>
                        </select>
                        <div>Turn Timer</div>
                        <select id="standard-turn-timer" title="Enable a 30-second timer per turn when On" aria-label="Enable a 30-second turn timer" tabindex="0">
                            <option value="off">Off</option>
                            <option value="on">On</option>
                        </select>
                    </fieldset>
                </div>
                <div id="standard-visual-options" class="tab-content">
                    <fieldset>
                        <legend>Visual Options</legend>
                        <div>Theme</div>
                        <select id="standard-theme" title="Choose the visual theme of the game board and UI" aria-label="Choose the visual theme" tabindex="0">
                            <!-- Options will be populated dynamically from existing themes -->
                        </select>
                        <div>White Piece Style</div>
                        <select id="standard-white-piece-style" title="Select the style of white pieces" aria-label="Select the style of white pieces" tabindex="0">
                            <!-- Options will be populated dynamically -->
                        </select>
                        <div>Black Piece Style</div>
                        <select id="standard-black-piece-style" title="Select the style of black pieces" aria-label="Select the style of black pieces" tabindex="0">
                            <!-- Options will be populated dynamically -->
                        </select>
                        <div>Hero</div>
                        <select id="standard-hero-select" title="Choose a hero to replace the king visually" aria-label="Choose a hero to replace the king visually" tabindex="0">
                            <option value="-1">None Selected</option>
                            <!-- Options will be populated dynamically -->
                        </select>
                        <div>
                            <label for="standard-song-select">Select Song:</label>
                            <select id="standard-song-select" title="Choose background music for the game" aria-label="Choose background music" tabindex="0">
                                <option value="">Select a song</option>
                                <!-- Options will be populated dynamically -->
                            </select>
                        </div>
                    </fieldset>
                </div>
            </div>
            <div id="standard-game-info">White to move</div>
            <div id="move-history" style="max-height: 200px; overflow-y: auto; margin-top: 10px; font-size: 14px; color: #333;"></div>
        </div>

        <!-- Creative Mode -->
        <div id="creative-mode" class="section">
            <h3>Creative Mode</h3>
            <button id="btn-back-to-start-creative" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('placement-options')">Placement Options</button>
                <button class="tab-button" onclick="openTab('map-management')">Map Management</button>
            </div>
            <div class="tab-container">
                <div id="placement-options" class="tab-content" style="display: block;">
                    <fieldset>
                        <legend>Placement Tools</legend>
                        <div id="creative-tools">
                            <button id="btn-place-king" aria-label="Place the king on the board" tabindex="0">Place King</button>
                            <button id="btn-place-jail" aria-label="Place the jail on the board" tabindex="0">Place Jail</button>
                            <button id="btn-place-escape" aria-label="Place the escape point on the board" tabindex="0">Place Escape</button>
                            <select id="guard-type" title="Choose guard type to place" aria-label="Choose guard type to place" tabindex="0">
                                <option value="pawn">Pawn</option>
                                <option value="rook">Rook</option>
                                <option value="knight">Knight</option>
                                <option value="bishop">Bishop</option>
                                <option value="queen">Queen</option>
                                <option value="sentry">Sentry</option>
                            </select>
                            <div>Guard Behavior</div>
                            <select id="guard-behavior" title="Choose guard behavior" aria-label="Choose guard behavior" tabindex="0">
                                <option value="passive">Passive</option>
                                <option value="aggressive">Aggressive</option>
                                <option value="patrolling">Patrolling</option>
                            </select>
                            <button id="btn-place-guard" aria-label="Place a guard on the board" tabindex="0">Place Guard</button>
                            <button id="btn-place-block" aria-label="Place a block on the board" tabindex="0">Place Block</button>
                            <button id="btn-batch-block" aria-label="Place multiple blocks" tabindex="0">Batch Blocks</button>
                            <input type="number" id="batch-count" min="1" max="10" value="5" style="width: 50px;" aria-label="Number of blocks to place">
                            <select id="treasure-type" title="Choose treasure type to place" aria-label="Choose treasure type to place" tabindex="0">
                                <option value="diamond">Diamond</option>
                                <option value="key">Key</option>
                                <option value="gold">Gold</option>
                                <option value="shield">Shield</option>
                                <option value="sword">Sword</option>
                                <option value="boots">Boots</option>
                                <option value="spyglass">Spyglass</option>
                                <option value="portal">Portal</option>
                                <option value="potion">Potion</option>
                                <option value="map">Map</option>
                                <option value="trident">Trident</option>
                                <option value="excalibur">Excalibur</option>
                                <option value="mjolnir">Mjolnir</option>
                                <option value="grail">Grail</option>
                                <option value="horn">Horn</option>
                                <option value="bow">Bow</option>
                                <option value="crown">Crown</option>
                                <option value="feather">Feather</option>
                                <option value="eye">Eye</option>
                                <option value="storm">Storm</option>
                                <option value="cloak">Cloak</option>
                            </select>
                            <button id="btn-place-treasure" aria-label="Place a treasure on the board" tabindex="0">Place Treasure</button>
                            <button id="btn-place-portal" aria-label="Place a portal on the board" tabindex="0">Place Portal</button>
                            <select id="terrain-type" title="Choose terrain type to place" aria-label="Choose terrain type to place" tabindex="0">
                                <option value="forest">Forest</option>
                                <option value="water">Water</option>
                            </select>
                            <button id="btn-place-terrain" aria-label="Place terrain on the board" tabindex="0">Place Terrain</button>
                            <button id="btn-batch-terrain" aria-label="Place multiple terrain tiles" tabindex="0">Batch Terrain</button>
                            <input type="number" id="batch-terrain-count" min="1" max="10" value="5" style="width: 50px;" aria-label="Number of terrain tiles to place">
                        </div>
                        <div id="hero-customization">
                            <h4>Create Custom Hero</h4>
                            <input type="text" id="hero-name" placeholder="Hero Name" aria-label="Enter custom hero name">
                            <select id="hero-ability-creative" title="Choose the hero's special ability" aria-label="Choose hero ability" tabindex="0">
                                <option value="strength">Strength (Defeat adjacent guards)</option>
                                <option value="magic">Magic (Random treasure effect)</option>
                                <option value="stealth">Stealth (Move undetected)</option>
                                <option value="charge">Charge (Double moves)</option>
                            </select>
                            <button id="btn-create-hero" aria-label="Create custom hero" tabindex="0">Create Hero</button>
                        </div>
                    </fieldset>
                </div>
                <div id="map-management" class="tab-content">
                    <fieldset>
                        <legend>Map Management</legend>
                        <button id="btn-remove" aria-label="Remove an element from the board" tabindex="0">Remove Element</button>
                        <button id="btn-undo" aria-label="Undo last action" tabindex="0">Undo</button>
                        <button id="btn-redo" aria-label="Redo last undone action" tabindex="0">Redo</button>
                        <button id="btn-test-map" aria-label="Test the current map" tabindex="0">Test Map</button>
                        <button id="btn-save-map" aria-label="Save the current map" tabindex="0">Save Map</button>
                        <button id="btn-load-map" aria-label="Load a saved map" tabindex="0">Load Map</button>
                        <button id="btn-export-map" aria-label="Export current map" tabindex="0">Export Map</button>
                        <button id="btn-import-map" aria-label="Import a map" tabindex="0">Import Map</button>
                        <button id="btn-clear-board" aria-label="Clear the board" tabindex="0">Clear Map</button>
                        <button id="btn-random-map" aria-label="Generate a random map" tabindex="0">Random Map</button>
                        <button id="btn-play-creative" aria-label="Play the current map" tabindex="0">Play Map</button>
                        <div id="saved-maps">
                            <h4>Saved Maps</h4>
                            <div id="maps-list"></div>
                        </div>
                    </fieldset>
                </div>
            </div>
            <canvas id="creative-board" width="400" height="400"></canvas>
        </div>

        <!-- Tutorial Section -->
        <div id="tutorial-section" class="section">
            <h3>Tutorial</h3>
            <button id="btn-back-to-start-tutorial" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('tutorial-instructions')">Instructions</button>
                <button class="tab-button" onclick="openTab('tutorial-controls')">Controls</button>
            </div>
            <div class="tab-container">
                <div id="tutorial-instructions" class="tab-content" style="display: block;">
                    <fieldset>
                        <legend>Tutorial Instructions</legend>
                        <div id="tutorial-info">Welcome to the Tutorial! Follow the instructions below.</div>
                        <button id="btn-start-tutorial" aria-label="Start the tutorial" tabindex="0">Start Tutorial</button>
                        <button id="btn-next-tutorial" aria-label="Proceed to the next tutorial step" style="display: none;" tabindex="0">Next Step</button>
                        <button id="btn-skip-tutorial" aria-label="Skip the tutorial" tabindex="0">Skip Tutorial</button>
                    </fieldset>
                </div>
                <div id="tutorial-controls" class="tab-content">
                    <fieldset>
                        <legend>Controls</legend>
                        <ul style="text-align: left;">
                            <li><strong>Space:</strong> Roll dice (when waiting)</li>
                            <li><strong>Arrow Keys/WASD:</strong> Move king</li>
                            <li><strong>Q/E/Z/C:</strong> Move diagonally</li>
                            <li><strong>H:</strong> Use hero ability (if enabled)</li>
                        </ul>
                    </fieldset>
                </div>
            </div>
            <canvas id="tutorial-board" width="400" height="400"></canvas>
        </div>

        <!-- Settings Section -->
        <div id="settings-section" class="section">
            <h3>Settings</h3>
            <button id="btn-back-to-start-settings" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <div class="tab-buttons">
                <button class="tab-button active" onclick="openTab('audio-settings')">Audio Settings</button>
                <button class="tab-button" onclick="openTab('game-settings')">Game Settings</button>
            </div>
            <div class="tab-container">
                <div id="audio-settings" class="tab-content" style="display: block;">
                    <fieldset>
                        <legend>Audio Settings</legend>
                        <label for="music-volume">Music Volume:</label>
                        <input type="range" id="music-volume" min="0" max="1" step="0.01" value="1" aria-label="Adjust music volume" tabindex="0">
                        <button id="btn-mute-music" aria-label="Mute or unmute music" tabindex="0">🔇</button>
                        <label for="sfx-volume">Sound Effects Volume:</label>
                        <input type="range" id="sfx-volume" min="0" max="1" step="0.01" value="1" aria-label="Adjust sound effects volume" tabindex="0">
                        <button id="btn-mute-sfx" aria-label="Mute or unmute sound effects" tabindex="0">🔇</button>
                        <div id="playlist-settings">
                            <h4>Music Playlist</h4>
                            <div id="song-list"></div>
                            <div>
                                <label for="play-order">Play Order:</label>
                                <select id="play-order">
                                    <option value="normal">Normal</option>
                                    <option value="random">Random</option>
                                </select>
                            </div>
                        </div>
                    </fieldset>
                </div>
                <div id="game-settings" class="tab-content">
                    <fieldset>
                        <legend>Game Settings</legend>
                        <div>
                            <label for="light-color">Light Square Color:</label>
                            <input type="color" id="light-color" value="#f5f5f5">
                        </div>
                        <div>
                            <label for="dark-color">Dark Square Color:</label>
                            <input type="color" id="dark-color" value="#a0a0a0">
                        </div>
                        <button id="btn-to-achievements" aria-label="Go to Achievements" tabindex="0">Achievements</button>
                        <button id="btn-save-theme" aria-label="Save the current theme" tabindex="0">Save Current Theme</button>
                        <button id="btn-customize-theme" aria-label="Customize a new theme" tabindex="0">Customize Theme</button>
                        <button id="btn-clear-saves" aria-label="Clear saved games" tabindex="0">Clear Saves</button>
                        <button id="btn-clear-stats" aria-label="Clear statistics" tabindex="0">Clear Stats</button>
                        <button id="btn-clear-themes" aria-label="Clear custom themes" tabindex="0">Clear Custom Themes</button>
                        <button id="btn-clear-achievements" aria-label="Clear achievements" tabindex="0">Clear Achievements</button>
                        <div id="stats-display">
                            <h3>Statistics</h3>
                            <p>Games Played: <span id="games-played">0</span></p>
                            <p>Wins: <span id="wins">0</span></p>
                            <p>Losses: <span id="losses">0</span></p>
                            <p>Total Moves: <span id="total-moves">0</span></p>
                            <p>Total Rolls: <span id="total-rolls">0</span></p>
                            <p>Guards Defeated: <span id="guards-defeated">0</span></p>
                            <p>Treasures Collected: <span id="treasures-collected">0</span></p>
                            <p>Highest Score: <span id="highest-score">0</span></p>
                            <p>Achievements Unlocked: <span id="achievements-unlocked">0</span></p>
                            <p>Total Time Played: <span id="total-time-played">0h 0m 0s</span></p>
                        </div>
                    </fieldset>
                </div>
            </div>
            <div id="leaderboard" style="margin-top: 20px;">
                <h4>Leaderboard</h4>
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #ddd;">
                            <th style="padding: 5px;">Rank</th>
                            <th style="padding: 5px;">Name</th>
                            <th style="padding: 5px;">Score</th>
                            <th style="padding: 5px;">Level</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body"></tbody>
                </table>
            </div>
        </div>

        <!-- Achievements Section -->
        <div id="achievements-section" class="section">
            <h3>Achievements</h3>
            <div id="achievements-list"></div>
            <button id="btn-back-to-start-achievements" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <button id="btn-back-to-settings-achievements" aria-label="Return to the settings section" tabindex="0">Back to Settings Section</button>
        </div>

        <!-- Rules Section -->
        <div id="rules-content" class="section">
            <button id="btn-back-from-rules" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <details>
                <summary>Goal</summary>
                <p>Escape from jail (red square) to the safe spot (green square) as the king or a selected hero, avoiding guards.</p>
            </details>
            <details>
                <summary>Play</summary>
                <ul>
                    <li>Choose difficulty, level, theme, piece style, and optionally a hero.</li>
                    <li>Toggle options: Turn Timer, Turn Limit, King Disarmed, Guards, Treasure Drops, Hidden Items, Hero Ability.</li>
                    <li>Click Play or Random Start.</li>
                    <li>Black walls block paths.</li>
                    <li>Press Space to roll dice (1–6 moves). Use arrow keys or WASD to move.</li>
                    <li>Move (1 move per square) or attack guards (1 move, removes them, ends turn, unless King Disarmed).</li>
                    <li>Collect treasures for special abilities (if enabled).</li>
                    <li>Use hero abilities (if enabled).</li>
                    <li>Reset: new board; Restart: same board; Menu: return to menu.</li>
                </ul>
            </details>
            <details>
                <summary>Pieces</summary>
                <ul>
                    <li><strong>King/Hero:</strong> Moves one square in any direction.</li>
                    <li><strong>Pawn:</strong> Moves diagonally towards you.</li>
                    <li><strong>Rook:</strong> Moves horizontally or vertically towards you.</li>
                    <li><strong>Knight:</strong> Moves in an L-shape.</li>
                    <li><strong>Bishop:</strong> Moves diagonally towards you.</li>
                    <li><strong>Queen:</strong> Moves in any direction towards you.</li>
                </ul>
            </details>
            <details>
                <summary>Options</summary>
                <ul>
                    <li><strong>Turn Timer:</strong> Limits time per turn to 30s when On.</li>
                    <li><strong>Turn Limit:</strong> Ends game if exceeded (None, 5, 10, 15 turns).</li>
                    <li><strong>King Disarmed:</strong> Prevents attacking guards when On.</li>
                    <li><strong>Guards:</strong> Enables/disables guards.</li>
                    <li><strong>Treasure Drops:</strong> Enables random treasure items on the board.</li>
                    <li><strong>Hidden Items:</strong> Makes treasure items invisible until collected.</li>
                    <li><strong>Hero Ability:</strong> Allows the selected hero to use their special ability.</li>
                    <li><strong>Portals:</strong> Adds 0 to 3 pairs of linked portals on the board.</li>
                    <li><strong>Arcade Mode:</strong> Point items (①, ⑤, ⑩) drop, awarding 1, 5, or 10 points. Killing a guard awards 10 points.</li>
                </ul>
            </details>
            <details>
                <summary>Definitions</summary>
                <div>
                    <details>
                        <summary>Heroes</summary>
                        <p>Heroes are special characters you can choose to play as instead of the default King. Each hero has a unique ability that can aid in your escape, with a cooldown period (in turns) or limited uses where specified.</p>
                        <ul>
                            <li><strong>Hercules</strong> (🦸): <em>Strength</em> - Defeat guards in adjacent squares (Cooldown: 3 turns)</li>
                            <li><strong>Merlin</strong> (🧙): <em>Magic</em> - Cast a random treasure effect (Cooldown: 2 turns)</li>
                            <li><strong>Hattori Hanzo</strong> (🥷): <em>Stealth</em> - Move through guards undetected (Cooldown: 4 turns)</li>
                            <li><strong>Miyamoto Musashi</strong> (🤺): <em>Duel</em> - Challenge and defeat a guard (Cooldown: 3 turns)</li>
                            <li><strong>Alexander the Great</strong> (🏇): <em>Charge</em> - Move double distance (Cooldown: 3 turns)</li>
                            <li><strong>Cleopatra</strong> (👸): <em>Charm</em> - Distract all guards (Cooldown: 4 turns)</li>
                            <li><strong>Prince Siddhartha</strong> (🤴): <em>Peace</em> - Prevent guard attacks for one turn (Cooldown: 2 turns)</li>
                            <li><strong>Archangel Michael</strong> (👼): <em>Protection</em> - Invincibility for one turn (Cooldown: 3 turns)</li>
                            <li><strong>King Solomon</strong> (👨‍⚖️): <em>Wisdom</em> - Reveal optimal path (Cooldown: 2 turns)</li>
                            <li><strong>Yuri Gagarin</strong> (👨‍🚀): <em>Explore</em> - Teleport to any square (Cooldown: 5 turns)</li>
                            <li><strong>Jesus Christ</strong> (✝️): <em>Resurrection</em> - Revive if captured once (Cooldown: 5 turns)</li>
                            <li><strong>Loki</strong> (🦹): <em>Trickery</em> - Swap places with a guard (Cooldown: 4 turns)</li>
                            <li><strong>The Oracle</strong> (🔮): <em>Reveal</em> - Reveal all guard positions for one turn (Cooldown: 2 turns)</li>
                            <li><strong>Robin Hood</strong> (🏹): <em>Ranged Attack</em> - Defeat a guard from afar (Cooldown: 3 turns)</li>
                            <li><strong>Hades</strong> (👤): <em>Disable Vision</em> - Disable a guard's vision for one turn (Cooldown: 2 turns)</li>
                            <li><strong>Jade Emperor</strong> (🧙‍♂️): <em>Time Warp</em> - Stun all guards for one turn (Cooldown: 4 turns)</li>
                            <li><strong>Oberon</strong> (🧙‍♂️): <em>Spell</em> - Cast a spell to stun all guards for one turn (Cooldown: 4 turns)</li>
                            <li><strong>Odysseus</strong> (🦹‍♂️): <em>Steal</em> - Steal a treasure from a nearby guard (Cooldown: 3 turns)</li>
                            <li><strong>Claudius</strong> (🗡️): <em>Assassinate</em> - Silently eliminate a guard within two squares (Cooldown: 3 turns)</li>
                            <li><strong>Morozko</strong> (❄️): <em>Freeze</em> - Freeze all guards for two turns (Cooldown: 4 turns)</li>
                            <li><strong>Kronos</strong> (⏳): <em>Time Skip</em> - Skip a guard's turn (Cooldown: 4 turns)</li>
                            <li><strong>Proteus</strong> (🪄): <em>Decoy</em> - Create a decoy that distracts guards (Cooldown: 3 turns)</li>
                            <li><strong>Odin</strong> (🌀): <em>Teleport</em> - Teleport to any square (3 uses)</li>
                            <li><strong>Yama</strong> (👻): <em>Intangibility</em> - Pass through walls for 3 moves (Cooldown: 4 turns, 3 uses)</li>
                            <li><strong>Zephyr</strong> (🌬️): <em>Windwalk</em> - Ignore blocks for one turn (Cooldown: 4 turns)</li>
                            <li><strong>Zeus</strong> (⚡): <em>Ranged Attack</em> - Defeat a guard from within two spaces (Cooldown: 2 turns)</li>
                        </ul>
                    </details>
                    <details>
                        <summary>Treasures</summary>
                        <p>Treasures are collectible items scattered across the board (if Treasure Drops are enabled). They provide special advantages or effects when collected, with durations specified where applicable.</p>
                        <ul>
                            <li><strong>Diamond</strong> (💎): <em>Reroll</em> - Reroll the dice</li>
                            <li><strong>Key</strong> (🗝️): <em>Unlock</em> - Unlock a hidden path</li>
                            <li><strong>Gold</strong> (💰): <em>Score</em> - Gain 100 points</li>
                            <li><strong>Shield</strong> (🛡️): <em>Invincible</em> - Invincible for one turn</li>
                            <li><strong>Sword</strong> (⚔️): <em>Attack</em> - Extra attack</li>
                            <li><strong>Boots</strong> (🏃): <em>Double Moves</em> - Double moves for one roll</li>
                            <li><strong>Spyglass</strong> (🔍): <em>Reveal Guards</em> - Reveal all guard vision</li>
                            <li><strong>Portal</strong> (🕳️): <em>Teleport</em> - Teleport to random square</li>
                            <li><strong>Potion</strong> (🧪): <em>Restore Moves</em> - Restore moves</li>
                            <li><strong>Map</strong> (📜): <em>Reveal Treasures</em> - Reveal all treasures</li>
                            <li><strong>Trident</strong> (🔱): <em>Push Guards</em> - Push guards back</li>
                            <li><strong>Excalibur</strong> (🗡️): <em>Defeat Guard</em> - Defeat any guard</li>
                            <li><strong>Mjolnir</strong> (🔨): <em>Stun Guards</em> - Stun all guards</li>
                            <li><strong>Grail</strong> (🍷): <em>Invincible</em> - Invincible for two turns</li>
                            <li><strong>Horn</strong> (📯): <em>Distract Guards</em> - Distract guards</li>
                            <li><strong>Bow</strong> (🏹): <em>Ranged Attack</em> - Attack from afar</li>
                            <li><strong>Crown</strong> (👑): <em>Double Score</em> - Double score</li>
                            <li><strong>Feather</strong> (🪶): <em>Fly</em> - Fly over walls</li>
                            <li><strong>Eye</strong> (🧿): <em>See Through</em> - See through walls</li>
                            <li><strong>Storm</strong> (🌩️): <em>Disrupt Vision</em> - Disrupt guard vision</li>
                            <li><strong>Phase Stone</strong> (🌌): <em>Phase</em> - Move through walls for 3 moves</li>
                            <li><strong>Cloak</strong> (🧥): <em>Invisibility</em> - Become invisible for 3 moves</li>
                            <li><strong>Lantern</strong> (🏮): <em>Disable Fog</em> - Disable fog vision for 3 turns</li>
                            <li><strong>Bomb</strong> (💣): <em>Destroy Walls</em> - Destroy adjacent walls</li>
                            <li><strong>Time Crystal</strong> (⏳): <em>Time Freeze</em> - Freeze guards for two turns</li>
                            <li><strong>Mirror</strong> (🪞): <em>Reflect</em> - Reflect guard vision back at them for one turn</li>
                            <li><strong>Whirlwind</strong> (🌪️): <em>Shuffle</em> - Randomly reposition all guards</li>
                            <li><strong>Compass</strong> (🧭): <em>Disable Fog</em> - Disable fog vision for 5 turns</li>
                            <li><strong>Speed Boost</strong> (🏃): <em>Speed</em> - Double moves for one turn</li>
                            <li><strong>Decoy</strong> (👥): <em>Decoy</em> - Create a decoy that distracts guards for 3 turns</li>
                            <li><strong>Wall Breaker</strong> (🔨): <em>Break Wall</em> - Destroy one blocked square</li>
                            <li><strong>Vision Enhancer</strong> (👁️): <em>Reveal</em> - Reveal all guards for 3 turns</li>
                        </ul>
                    </details>
                    <details>
                        <summary>Prisons</summary>
                        <p>Prisons are the various settings in which the game takes place. Each prison offers a unique environment and challenge, defined by the number of guards and the difficulty level. The following is a complete list of available prisons:</p>
                        <ul>
                            <li>Alcatraz Island - Guards: 5, Difficulty: Knight</li>
                            <li>Rikers Island - Guards: 6, Difficulty: Knight</li>
                            <li>San Quentin State Prison - Guards: 7, Difficulty: Rook</li>
                            <li>ADX Florence - Guards: 8, Difficulty: Rook</li>
                            <li>USP Marion - Guards: 5, Difficulty: Knight</li>
                            <li>Walla Walla State Penitentiary - Guards: 6, Difficulty: Knight</li>
                            <li>Eastern State Penitentiary - Guards: 4, Difficulty: Pawn</li>
                            <li>La Sabaneta Prison - Guards: 7, Difficulty: Rook</li>
                            <li>Bang Kwang Central Prison - Guards: 8, Difficulty: Rook</li>
                            <li>Puerto de Asturias Prison - Guards: 5, Difficulty: Knight</li>
                            <li>Cellular Jail - Guards: 6, Difficulty: Knight</li>
                            <li>Hỏa Lò Prison - Guards: 4, Difficulty: Pawn</li>
                            <li>Andersonville Prison - Guards: 7, Difficulty: Rook</li>
                            <li>Folsom State Prison - Guards: 5, Difficulty: Knight</li>
                            <li>Belmarsh Prison - Guards: 6, Difficulty: Knight</li>
                            <li>Guantanamo Bay - Guards: 8, Difficulty: Rook</li>
                            <li>Baikonur Prison - Guards: 5, Difficulty: Knight</li>
                            <li>Devil’s Island - Guards: 7, Difficulty: Rook</li>
                            <li>Robben Island - Guards: 4, Difficulty: Pawn</li>
                            <li>The Tower of London - Guards: 6, Difficulty: Knight</li>
                            <li>Reading Gaol - Guards: 5, Difficulty: Knight</li>
                            <li>Wormwood Scrubs - Guards: 6, Difficulty: Knight</li>
                            <li>Château d’If - Guards: 7, Difficulty: Rook</li>
                            <li>The Bastille - Guards: 5, Difficulty: Knight</li>
                            <li>Spandau Prison - Guards: 6, Difficulty: Knight</li>
                            <li>Tadmor Prison - Guards: 8, Difficulty: Rook</li>
                            <li>Ryukyu - Guards: 4, Difficulty: Pawn</li>
                            <li>Port Arthur - Guards: 5, Difficulty: Knight</li>
                            <li>The Labyrinth - Guards: 7, Difficulty: Rook</li>
                            <li>Tartarus - Guards: 9, Difficulty: Queen</li>
                        </ul>
                    </details>
                    <details>
                        <summary>Theme Styles</summary>
                        <p>Theme Styles alter the visual appearance of the game, affecting the colors of the board squares (light and dark), background, buttons, text, and the font used. Below is the complete list of over 70 unique themes available, each providing a distinct aesthetic to enhance the gaming experience. Each theme is defined with its specific light and dark square colors and font style as specified in the game’s settings.</p>
                        <dl>
                            <dt><strong>Light</strong></dt>
                            <dd>Light Color - #f5f5f5, Dark Color - #a0a0a0, Font - Arial, sans-serif</dd>
                            <dt><strong>Dark</strong></dt>
                            <dd>Light Color - #555, Dark Color - #222, Font - Arial, sans-serif</dd>
                            <dt><strong>Greyscale</strong></dt>
                            <dd>Light Color - #ccc, Dark Color - #666, Font - Cabin, sans-serif</dd>
                            <dt><strong>RGB</strong></dt>
                            <dd>Light Color - #f00, Dark Color - #0f0, Font - Orbitron, sans-serif</dd>
                            <dt><strong>90s</strong></dt>
                            <dd>Light Color - #ff69b4, Dark Color - #00ced1, Font - VCR OSD Mono, monospace</dd>
                            <dt><strong>80s</strong></dt>
                            <dd>Light Color - #ff00ff, Dark Color - #00ffff, Font - Press Start 2P, cursive</dd>
                            <dt><strong>70s</strong></dt>
                            <dd>Light Color - #ffa500, Dark Color - #8b4513, Font - Bubblegum Sans, cursive</dd>
                            <dt><strong>Neon</strong></dt>
                            <dd>Light Color - #ff0, Dark Color - #0ff, Font - Audiowide, cursive</dd>
                            <dt><strong>Paint</strong></dt>
                            <dd>Light Color - #ff9999, Dark Color - #99ccff, Font - Permanent Marker, cursive</dd>
                            <dt><strong>Galaxy</strong></dt>
                            <dd>Light Color - #d8bfd8, Dark Color - #4b0082, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Pirate</strong></dt>
                            <dd>Light Color - #d2b48c, Dark Color - #8b4513, Font - Hanalei Fill, cursive</dd>
                            <dt><strong>Cyberpunk</strong></dt>
                            <dd>Light Color - #00ffff, Dark Color - #ff00ff, Font - Rajdhani, sans-serif</dd>
                            <dt><strong>Retro-Arcade</strong></dt>
                            <dd>Light Color - #ff4500, Dark Color - #000080, Font - Press Start 2P, cursive</dd>
                            <dt><strong>Nature</strong></dt>
                            <dd>Light Color - #98fb98, Dark Color - #228b22, Font - Cabin, sans-serif</dd>
                            <dt><strong>Steampunk</strong></dt>
                            <dd>Light Color - #cd853f, Dark Color - #8b4513, Font - MedievalSharp, cursive</dd>
                            <dt><strong>Mythology</strong></dt>
                            <dd>Light Color - #ffd700, Dark Color - #b8860b, Font - MedievalSharp, cursive</dd>
                            <dt><strong>Underwater</strong></dt>
                            <dd>Light Color - #00ced1, Dark Color - #1e90ff, Font - Cabin, sans-serif</dd>
                            <dt><strong>Desert</strong></dt>
                            <dd>Light Color - #f4a460, Dark Color - #cd853f, Font - Rajdhani, sans-serif</dd>
                            <dt><strong>Jungle</strong></dt>
                            <dd>Light Color - #9acd32, Dark Color - #228b22, Font - Cabin, sans-serif</dd>
                            <dt><strong>Space</strong></dt>
                            <dd>Light Color - #e6e6fa, Dark Color - #483d8b, Font - Orbitron, sans-serif</dd>
                            <dt><strong>Ice</strong></dt>
                            <dd>Light Color - #f0f8ff, Dark Color - #b0c4de, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Volcano</strong></dt>
                            <dd>Light Color - #ff4500, Dark Color - #8b0000, Font - Bebas Neue, sans-serif</dd>
                            <dt><strong>Candy</strong></dt>
                            <dd>Light Color - #ff69b4, Dark Color - #ff1493, Font - Bubblegum Sans, cursive</dd>
                            <dt><strong>Haunted</strong></dt>
                            <dd>Light Color - #778899, Dark Color - #2f2f2f, Font - Creepster, cursive</dd>
                            <dt><strong>Circus</strong></dt>
                            <dd>Light Color - #ff0000, Dark Color - #ffd700, Font - Permanent Marker, cursive</dd>
                            <dt><strong>Dream</strong></dt>
                            <dd>Light Color - #dda0dd, Dark Color - #9370db, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Noir</strong></dt>
                            <dd>Light Color - #696969, Dark Color - #2f2f2f, Font - Nosifer, cursive</dd>
                            <dt><strong>Forest</strong></dt>
                            <dd>Light Color - #228B22, Dark Color - #8B4513, Font - Cabin, sans-serif</dd>
                            <dt><strong>Spring</strong></dt>
                            <dd>Light Color - #98FB98, Dark Color - #FFB6C1, Font - Playfair Display, serif</dd>
                            <dt><strong>Summer</strong></dt>
                            <dd>Light Color - #FFFF00, Dark Color - #FFA500, Font - Lobster, cursive</dd>
                            <dt><strong>Autumn</strong></dt>
                            <dd>Light Color - #F5F5DC, Dark Color - #A52A2A, Font - Merriweather, serif</dd>
                            <dt><strong>Winter</strong></dt>
                            <dd>Light Color - #FFFFFF, Dark Color - #ADD8E6, Font - Roboto, sans-serif</dd>
                            <dt><strong>Renaissance</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #800000, Font - Cinzel, serif</dd>
                            <dt><strong>Victorian</strong></dt>
                            <dd>Light Color - #D3D3D3, Dark Color - #696969, Font - Old Standard TT, serif</dd>
                            <dt><strong>Art-Deco</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #000000, Font - Abril Fatface, cursive</dd>
                            <dt><strong>Ancient-Egypt</strong></dt>
                            <dd>Light Color - #F4C430, Dark Color - #8B4513, Font - Papyrus, fantasy</dd>
                            <dt><strong>Samurai</strong></dt>
                            <dd>Light Color - #D3D3D3, Dark Color - #000000, Font - Noto Serif JP, serif</dd>
                            <dt><strong>Fantasy</strong></dt>
                            <dd>Light Color - #E6E6FA, Dark Color - #9370DB, Font - Uncial Antiqua, cursive</dd>
                            <dt><strong>Sci-Fi</strong></dt>
                            <dd>Light Color - #00FF00, Dark Color - #0000FF, Font - Orbitron, sans-serif</dd>
                            <dt><strong>Steampunk-New</strong></dt>
                            <dd>Light Color - #DAA520, Dark Color - #8B4513, Font - Special Elite, cursive</dd>
                            <dt><strong>Cyberpunk-New</strong></dt>
                            <dd>Light Color - #FF00FF, Dark Color - #00FFFF, Font - Share Tech Mono, monospace</dd>
                            <dt><strong>Mythical</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #4B0082, Font - MedievalSharp, cursive</dd>
                            <dt><strong>Ocean</strong></dt>
                            <dd>Light Color - #00CED1, Dark Color - #4682B4, Font - Cabin, sans-serif</dd>
                            <dt><strong>Desert-New</strong></dt>
                            <dd>Light Color - #F4A460, Dark Color - #CD853F, Font - Rajdhani, sans-serif</dd>
                            <dt><strong>Mountains</strong></dt>
                            <dd>Light Color - #B0C4DE, Dark Color - #4682B4, Font - Lato, sans-serif</dd>
                            <dt><strong>Forest-New</strong></dt>
                            <dd>Light Color - #228B22, Dark Color - #8B4513, Font - Cabin, sans-serif</dd>
                            <dt><strong>Jungle-New</strong></dt>
                            <dd>Light predation - #9ACD32, Dark Color - #228B22, Font - Cabin, sans-serif</dd>
                            <dt><strong>Arctic</strong></dt>
                            <dd>Light Color - #F0F8FF, Dark Color - #B0C4DE, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Minimalist</strong></dt>
                            <dd>Light Color - #FFFFFF, Dark Color - #D3D3D3, Font - Helvetica, sans-serif</dd>
                            <dt><strong>Vibrant</strong></dt>
                            <dd>Light Color - #FF4500, Dark Color - #FFD700, Font - Bebas Neue, sans-serif</dd>
                            <dt><strong>Monochrome</strong></dt>
                            <dd>Light Color - #D3D3D3, Dark Color - #808080, Font - Roboto Mono, monospace</dd>
                            <dt><strong>Pastel</strong></dt>
                            <dd>Light Color - #FFB6C1, Dark Color - #98FB98, Font - Quicksand, sans-serif</dd>
                            <dt><strong>Neon-New</strong></dt>
                            <dd>Light Color - #FF00FF, Dark Color - #00FF00, Font - Audiowide, cursive</dd>
                            <dt><strong>Retro</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #FF4500, Font - Press Start 2P, cursive</dd>
                            <dt><strong>Vintage</strong></dt>
                            <dd>Light Color - #F5DEB3, Dark Color - #8B4513, Font - Great Vibes, cursive</dd>
                            <dt><strong>Luxury</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #000000, Font - Playfair Display, serif</dd>
                            <dt><strong>Candy-New</strong></dt>
                            <dd>Light Color - #FF69B4, Dark Color - #FF1493, Font - Bubblegum Sans, cursive</dd>
                            <dt><strong>Haunted-New</strong></dt>
                            <dd>Light Color - #778899, Dark Color - #2F2F2F, Font - Creepster, cursive</dd>
                            <dt><strong>Circus-New</strong></dt>
                            <dd>Light Color - #FF0000, Dark Color - #FFD700, Font - Permanent Marker, cursive</dd>
                            <dt><strong>Dream-New</strong></dt>
                            <dd>Light Color - #DDA0DD, Dark Color - #9370DB, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Noir-New</strong></dt>
                            <dd>Light Color - #696969, Dark Color - #2F2F2F, Font - Nosifer, cursive</dd>
                            <dt><strong>Galactic</strong></dt>
                            <dd>Light Color - #E6E6FA, Dark Color - #483D8B, Font - Orbitron, sans-serif</dd>
                            <dt><strong>Pirate-New</strong></dt>
                            <dd>Light Color - #D2B48C, Dark Color - #8B4513, Font - Hanalei Fill, cursive</dd>
                            <dt><strong>Volcano-New</strong></dt>
                            <dd>Light Color - #FF4500, Dark Color - #8B0000, Font - Bebas Neue, sans-serif</dd>
                            <dt><strong>Ice-New</strong></dt>
                            <dd>Light Color - #F0F8FF, Dark Color - #B0C4DE, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Paint-New</strong></dt>
                            <dd>Light Color - #FF9999, Dark Color - #99CCFF, Font - Permanent Marker, cursive</dd>
                            <dt><strong>Greyscale-New</strong></dt>
                            <dd>Light Color - #CCCCCC, Dark Color - #666666, Font - Cabin, sans-serif</dd>
                            <dt><strong>RGB-New</strong></dt>
                            <dd>Light Color - #FF0000, Dark Color - #00FF00, Font - Orbitron, sans-serif</dd>
                            <dt><strong>90s-New</strong></dt>
                            <dd>Light Color - #FF69B4, Dark Color - #00CED1, Font - VCR OSD Mono, monospace</dd>
                            <dt><strong>80s-New</strong></dt>
                            <dd>Light Color - #FF00FF, Dark Color - #00FFFF, Font - Press Start 2P, cursive</dd>
                            <dt><strong>70s-New</strong></dt>
                            <dd>Light Color - #FFA500, Dark Color - #8B4513, Font - Bubblegum Sans, cursive</dd>
                            <dt><strong>Nature-New</strong></dt>
                            <dd>Light Color - #98FB98, Dark Color - #228B22, Font - Cabin, sans-serif</dd>
                            <dt><strong>Retro-Arcade-New</strong></dt>
                            <dd>Light Color - #FF4500, Dark Color - #000080, Font - Press Start 2P, cursive</dd>
                            <dt><strong>Galaxy-New</strong></dt>
                            <dd>Light Color - #D8BFD8, Dark Color - #4B0082, Font - Exo 2, sans-serif</dd>
                            <dt><strong>Cyberpunk-Newer</strong></dt>
                            <dd>Light Color - #00FFFF, Dark Color - #FF00FF, Font - Rajdhani, sans-serif</dd>
                            <dt><strong>Mythology-New</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #B8860B, Font - MedievalSharp, cursive</dd>
                            <dt><strong>Underwater-New</strong></dt>
                            <dd>Light Color - #00CED1, Dark Color - #1E90FF, Font - Cabin, sans-serif</dd>
                            <dt><strong>Twilight</strong></dt>
                            <dd>Light Color - #E0B0FF, Dark Color - #6A0DAD, Font - Lora, serif</dd>
                            <dt><strong>Dystopian</strong></dt>
                            <dd>Light Color - #808080, Dark Color - #A52A2A, Font - Impact, sans-serif</dd>
                            <dt><strong>Utopian</strong></dt>
                            <dd>Light Color - #ADD8E6, Dark Color - #98FB98, Font - Futura, sans-serif</dd>
                            <dt><strong>Noir-Detective</strong></dt>
                            <dd>Light Color - #D3D3D3, Dark Color - #696969, Font - Courier New, monospace</dd>
                            <dt><strong>Carnival</strong></dt>
                            <dd>Light Color - #FF0000, Dark Color - #FFD700, Font - Showcard Gothic, fantasy</dd>
                            <dt><strong>Zen</strong></dt>
                            <dd>Light Color - #FFFFFF, Dark Color - #D3D3D3, Font - Gill Sans, sans-serif</dd>
                            <dt><strong>Baroque</strong></dt>
                            <dd>Light Color - #FFD700, Dark Color - #800000, Font - Palace Script MT, cursive</dd>
                            <dt><strong>Cyberpunk-Noir</strong></dt>
                            <dd>Light Color - #00FFFF, Dark Color - #FF00FF, Font - Neuropol, sans-serif</dd>
                            <dt><strong>Apocalyptic</strong></dt>
                            <dd>Light Color - #BDB76B, Dark Color - #8B4513, Font - Destroyed, fantasy</dd>
                            <dt><strong>Magical-Realism</strong></dt>
                            <dd>Light Color - #FFB6C1, Dark Color - #98FB98, Font - Amatic SC, cursive</dd>
                            <dt><strong>Retro-Futurism</strong></dt>
                            <dd>Light Color - #00CED1, Dark Color - #FF4500, Font - Atomic Age, cursive</dd>
                            <dt><strong>Halloween</strong></dt>
                            <dd>Light Color - #FFA500, Dark Color - #8B4513, Font - Creepster, cursive</dd>
                            <dt><strong>Baroque-Opulence</strong></dt>
                            <dd>Light Color - #F5E050, Dark Color - #4A2C2A, Font - Garamond, serif</dd>
                            <dt><strong>Cosmic-Dawn</strong></dt>
                            <dd>Light Color - #FFB6C1, Dark Color - #4B0082, Font - Alegreya, serif</dd>
                            <dt><strong>Sahara-Sunset</strong></dt>
                            <dd>Light Color - #FF8C00, Dark Color - #8A360F, Font - Fira Sans, sans-serif</dd>
                            <dt><strong>Arctic-Twilight</strong></dt>
                            <dd>Light Color - #E0FFFF, Dark Color - #4682B4, Font - Montserrat, sans-serif</dd>
                            <dt><strong>Gothic-Romance</strong></dt>
                            <dd>Light Color - #D8BFD8, Dark Color - #4B0082, Font - EB Garamond, serif</dd>
                            <dt><strong>Urban-Jungle</strong></dt>
                            <dd>Light Color - #9ACD32, Dark Color - #696969, Font - Urbanist, sans-serif</dd>
                            <dt><strong>Retro-Synthwave</strong></dt>
                            <dd>Light Color - #FF77FF, Dark Color - #00B7EB, Font - Orbitron, sans-serif</dd>
                            <dt><strong>Mediterranean-Coast</strong></dt>
                            <dd>Light Color - #F0E68C, Dark Color - #4682B4, Font - Lato, sans-serif</dd>
                            <dt><strong>Celestial-Myth</strong></dt>
                            <dd>Light Color - #F0E68C, Dark Color - #2A4066, Font - Sorts Mill Goudy, serif</dd>
                            <dt><strong>Industrial-Rust</strong></dt>
                            <dd>Light Color - #CD5C5C, Dark Color - #4A2C2A, Font - Oswald, sans-serif</dd>
                            <dt><strong>Beach</strong></dt>
                            <dd>Light Color - #FFFACD, Dark Color - #DAA520, Font - Pacifico, cursive</dd>
                            <dt><strong>Sunset</strong></dt>
                            <dd>Light Color - #FFDAB9, Dark Color - #FF6347, Font - Dancing Script, cursive</dd>
                            <dt><strong>Enchanted-Forest</strong></dt>
                            <dd>Light Color - #E6E6FA, Dark Color - #483D8B, Font - Cardo, serif</dd>
                            <dt><strong>Canyon</strong></dt>
                            <dd>Light Color - #FF7F50, Dark Color - #8B4513, Font - Arvo, serif</dd>
                        </dl>
                    </details>
                    <details>
                        <summary>Piece Styles</summary>
                        <p>Piece Styles determine the symbols or emojis used to represent the chess pieces on the board (Pawn, Rook, Knight, Bishop, Queen, King/Hero). Below is the complete list of 25 available piece styles, each offering thematic variations with unique symbols as defined in the game’s settings.</p>
                        <dl>
                            <dt><strong>Classic</strong></dt>
                            <dd>Pawn (♟), Rook (♜), Knight (♞), Bishop (♝), Queen (♛), King (👑)</dd>
                            <dt><strong>Catholic</strong></dt>
                            <dd>Pawn (🙏), Rook (🏰), Knight (⚔️), Bishop (⛪), Queen (👿), King (✝️)</dd>
                            <dt><strong>Minimalist</strong></dt>
                            <dd>Pawn (p), Rook (r), Knight (n), Bishop (b), Queen (q), King (k)</dd>
                            <dt><strong>Fantasy</strong></dt>
                            <dd>Pawn (🧝), Rook (🏯), Knight (🐉), Bishop (🧙), Queen (🧚), King (🧞)</dd>
                            <dt><strong>Scifi</strong></dt>
                            <dd>Pawn (🤖), Rook (🛰️), Knight (👽), Bishop (🖖), Queen (🌌), King (🚀)</dd>
                            <dt><strong>Pirate-Crew</strong></dt>
                            <dd>Pawn (🏴‍☠️), Rook (⚓), Knight (🗡️), Bishop (🧭), Queen (💰), King (⚔️)</dd>
                            <dt><strong>Circus-Troupe</strong></dt>
                            <dd>Pawn (🤡), Rook (🎪), Knight (🐘), Bishop (🎩), Queen (🎭), King (🎬)</dd>
                            <dt><strong>Steampunk-Gadgets</strong></dt>
                            <dd>Pawn (⚙️), Rook (🏭), Knight (🛩️), Bishop (🔧), Queen (⏰), King (🛠️)</dd>
                            <dt><strong>Elemental</strong></dt>
                            <dd>Pawn (💧), Rook (🔥), Knight (🌪️), Bishop (⛰️), Queen (☀️), King (🌩️)</dd>
                            <dt><strong>Candy-Cast</strong></dt>
                            <dd>Pawn (🍬), Rook (🍫), Knight (🍭), Bishop (🍰), Queen (🍩), King (🍪)</dd>
                            <dt><strong>Ancient-Egypt</strong></dt>
                            <dd>Pawn (𓃰), Rook (𓉔), Knight (𓃗), Bishop (𓋹), Queen (𓋨), King (𓀭)</dd>
                            <dt><strong>Musical-Instruments</strong></dt>
                            <dd>Pawn (🎷), Rook (🥁), Knight (🎻), Bishop (🎺), Queen (🎹), King (🎼)</dd>
                            <dt><strong>Sports-Equipment</strong></dt>
                            <dd>Pawn (⚽), Rook (🏈), Knight (🏀), Bishop (🎾), Queen (🏆), King (🥇)</dd>
                            <dt><strong>Fruits</strong></dt>
                            <dd>Pawn (🍎), Rook (🍌), Knight (🍇), Bishop (🍓), Queen (🍍), King (🍉)</dd>
                            <dt><strong>Zodiac-Signs</strong></dt>
                            <dd>Pawn (♈), Rook (♉), Knight (♊), Bishop (♋), Queen (♌), King (♍)</dd>
                            <dt><strong>Braille</strong></dt>
                            <dd>Pawn (⠐), Rook (⠿), Knight (⠸), Bishop (⠼), Queen (⠾), King (⠷)</dd>
                            <dt><strong>Musical</strong></dt>
                            <dd>Pawn (♩), Rook (𝄻), Knight (♫), Bishop (𝄢), Queen (♬), King (𝄐)</dd>
                            <dt><strong>Geometric</strong></dt>
                            <dd>Pawn (⚬), Rook (⧫), Knight (△), Bishop (♦), Queen (★), King (◯)</dd>
                            <dt><strong>Math</strong></dt>
                            <dd>Pawn (+), Rook (×), Knight (÷), Bishop (∫), Queen (∞), King (∑)</dd>
                            <dt><strong>Currency</strong></dt>
                            <dd>Pawn (¢), Rook ($), Knight (€), Bishop (¥), Queen (£), King (₿)</dd>
                            <dt><strong>Arrows</strong></dt>
                            <dd>Pawn (→), Rook (⇉), Knight (↬), Bishop (↗), Queen (↻), King (🡆)</dd>
                            <dt><strong>Letterlike</strong></dt>
                            <dd>Pawn (℘), Rook (ℝ), Knight (ℕ), Bishop (ℬ), Queen (ℚ), King (𝕂)</dd>
                            <dt><strong>Supersub</strong></dt>
                            <dd>Pawn (ₚ), Rook (ʳ), Knight (ₙ), Bishop (ᵇ), Queen (ᵩ), King (ᵏ)</dd>
                            <dt><strong>Dingbats</strong></dt>
                            <dd>Pawn (✶), Rook (❒), Knight (✪), Bishop (✝), Queen (❀), King (♔)</dd>
                            <dt><strong>Emoticons</strong></dt>
                            <dd>Pawn (😐), Rook (🏢), Knight (🐴), Bishop (👤), Queen (👩), King (👨)</dd>
                        </dl>
                    </details>
                    <details>
                        <summary>Square Types</summary>
                        <p>The game board consists of different types of squares that affect gameplay. Below is a detailed description of each square type, its visual representation, and its meaning in the context of the game:</p>
                        <ul>
                            <li><strong>Basic Squares</strong>: The standard board pattern, colored according to the selected theme (light or dark shades). When Fog Vision is active and the square is outside the player's vision, it is grayed out (#808080), indicating it is obscured from view.</li>
                            <li><strong>Special Squares</strong>: These squares have distinct colors that override the basic theme colors and represent key gameplay elements:
                                <ul>
                                    <li><strong>Jail (Red)</strong>: The starting position of the player, marked by a solid red square (#f00). This is where the player begins their journey.</li>
                                    <li><strong>Escape (Green)</strong>: The target square the player must reach to win the game, marked by a solid green square (#0f0). It may have additional markings or a distinct appearance (e.g., a symbol) to differentiate it from other green squares like terrain.</li>
                                    <li><strong>Blocked (Black)</strong>: Impassable obstacles that prevent movement, represented by black squares (#000) with a gray border (#333). These block the player's path.</li>
                                    <li><strong>Terrain</strong>: Special squares that affect player movement:
                                        <ul>
                                            <li><strong>Forest (#228B22)</strong>: Green squares that cost 2 moves to traverse instead of the usual 1.</li>
                                            <li><strong>Water (#00CED1)</strong>: Blue squares that, when stepped on, immediately end the player's turn.</li>
                                            <li><strong>Sand (#C2B280)</strong>: Beige squares that cost 2 moves to traverse instead of the usual 1.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Portals</strong>: Paired squares that allow instant teleportation between them when the player steps on one. They are colored purple (#800080), orange (#FFA500), or blue (#0000FF), with up to three pairs possible when the Portals option is enabled.</li>
                                </ul>
                            </li>
                            <li><strong>Highlight Overlays</strong>: Temporary visual effects overlaid on squares to indicate specific gameplay states:
                                <ul>
                                    <li><strong>Valid Moves (Blue)</strong>: A semi-transparent blue overlay (rgba(0, 0, 255, 0.5)) on squares the player can move to during the moving phase, guiding player options.</li>
                                    <li><strong>Hint (Cyan)</strong>: A semi-transparent cyan overlay (rgba(0, 255, 255, 0.5)) on a square suggesting the next move, assisting the player in decision-making.</li>
                                    <li><strong>Guard Vision (Yellow)</strong>: A semi-transparent yellow overlay (rgba(255, 255, 0, 0.5)) on squares visible to guards, shown when guard vision is revealed or when hovering over a guard, indicating areas of danger.</li>
                                    <li><strong>Move Hints (Green)</strong>: A semi-transparent green overlay (rgba(0, 255, 0, 0.3)) on squares that form a path toward the escape, helping the player navigate.</li>
                                    <li><strong>Invalid Move (Red)</strong>: A semi-transparent red overlay (rgba(255, 0, 0, 0.5)) on a square when the player attempts an invalid move, signaling an error.</li>
                                    <li><strong>Tutorial Highlight (Gold)</strong>: A pulsing gold overlay (rgba(255, 215, 0, varying opacity)) on squares during tutorial steps, guiding the player through the learning process with a dynamic effect.</li>
                                    <li><strong>Selected/Highlighted Square (Gold)</strong>: A semi-transparent gold overlay (rgba(255, 215, 0, 0.5)) on a square to indicate it is selected or highlighted for a specific purpose, such as marking an important location.</li>
                                </ul>
                            </li>
                            <li><strong>Pieces and Items</strong>: Visual representations placed on squares to denote game entities or collectibles:
                                <ul>
                                    <li><strong>Treasures and Point Items</strong>: Displayed with gold symbols (#FFD700) on the square, visible when hidden items are off or overridden. These represent collectible rewards or points.</li>
                                    <li><strong>Guards</strong>: Represented by their symbols (e.g., pawn symbols from the piece style) in the theme's button color, placed on their occupied squares. Guards act as opponents patrolling the board.</li>
                                    <li><strong>Player (King/Hero)</strong>: Represented by its symbol (e.g., a king or hero emoji) in the theme's dark color, marking the player's current position on the board.</li>
                                    <li><strong>Guard Alert</strong>: A pulsing red circle (rgba(255, 0, 0, varying opacity)) around a guard's square when it can see the player, indicating immediate danger. This effect activates when guards are enabled and the player is not invincible, stealthy, or invisible.</li>
                                </ul>
                            </li>
                        </ul>
                    </details>
                </div>
            </details>
        </div>

        <!-- Tips & Strategy Section -->
        <div id="tips-strategy-section" class="section">
            <button id="btn-back-to-start-tips" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <details>
                <summary>Tips & Strategy</summary>
                <div>
                    <details>
                        <summary>Tips & Strategy</summary>
                        <p>Here you will find Tips & Strategies to assist in playing the game:</p>
                        <ul>
                            <li><strong>General Tips</strong>: These squares have distinct colors that override the basic theme colors and represent key gameplay elements:
                                <ul>
                                    <li><strong>Plan Your Moves:</strong> Roll the dice and plan your path to avoid guards, especially when Fog Vision is on, limiting your visibility.</li>
                                    <li><strong>Use Terrain Wisely:</strong> Avoid Water squares that end your turn, and budget extra moves for Forest or Sand squares (2 moves each).</li>
                                    <li><strong>Conserve Moves:</strong> When Turn Limit is enabled, prioritize direct paths to the escape square to stay within the turn cap (5, 10, or 15 turns).</li>
                                    <li><strong>Guard Awareness:</strong> Hover over guards to see their vision (yellow overlay) and avoid these squares unless you have stealth or invincibility.</li>
                                </ul>
                            </li>
                            <li><strong>Hero Strategies</strong>: Temporary visual effects overlaid on squares to indicate specific gameplay states:
                            <p>Choose a hero based on your playstyle and use their abilities strategically:</p>
                                <ul>
                                    <li><strong>Hercules (Strength):</strong> Clear multiple guards at once when cornered (Cooldown: 3 turns).</li>
                                    <li><strong>Hattori Hanzo (Stealth):</strong> Move past guards undetected on high-difficulty levels (Cooldown: 4 turns).</li>
                                    <li><strong>Merlin (Magic):</strong> Trigger random treasure effects for unexpected advantages (Cooldown: 2 turns).</li>
                                    <li><strong>King Solomon (Wisdom):</strong> Reveal the optimal path when lost or under time pressure (Cooldown: 2 turns).</li>
                                    <li><strong>Alexander the Great (Charge):</strong> Double your moves to reach the escape faster (Cooldown: 3 turns).</li>
                                </ul>
                                <p><em>Tip:</em> Save hero abilities for critical moments, as cooldowns can leave you vulnerable.</p>
                            </li>
                            <li><strong>Difficulty-Specific Advice</strong>
                                <ul>
                                    <li><strong>Pawn/Knight (4-6 Guards):</strong> Focus on evasion; use treasures like the Cloak (invisibility) to slip past guards.</li>
                                    <li><strong>Rook/Bishop (7-8 Guards):</strong> Combine hero abilities (e.g., Hercules) with treasures (e.g., Sword) to reduce guard numbers.</li>
                                    <li><strong>Queen/King (9+ Guards):</strong> Enable Move Hints (Full Path) and use portals to bypass dense guard patrols.</li>
                                </ul>
                            </li>
                            <li><strong>Advanced Techniques</strong>
                                <ul>
                                    <li><strong>Treasure Combos:</strong> Pair Boots (double moves) with a Portal (teleport) to cover large distances in one turn.</li>
                                    <li><strong>Guard Manipulation:</strong> Use the Horn or Decoy to distract guards, creating safe paths to the escape.</li>
                                    <li><strong>Portal Mastery:</strong> Memorize portal pairs (purple, orange, blue) to use them as shortcuts or escapes from guard vision.</li>
                                    <li><strong>Arcade Mode Scoring:</strong> Prioritize guard kills (10 points each) and Gold treasures (100 points) for high scores.</li>
                                </ul>
                            </li>
                        </ul>
                    </details>
                </div>
            </details>
        </div>

        <!-- Store Section -->
        <div id="store-section" class="section">
            <button id="btn-back-to-start-store" aria-label="Return to the start page" tabindex="0">Back to Start Page</button>
            <h3>Store</h3>
            <div class="merchandise">
                <div class="item">
                    <img src="https://images-api.printify.com/mockup/6850dda60944c2e20d0fca31/87919/57161/fugitive-chess-puzzle-colorful-gaming-jigsaw-fun-family-activity-gift-for-gamers-puzzle-lovers-unique-home-decor.jpg?camera_label=front&revision=1750130274082&s=400" alt="Puzzles">
                    <p>Fugitive Chess Puzzles - $14.99</p>
                    <a href="https://fugitive-chess.printify.me/product/21035330/fugitive-chess-puzzle-colorful-gaming-jigsaw-fun-family-activity-gift-for-gamers-and-amp-puzzle-lovers-unique-home-decor" target="_blank">Buy Now</a>
                </div>
                <div class="item">
                    <img src="https://images-api.printify.com/mockup/6850cd0d7214fb1cd8040b6f/12124/92570/fugitive-chess-unisex-heavy-cotton-tee-graphic-t-shirt-for-gamers-casual-wear-gift-for-chess-lovers-unique-apparel-board-game.jpg?camera_label=front&revision=1750127631078&s=100" alt="T-Shirts & Hoodies">
                    <p>T-Shirts & Hoodies from - $19.99</p>
                    <a href="https://fugitive-chess.printify.me/" target="_blank">Buy Now</a>
                </div>
                <div class="item">
                    <img src="https://images-api.printify.com/mockup/6850d8207b35c1a3ff04e361/71923/13136/fugitive-chess-mouse-pad-gaming-accessories-cute-office-decor-gift-for-gamers-unique-desk-decor-computer-mouse-pad.jpg?camera_label=front&revision=1750129944700&s=100" alt="Mouse Pads">
                    <p>Fugitive Mouse Pads - $14.99</p>
                    <a href="https://fugitive-chess.printify.me/product/21035238/fugitive-chess-mouse-pad-gaming-accessories-cute-office-decor-gift-for-gamers-unique-desk-decor-computer-mouse-pad" target="_blank">Buy Now</a>
                </div>
		<div class="item">
                    <img src="https://images-api.printify.com/mockup/6850e34ee710fed48703c4e8/93560/72485/chic-dad-hat-with-leather-patch-fugitive-chess-cap-gift-for-chess-lovers-casual-style-hat-unique-dad-gift-trendy-accessories.jpg?camera_label=front&revision=1750131597233&s=100" alt="Hats">
                    <p>Fugitive Chess Hats - $14.99</p>
                    <a href="https://fugitive-chess.printify.me/product/21035789/chic-dad-hat-with-leather-patch-fugitive-chess-cap-gift-for-chess-lovers-casual-style-hat-unique-dad-gift-trendy-accessories" target="_blank">Buy Now</a>
                </div>
                <div class="item">
                    <img src="https://images-api.printify.com/mockup/6850e1c87214fb1cd80410f2/75282/20220/fugitive-chess-silk-poster-vibrant-wall-art-retro-game-decor-unique-gift-for-gamers-indoor-outdoor-home-decoration.jpg?camera_label=front&revision=1750131214101&s=100" alt="Posters">
                    <p>Fugitive Chess 36" x 24" Posters - $17.99</p>
                    <a href="https://fugitive-chess.printify.me/product/21035639/fugitive-chess-silk-poster-vibrant-wall-art-retro-game-decor-unique-gift-for-gamers-indoor-and-amp-outdoor-home-decoration" target="_blank">Buy Now</a>
                </div>
                <div class="item">
                    <img src="https://images-api.printify.com/mockup/6850e54c67929bc0af042eb1/80252/51792/fugitive-chess-velveteen-microfiber-blanket-cozy-gamer-blanket-unique-chess-decor-video-game-gift-soft-throw-for-game-nights.jpg?camera_label=horizontal&revision=1750132222727&s=100" alt="Blankets">
                    <p>Fugitive 60" x 50" Blankets - $39.99</p>
                    <a href="https://fugitive-chess.printify.me/product/21035943/fugitive-chess-velveteen-microfiber-blanket-cozy-gamer-blanket-unique-chess-decor-video-game-gift-soft-throw-for-game-nights">Buy Now</a>
                </div>
            </div>
            <div class="sponsors">
                <h4>Sponsors & Partners</h4>
                <a href="https://printify.com/" target="_blank">Printify</a><br>
            </div>
        </div>

        <!-- Prompt (Shared Across Modes) -->
        <div id="custom-prompt" class="custom-modal">
            <div id="custom-prompt-text"></div>
            <div id="custom-prompt-buttons">
                <button id="btn-custom-replay" aria-label="Replay the current level" tabindex="0">Replay</button>
                <button id="btn-custom-next" aria-label="Advance to the next level" tabindex="0">Next Level</button>
                <button id="btn-custom-menu" aria-label="Return to the Fugitive menu" tabindex="0" style="display: none;">Back to Menu</button>
            </div>
        </div>
        <div id="game-announcements" aria-live="polite"></div>
    </main>
    <div id="game-footer">
        <f1>Dough Knee Games</f1>
        <div id="music-player">
            <div id="track-info">Now Playing: None</div>
              <div>
                  <label for="footer-song-select">Select Song:</label>
                  <select id="footer-song-select" title="Choose background music for the game" aria-label="Choose background music" tabindex="0">
                      <option value="">Select a song</option>
                      <!-- Options will be populated dynamically -->
                  </select>
              </div>
            <div id="music-controls">
                <button id="btn-mute" aria-label="Toggle mute for music" tabindex="0">Mute</button>
                <button id="btn-pause" aria-label="Play or pause music" tabindex="0">Play</button>
                <button id="btn-skip" aria-label="Skip to the next music track" tabindex="0">Skip</button>
                <button id="btn-shuffle" aria-label="Shuffle the music playlist" tabindex="0">Shuffle</button>
                <button id="btn-repeat" aria-label="Toggle repeat for music" tabindex="0">Repeat</button>
            </div>
        </div>
    </div>
    <script>
        console.log('Fugitive Chess Version: 2025-06-01 Enhanced with Keyboard Controls');

        // --- Constants and State ---
        const SQUARE = 50;
        const BOARD = 8;
        let ctx = null;
        let tutorialCtx = null;
        let creativeCtx = null
        let standardChessCtx = null;
        let lastCursorMoveTime = 0;
        let lastMoveTime = 0;
        let moveHistory = [];
        let musicInitiated = false;
        let musicStartTimeout = null;
        let isCampaignMode = false;
        let turnTimer = null;
        let adBoardInterval = null;
        let turnCount = 0;
        let previousBoard = null;
        let isDirty = true;
        let availableSquares = [];
        let availableIndex = 0;
        let globalStats = JSON.parse(localStorage.getItem('fugitiveGlobalStats')) || {
            levelsCompleted: 0,
            treasuresCollected: 0,
            guardsDefeated: 0
        };

        // Ad Board Variables
        let currentDesign = 0;
        let horizontalRow = 0;
        let verticalCol = 0;
        let columnStart = 0;
        let rowCycleIndex = 0;
        let spiralShift = 0;
        let spiralClockwiseShift = 0;
        let spiralCounterclockwiseShift = 0;
        let snake2x4RowShift = 0;
        let snake2x4ColShift = 0;
        let snake4x2RowShift = 0;
        let snake4x2ColShift = 0;
        let waveShift = 0;
        let spiralReverseClockwiseShift = 0;
        let spiralReverseCounterclockwiseShift = 0;
        let waveReverseShift = 0;
        let waveBackwardShift = 0;
        let patternIndex = 0;

        const patterns = [
            'horizontal-forward', 'horizontal-backward', 'diagonal', 'reverse-diagonal', 
            'diagonal-backward', 'reverse-diagonal-backward', 'vertical-forward', 
            'vertical-backward', 'column-cycling', 'row-cycling', 'random-8'
        ];

        const heroes = {
            hercules: { emoji: '🦸', name: 'Hercules', effect: 'strength', description: 'Defeat guards in adjacent squares', cooldown: 3 },
            merlin: { emoji: '🧙', name: 'Merlin', effect: 'magic', description: 'Cast a random treasure effect', cooldown: 2 },
            hanzo: { emoji: '🥷', name: 'Hattori Hanzo', effect: 'stealth', description: 'Move through guards undetected', cooldown: 4 },
            musashi: { emoji: '🤺', name: 'Miyamoto Musashi', effect: 'duel', description: 'Challenge and defeat a guard', cooldown: 3 },
            alexander: { emoji: '🏇', name: 'Alexander the Great', effect: 'charge', description: 'Move double distance', cooldown: 3 },
            cleopatra: { emoji: '👸', name: 'Cleopatra', effect: 'charm', description: 'Distract all guards', cooldown: 4 },
            siddhartha: { emoji: '🤴', name: 'Prince Siddhartha', effect: 'peace', description: 'Prevent guard attacks for one turn', cooldown: 2 },
            michael: { emoji: '👼', name: 'Archangel Michael', effect: 'protection', description: 'Invincibility for one turn', cooldown: 3 },
            solomon: { emoji: '👨‍⚖️', name: 'King Solomon', effect: 'wisdom', description: 'Reveal optimal path', cooldown: 2 },
            gagarin: { emoji: '👨‍🚀', name: 'Yuri Gagarin', effect: 'explore', description: 'Teleport to any square', cooldown: 5 },
            jesus: { emoji: '✝️', name: 'Jesus Christ', effect: 'resurrection', description: 'Revive if captured once', cooldown: 5 },
            loki: { emoji: '🦹', name: 'Loki', effect: 'trickery', description: 'Swap places with a guard', cooldown: 4 },
            oracle: { emoji: '🔮', name: 'The Oracle', effect: 'reveal', description: 'Reveal all guard positions for one turn', cooldown: 2 },
            robinHood: { emoji: '🏹', name: 'Robin Hood', effect: 'rangedAttack', description: 'Defeat a guard from afar', cooldown: 3 },
            shadow: { emoji: '👤', name: 'Hades', effect: 'disableVision', description: 'Disable a guard\'s vision for one turn', cooldown: 2 },
            timeWizard: { emoji: '🧙‍♂️', name: 'Jade Emperor', effect: 'timeWarp', description: 'Stun all guards for one turn', cooldown: 4 },
            wizard: { emoji: '🧙‍♂️', name: 'Oberon', effect: 'spell', description: 'Cast a spell to stun all guards for one turn', cooldown: 4 },
            thief: { emoji: '🦹‍♂️', name: 'Odysseus', effect: 'steal', description: 'Steal a treasure from a nearby guard', cooldown: 3 },
            assassin: { emoji: '🗡️', name: 'Claudius', effect: 'assassinate', description: 'Silently eliminate a guard within two squares', cooldown: 3 },
            frostMage: { emoji: '❄️', name: 'Morozko', effect: 'freeze', description: 'Freeze all guards for two turns', cooldown: 4 },
            chronomancer: { emoji: '⏳', name: 'Kronos', effect: 'timeSkip', description: 'Skip a guard\'s turn', cooldown: 4 },
            illusionist: { emoji: '🪄', name: 'Proteus', effect: 'decoy', description: 'Create a decoy that distracts guards', cooldown: 3 },
            teleporter: { emoji: '🌀', name: 'Odin', effect: 'teleport', description: 'Teleport to any square (3 uses)', cooldown: 0, uses: 3 },
            phantom: { emoji: '👻', name: 'Yama', effect: 'intangibility', description: 'Pass through walls for 3 moves', cooldown: 4, uses: 3 },
            zephyr: { emoji: '🌬️', name: 'Zephyr', effect: 'windwalk', description: 'Ignore blocks for one turn', cooldown: 4 },
            zeus: { emoji: '⚡', name: 'Zeus', effect: 'rangedAttack', description: 'Defeat a guard from within two spaces', cooldown: 2 }
        };

        // Load custom heroes from local storage
        const customHeroes = JSON.parse(localStorage.getItem('fugitiveCustomHeroes')) || {};
        Object.assign(heroes, customHeroes);

        /**
         * Creates a custom hero based on user input and integrates it into the game.
         * The hero is added to the heroes object, saved to local storage, and selected in the UI.
         */
        function createCustomHero() {
            // Retrieve the hero's name from the input field and remove leading/trailing whitespace
            const heroName = document.getElementById('hero-name').value.trim();

            // Retrieve the selected ability from the dropdown menu
            const selectedAbility = document.getElementById('hero-ability').value;

            // Validate that both a name and an ability have been provided
            if (heroName && selectedAbility) {
                // Define the custom hero object with properties
                const customHero = {
                    emoji: '🦸', // Default emoji representing a custom hero
                    name: heroName, // The name entered by the user
                    effect: selectedAbility, // The ability selected by the user
                    description: generateHeroDescription(selectedAbility) // Generate a dynamic description
                };

                // Add the custom hero to the heroes object using a unique key
                const heroKey = `custom:${heroName}`;
                heroes[heroKey] = customHero;

                // Save the updated heroes object to local storage for persistence
                localStorage.setItem('fugitiveCustomHeroes', JSON.stringify(heroes));

                // Refresh the hero selection dropdown to include the new custom hero
                initHeroDropdown();

                // Update the hero selection dropdown to select the new custom hero
                document.getElementById('hero-select').value = heroKey;

                // Update the game state to reflect the selected hero
                state.hero = heroKey;

                // Notify the user of successful hero creation
                alert(`Custom hero "${heroName}" created!`);
            } else {
                // Inform the user if required inputs are missing
                alert('Please enter a name and select an ability.');
            }
        }

        /**
         * Generates a description for the custom hero based on the selected ability.
         * @param {string} ability - The ability selected for the hero
         * @returns {string} - A descriptive string for the hero's ability
         */
        function generateHeroDescription(ability) {
            if (ability === 'strength') {
                return 'Custom hero with Defeat adjacent guards';
            } else if (ability === 'magic') {
                return 'Custom hero with Random treasure effect';
            } else if (ability === 'stealth') {
                return 'Custom hero with Move undetected';
            } else {
                return 'Custom hero with Double moves';
            }
        }

        document.getElementById('btn-create-hero').addEventListener('click', () => {
            const name = document.getElementById('hero-name').value.trim();
            const ability = document.getElementById('hero-ability-creative').value;
            if (name && ability) {
                const customHero = {
                    emoji: '🦸',
                    name,
                    effect: ability,
                    description: `Custom hero with ${ability === 'strength' ? 'Defeat adjacent guards' : ability === 'magic' ? 'Random treasure effect' : ability === 'stealth' ? 'Move undetected' : 'Double moves'}`,
                    cooldown: ability === 'stealth' ? 4 : 3 // Example cooldowns
                };
                heroes[`custom:${name}`] = customHero;
                const customHeroes = JSON.parse(localStorage.getItem('fugitiveCustomHeroes')) || {};
                customHeroes[`custom:${name}`] = customHero;
                localStorage.setItem('fugitiveCustomHeroes', JSON.stringify(customHeroes));
                initHeroDropdown();
                document.getElementById('hero-select').value = `custom:${name}`;
                state.hero = `custom:${name}`;
                alert(`Custom hero "${name}" created and selected!`);
                drawBoard(); // Reflect hero change if in game
            } else {
                alert('Please enter a name and select an ability.');
            }
        });

        const treasures = {
            diamond: { symbol: '💎', effect: 'reroll', description: 'Reroll the dice' },
            key: { symbol: '🗝️', effect: 'unlock', description: 'Unlock a hidden path' },
            gold: { symbol: '💰', effect: 'score', description: 'Gain 100 points' },
            shield: { symbol: '🛡️', effect: 'invincible', duration: 1, description: 'Invincible for one turn' },
            sword: { symbol: '⚔️', effect: 'attack', description: 'Extra attack' },
            boots: { symbol: '🏃', effect: 'double-moves', duration: 1, description: 'Double moves for one roll' },
            spyglass: { symbol: '🔍', effect: 'reveal-guards', description: 'Reveal all guard vision' },
            portal: { symbol: '🕳️', effect: 'teleport', description: 'Teleport to random square' },
            potion: { symbol: '🧪', effect: 'restore-moves', description: 'Restore moves' },
            map: { symbol: '📜', effect: 'reveal-treasures', description: 'Reveal all treasures' },
            trident: { symbol: '🔱', effect: 'push-guards', description: 'Push guards back' },
            excalibur: { symbol: '🗡️', effect: 'defeat-guard', description: 'Defeat any guard' },
            mjolnir: { symbol: '🔨', effect: 'stun-guards', description: 'Stun all guards' },
            grail: { symbol: '🍷', effect: 'invincible', duration: 2, description: 'Invincible for two turns' },
            horn: { symbol: '📯', effect: 'distract-guards', description: 'Distract guards' },
            bow: { symbol: '🏹', effect: 'ranged-attack', description: 'Attack from afar' },
            crown: { symbol: '👑', effect: 'double-score', description: 'Double score' },
            feather: { symbol: '🪶', effect: 'fly', description: 'Fly over walls' },
            eye: { symbol: '🧿', effect: 'see-through', description: 'See through walls' },
            storm: { symbol: '🌩️', effect: 'disrupt-vision', description: 'Disrupt guard vision' },
            phaseStone: { symbol: '🌌', effect: 'phase', description: 'Move through walls for 3 moves' },
            cloak: { symbol: '🧥', effect: 'invisibility', duration: 3, description: 'Become invisible for 3 moves' },
            lantern: { symbol: '🏮', effect: 'disable-fog', duration: 3, description: 'Disable fog vision for 3 turns' },
            bomb: { symbol: '💣', effect: 'destroyWalls', description: 'Destroy adjacent walls' },
            timeCrystal: { symbol: '⏳', effect: 'timeFreeze', description: 'Freeze guards for two turns' },
            mirror: { symbol: '🪞', effect: 'reflect', description: 'Reflect guard vision back at them for one turn' },
            whirlwind: { symbol: '🌪️', effect: 'shuffle', description: 'Randomly reposition all guards' },
            compass: { symbol: '🧭', effect: 'disable-fog', duration: 5, description: 'Disable fog vision for 5 turns' },
            speedBoost: { symbol: '🏃', effect: 'speed', description: 'Double moves for one turn' },
            decoy: { symbol: '👥', effect: 'decoy', description: 'Create a decoy that distracts guards for 3 turns' },
            wallBreaker: { symbol: '🔨', effect: 'breakWall', description: 'Destroy one blocked square' },
            visionEnhancer: { symbol: '👁️', effect: 'reveal', description: 'Reveal all guards for 3 turns' }
        };

        const sounds = {
            move: document.getElementById('move-sound'),
            capture: document.getElementById('capture-sound'),
            win: document.getElementById('win-sound'),
            lose: document.getElementById('lose-sound'),
            collect: document.getElementById('collect-sound'),
            ability: document.getElementById('ability-sound'),
            teleport: document.getElementById('teleport-sound'),
            roll: document.getElementById('roll-sound'),
            invalid: document.getElementById('invalid-sound'),
            click: document.getElementById('click-sound'),
            timerTick: document.getElementById('tick-sound')
        };

        const points = { '①': 1, '⑤': 5, '⑩': 10 };

        const pieceValues = {
            pawn: 1,
            knight: 3,
            bishop: 3,
            rook: 5,
            queen: 9,
            king: 0
        };

        const prisons = [
            "Alcatraz Island",
            "Rikers Island",
            "San Quentin State Prison",
            "ADX Florence",
            "USP Marion",
            "Walla Walla State Penitentiary",
            "Eastern State Penitentiary",
            "La Sabaneta Prison",
            "Bang Kwang Central Prison",
            "Puerto de Asturias Prison",
            "Cellular Jail",
            "Hỏa Lò Prison",
            "Andersonville Prison",
            "Folsom State Prison",
            "Belmarsh Prison",
            "Guantanamo Bay",
            "Baikonur Prison",
            "Devil’s Island",
            "Robben Island",
            "The Tower of London",
            "Reading Gaol",
            "Wormwood Scrubs",
            "Château d’If",
            "The Bastille",
            "Spandau Prison",
            "Tadmor Prison",
            "Ryukyu",
            "Port Arthur",
            "The Labyrinth",
            "Tartarus"
        ];

        const predefinedMaps = {
            "predefined_map_1": { // Alcatraz Island: 5 guards, medium
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 5, behavior: "Passive" },
                    { type: "Pawn", row: 4, col: 1, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 3, behavior: "Passive" }
                ],
                blocks: [],
                treasures: [],
                portals: [],
                terrain: []
            },
            "predefined_map_2": { // Rikers Island: 6 guards, medium
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 1, behavior: "Passive" },
                    { type: "Pawn", row: 4, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 5, col: 4, behavior: "Aggressive" },
                    { type: "Pawn", row: 6, col: 5, behavior: "Passive" },
                    { type: "Knight", row: 3, col: 6, behavior: "Patrolling" },
                    { type: "Bishop", row: 1, col: 7, behavior: "Aggressive" }
                ],
                blocks: [
                    { row: 1, col: 3 },
                    { row: 3, col: 3 },
                    { row: 4, col: 3 },
                    { row: 6, col: 3 }
                ],
                treasures: [],
                portals: [],
                terrain: []
            },
            "predefined_map_3": { // San Quentin State Prison: 7 guards, hard
                king: { row: 7, col: 7 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Knight", row: 3, col: 3, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 5, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 4, behavior: "Patrolling" },
                    { type: "Pawn", row: 4, col: 6, behavior: "Passive" },
                    { type: "Queen", row: 1, col: 2, behavior: "Aggressive" },
                    { type: "Sentry", row: 6, col: 1, behavior: "Passive" },
                    { type: "Pawn", row: 0, col: 5, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 2, col: 3 },
                    { row: 2, col: 4 },
                    { row: 5, col: 2 },
                    { row: 5, col: 3 },
                    { row: 5, col: 4 }
                ],
                treasures: [],
                portals: [],
                terrain: []
            },
            "predefined_map_4": { // ADX Florence: 8 guards, hard
                king: { row: 4, col: 4 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 2, col: 2, behavior: "Aggressive" },
                    { type: "Rook", row: 4, col: 0, behavior: "Patrolling" },
                    { type: "Knight", row: 0, col: 4, behavior: "Aggressive" },
                    { type: "Bishop", row: 7, col: 3, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 5, behavior: "Passive" },
                    { type: "Sentry", row: 5, col: 2, behavior: "Aggressive" },
                    { type: "Pawn", row: 1, col: 6, behavior: "Passive" },
                    { type: "Knight", row: 6, col: 5, behavior: "Patrolling" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 3, col: 4 },
                    { row: 4, col: 3 },
                    { row: 4, col: 5 },
                    { row: 5, col: 3 },
                    { row: 5, col: 4 }
                ],
                treasures: [],
                portals: [],
                terrain: []
            },
            "predefined_map_5": { // USP Marion: 5 guards, medium
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 4, behavior: "Aggressive" },
                    { type: "Knight", row: 3, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 5, col: 5, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 3, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [],
                portals: [],
                terrain: []
            },
            "predefined_map_6": { // Walla Walla State Penitentiary: 6 guards, medium
                king: { row: 7, col: 7 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Pawn", row: 6, col: 5, behavior: "Passive" },
                    { type: "Rook", row: 5, col: 3, behavior: "Aggressive" },
                    { type: "Knight", row: 4, col: 6, behavior: "Patrolling" },
                    { type: "Bishop", row: 3, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 2, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 1, col: 1, behavior: "Aggressive" }
                ],
                blocks: [
                    { row: 5, col: 5 },
                    { row: 4, col: 4 },
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Diamond", row: 2, col: 2 },
                    { type: "Key", row: 6, col: 6 }
                ],
                portals: [],
                terrain: []
            },
            "predefined_map_7": { // Eastern State Penitentiary: 4 guards, easy
                king: { row: 0, col: 7 },
                escape: { row: 7, col: 0 },
                guards: [
                    { type: "Pawn", row: 1, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 1, behavior: "Passive" }
                ],
                blocks: [],
                treasures: [
                    { type: "Gold", row: 4, col: 5 }
                ],
                portals: [],
                terrain: []
            },
            "predefined_map_8": { // La Sabaneta Prison: 7 guards, hard
                king: { row: 3, col: 3 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 1, col: 1, behavior: "Aggressive" },
                    { type: "Rook", row: 2, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 2, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 0, col: 3, behavior: "Aggressive" },
                    { type: "Pawn", row: 3, col: 0, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 2, col: 3 },
                    { row: 3, col: 2 },
                    { row: 4, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Shield", row: 5, col: 1 },
                    { type: "Sword", row: 1, col: 4 }
                ],
                portals: [],
                terrain: []
            },
            "predefined_map_9": { // Bang Kwang Central Prison: 8 guards, hard
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 2, col: 2, behavior: "Aggressive" },
                    { type: "Rook", row: 3, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 1, behavior: "Aggressive" },
                    { type: "Bishop", lineNumber: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 3, behavior: "Passive" },
                    { type: "Sentry", row: 1, col: 4, behavior: "Aggressive" },
                    { type: "Pawn", row: 0, col: 6, behavior: "Passive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" }
                ],
                blocks: [
                    { row: 1, col: 1 },
                    { row: 1, col: 2 },
                    { row: 2, col: 1 },
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Boots", row: 3, col: 0 },
                    { type: "Spyglass", row: 6, col: 5 }
                ],
                portals: [],
                terrain: []
            },
            "predefined_map_10": { // Puerto de Asturias Prison: 5 guards, medium
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 3, behavior: "Passive" },
                    { type: "Rook", row: 4, col: 5, behavior: "Aggressive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" },
                    { type: "Bishop", row: 3, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 1, col: 4, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Potion", row: 2, col: 5 },
                    { type: "Map", row: 6, col: 1 }
                ],
                portals: [],
                terrain: []
            },
            "predefined_map_11": { // Cellular Jail: 6 guards, medium
                king: { row: 4, col: 0 },
                escape: { row: 4, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 3, col: 5, behavior: "Aggressive" },
                    { type: "Knight", row: 5, col: 3, behavior: "Patrolling" },
                    { type: "Bishop", row: 6, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 1, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 0, col: 1, behavior: "Aggressive" }
                ],
                blocks: [
                    { row: 4, col: 2 },
                    { row: 4, col: 3 },
                    { row: 4, col: 5 }
                ],
                treasures: [
                    { type: "Trident", row: 3, col: 1 }
                ],
                portals: [
                    [{ row: 2, col: 0 }, { row: 6, col: 0 }]
                ],
                terrain: []
            },
            "predefined_map_12": { // Hỏa Lò Prison: 4 guards, easy
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 5, behavior: "Passive" }
                ],
                blocks: [],
                treasures: [],
                portals: [
                    [{ row: 2, col: 2 }, { row: 5, col: 5 }]
                ],
                terrain: []
            },
            "predefined_map_13": { // Andersonville Prison: 7 guards, hard
                king: { row: 7, col: 7 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Queen", row: 5, col: 5, behavior: "Aggressive" },
                    { type: "Rook", row: 6, col: 2, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 3, behavior: "Aggressive" },
                    { type: "Bishop", row: 3, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 2, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 1, col: 1, behavior: "Aggressive" },
                    { type: "Pawn", row: 0, col: 3, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 4, col: 4 },
                    { row: 5, col: 3 },
                    { row: 4, col: 2 }
                ],
                treasures: [
                    { type: "Excalibur", row: 6, col: 6 }
                ],
                portals: [
                    [{ row: 7, col: 0 }, { row: 0, col: 7 }]
                ],
                terrain: []
            },
            "predefined_map_14": { // Folsom State Prison: 5 guards, medium
                king: { row: 0, col: 7 },
                escape: { row: 7, col: 0 },
                guards: [
                    { type: "Pawn", row: 1, col: 5, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 3, behavior: "Aggressive" },
                    { type: "Knight", row: 4, col: 2, behavior: "Patrolling" },
                    { type: "Bishop", row: 5, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 1, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 3, col: 4 }
                ],
                treasures: [
                    { type: "Mjolnir", row: 2, col: 6 }
                ],
                portals: [
                    [{ row: 0, col: 0 }, { row: 7, col: 7 }]
                ],
                terrain: []
            },
            "predefined_map_15": { // Belmarsh Prison: 6 guards, medium
                king: { row: 3, col: 3 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 1, behavior: "Passive" },
                    { type: "Rook", row: 4, col: 5, behavior: "Aggressive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" },
                    { type: "Bishop", row: 1, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 0, col: 3, behavior: "Passive" },
                    { type: "Sentry", row: 6, col: 6, behavior: "Aggressive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Grail", row: 5, col: 3 }
                ],
                portals: [
                    [{ row: 3, col: 0 }, { row: 3, col: 7 }]
                ],
                terrain: []
            },
            "predefined_map_16": { // Guantanamo Bay: 8 guards, hard
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 2, col: 2, behavior: "Aggressive" },
                    { type: "Rook", row: 3, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 1, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 3, behavior: "Passive" },
                    { type: "Sentry", row: 1, col: 4, behavior: "Aggressive" },
                    { type: "Pawn", row: 0, col: 6, behavior: "Passive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Horn", row: 2, col: 0 }
                ],
                portals: [],
                terrain: [
                    { type: "Water", row: 7, col: 0 },
                    { type: "Water", row: 0, col: 7 }
                ]
            },
            "predefined_map_17": { // Baikonur Prison: 5 guards, medium
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 3, behavior: "Passive" },
                    { type: "Rook", row: 4, col: 5, behavior: "Aggressive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" },
                    { type: "Bishop", row: 3, col: 6, behavior: "Passive" },
                    { type: "Sentry", row: 1, col: 1, behavior: "Aggressive" }
                ],
                blocks: [
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Bow", row: 6, col: 4 }
                ],
                portals: [],
                terrain: [
                    { type: "Forest", row: 0, col: 0 }
                ]
            },
            "predefined_map_18": { // Devil’s Island: 7 guards, hard
                king: { row: 0, col: 7 },
                escape: { row: 7, col: 0 },
                guards: [
                    { type: "Queen", row: 1, col: 5, behavior: "Aggressive" },
                    { type: "Rook", row: 2, col: 3, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 2, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 1, behavior: "Passive" },
                    { type: "Sentry", row: 3, col: 6, behavior: "Aggressive" },
                    { type: "Pawn", row: 0, col: 2, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Crown", row: 5, col: 5 }
                ],
                portals: [],
                terrain: [
                    { type: "Water", row: 0, col: 0 },
                    { type: "Water", row: 7, col: 7 }
                ]
            },
            "predefined_map_19": { // Robben Island: 4 guards, easy
                king: { row: 7, col: 7 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Pawn", row: 6, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 5, behavior: "Passive" },
                    { type: "Pawn", row: 4, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 3, behavior: "Passive" }
                ],
                blocks: [],
                treasures: [
                    { type: "Feather", row: 2, col: 2 }
                ],
                portals: [],
                terrain: [
                    { type: "Water", row: 1, col: 1 }
                ]
            },
            "predefined_map_20": { // The Tower of London: 6 guards, medium
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 4, behavior: "Aggressive" },
                    { type: "Knight", row: 3, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 4, col: 5, behavior: "Passive" },
                    { type: "Sentry", row: 5, col: 3, behavior: "Aggressive" },
                    { type: "Pawn", row: 6, col: 6, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Eye", row: 2, col: 0 }
                ],
                portals: [],
                terrain: [
                    { type: "Forest", row: 7, col: 0 }
                ]
            },
            "predefined_map_21": { // Reading Gaol: 5 guards, medium
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 3, behavior: "Passive" },
                    { type: "Rook", row: 4, col: 5, behavior: "Aggressive" },
                    { type: "Knight", row: 5, col: 2, behavior: "Patrolling" },
                    { type: "Bishop", row: 3, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 1, col: 1, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 },
                    { row: 4, col: 4 }
                ],
                treasures: [
                    { type: "Storm", row: 6, col: 6 }
                ],
                portals: [
                    [{ row: 7, col: 7 }, { row: 0, col: 0 }]
                ],
                terrain: [
                    { type: "Water", row: 2, col: 2 }
                ]
            },
            "predefined_map_22": { // Wormwood Scrubs: 6 guards, medium
                king: { row: 0, col: 7 },
                escape: { row: 7, col: 0 },
                guards: [
                    { type: "Pawn", row: 1, col: 5, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 3, behavior: "Aggressive" },
                    { type: "Knight", row: 3, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 4, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 5, col: 6, behavior: "Aggressive" },
                    { type: "Pawn", row: 6, col: 2, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Cloak", row: 5, col: 0 }
                ],
                portals: [
                    [{ row: 0, col: 0 }, { row: 7, col: 7 }]
                ],
                terrain: [
                    { type: "Forest", row: 1, col: 1 }
                ]
            },
            "predefined_map_23": { // Château d’If: 7 guards, hard
                king: { row: 3, col: 3 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 1, col: 1, behavior: "Aggressive" },
                    { type: "Rook", row: 2, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 2, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 6, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 0, col: 3, behavior: "Aggressive" },
                    { type: "Pawn", row: 3, col: 0, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 3, col: 4 },
                    { row: 4, col: 3 }
                ],
                treasures: [
                    { type: "Diamond", row: 5, col: 1 },
                    { type: "Key", row: 1, col: 4 }
                ],
                portals: [
                    [{ row: 0, col: 0 }, { row: 7, col: 0 }]
                ],
                terrain: [
                    { type: "Water", row: 0, col: 7 },
                    { type: "Water", row: 7, col: 0 }
                ]
            },
            "predefined_map_24": { // The Bastille: 5 guards, medium
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 4, behavior: "Aggressive" },
                    { type: "Knight", row: 3, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 4, col: 5, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 3, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Shield", row: 6, col: 6 }
                ],
                portals: [
                    [{ row: 0, col: 7 }, { row: 7, col: 0 }]
                ],
                terrain: [
                    { type: "Forest", row: 2, col: 2 }
                ]
            },
            "predefined_map_25": { // Spandau Prison: 6 guards, medium
                king: { row: 7, col: 7 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Pawn", row: 6, col: 5, behavior: "Passive" },
                    { type: "Rook", row: 5, col: 3, behavior: "Aggressive" },
                    { type: "Knight", row: 4, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 3, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 2, col: 6, behavior: "Aggressive" },
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" }
                ],
                blocks: [
                    { row: 4, col: 4 },
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Sword", row: 0, col: 7 }
                ],
                portals: [
                    [{ row: 7, col: 0 }, { row: 0, col: 7 }]
                ],
                terrain: [
                    { type: "Forest", row: 5, col: 5 }
                ]
            },
            "predefined_map_26": { // Tadmor Prison: 8 guards, hard
                king: { row: 0, col: 7 },
                escape: { row: 7, col: 0 },
                guards: [
                    { type: "Queen", row: 1, col: 5, behavior: "Aggressive" },
                    { type: "Rook", row: 2, col: 3, behavior: "Patrolling" },
                    { type: "Knight", row: 3, col: 1, behavior: "Aggressive" },
                    { type: "Bishop", row: 4, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 5, col: 6, behavior: "Aggressive" },
                    { type: "Pawn", row: 6, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 0, col: 3, behavior: "Passive" },
                    { type: "Knight", row: 5, col: 0, behavior: "Patrolling" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 3, col: 3 },
                    { row: 4, col: 2 },
                    { row: 3, col: 4 }
                ],
                treasures: [
                    { type: "Boots", row: 1, col: 1 },
                    { type: "Spyglass", row: 6, col: 5 }
                ],
                portals: [
                    [{ row: 0, col: 0 }, { row: 7, col: 7 }],
                    [{ row: 2, col: 6 }, { row: 5, col: 1 }]
                ],
                terrain: [
                    { type: "Water", row: 0, col: 0 },
                    { type: "Forest", row: 7, col: 7 }
                ]
            },
            "predefined_map_27": { // Ryukyu: 4 guards, easy
                king: { row: 7, col: 0 },
                escape: { row: 0, col: 7 },
                guards: [
                    { type: "Pawn", row: 2, col: 2, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 4, col: 6, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 3, behavior: "Passive" }
                ],
                blocks: [],
                treasures: [
                    { type: "Potion", row: 6, col: 1 }
                ],
                portals: [
                    [{ row: 7, col: 7 }, { row: 0, col: 0 }]
                ],
                terrain: [
                    { type: "Water", row: 1, col: 1 }
                ]
            },
            "predefined_map_28": { // Port Arthur: 5 guards, medium
                king: { row: 0, col: 0 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Pawn", row: 1, col: 2, behavior: "Passive" },
                    { type: "Rook", row: 2, col: 4, behavior: "Aggressive" },
                    { type: "Knight", row: 3, col: 1, behavior: "Patrolling" },
                    { type: "Bishop", row: 4, col: 5, behavior: "Passive" },
                    { type: "Pawn", row: 5, col: 3, behavior: "Passive" }
                ],
                blocks: [
                    { row: 3, col: 3 }
                ],
                treasures: [
                    { type: "Map", row: 6, col: 6 }
                ],
                portals: [
                    [{ row: 0, col: 7 }, { row: 7, col: 0 }]
                ],
                terrain: [
                    { type: "Water", row: 2, col: 2 }
                ]
            },
            "predefined_map_29": { // The Labyrinth: 7 guards, hard
                king: { row: 3, col: 3 },
                escape: { row: 7, col: 7 },
                guards: [
                    { type: "Queen", row: 1, col: 1, behavior: "Aggressive" },
                    { type: "Rook", row: 2, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 4, col: 2, behavior: "Aggressive" },
                    { type: "Bishop", row: 5, col: 6, behavior: "Passive" },
                    { type: "Sentry", row: 0, col: 3, behavior: "Aggressive" },
                    { type: "Pawn", row: 6, col: 4, behavior: "Passive" },
                    { type: "Pawn", row: 3, col: 0, behavior: "Passive" }
                ],
                blocks: [
                    { row: 2, col: 2 },
                    { row: 2, col: 3 },
                    { row: 3, col: 2 },
                    { row: 4, col: 3 },
                    { row: 4, col: 4 },
                    { row: 3, col: 4 }
                ],
                treasures: [
                    { type: "Trident", row: 5, col: 1 },
                    { type: "Excalibur", row: 1, col: 4 }
                ],
                portals: [
                    [{ row: 0, col: 0 }, { row: 7, col: 0 }],
                    [{ row: 0, col: 7 }, { row: 7, col: 7 }]
                ],
                terrain: [
                    { type: "Forest", row: 0, col: 1 },
                    { type: "Water", row: 6, col: 6 }
                ]
            },
            "predefined_map_30": { // Tartarus: 9 guards, extreme
                king: { row: 4, col: 4 },
                escape: { row: 0, col: 0 },
                guards: [
                    { type: "Queen", row: 2, col: 2, behavior: "Aggressive" },
                    { type: "Queen", row: 6, col: 6, behavior: "Aggressive" },
                    { type: "Rook", row: 3, col: 5, behavior: "Patrolling" },
                    { type: "Knight", row: 5, col: 3, behavior: "Aggressive" },
                    { type: "Bishop", row: 1, col: 4, behavior: "Passive" },
                    { type: "Sentry", row: 4, col: 1, behavior: "Aggressive" },
                    { type: "Pawn", row: 0, col: 3, behavior: "Passive" },
                    { type: "Pawn", row: 7, col: 5, behavior: "Passive" },
                    { type: "Knight", row: 5, col: 0, behavior: "Patrolling" }
                ],
                blocks: [
                    { row: 2, col: 3 },
                    { row: 3, col: 2 },
                    { row: 3, col: 3 },
                    { row: 4, col: 2 },
                    { row: 4, col: 3 },
                    { row: 5, col: 2 },
                    { row: 5, col: 3 }
                ],
                treasures: [
                    { type: "Mjolnir", row: 1, col: 1 },
                    { type: "Grail", row: 6, col: 1 },
                    { type: "Horn", row: 3, col: 6 }
                ],
                portals: [
                    [{ row: 0, col: 7 }, { row: 7, col: 0 }],
                    [{ row: 1, col: 0 }, { row: 6, col: 7 }],
                    [{ row: 2, col: 4 }, { row: 5, col: 5 }]
                ],
                terrain: [
                    { type: "Forest", row: 0, col: 1 },
                    { type: "Water", row: 7, col: 1 },
                    { type: "Forest", row: 1, col: 6 },
                    { type: "Water", row: 6, col: 0 }
                ]
            }
        };

        // Define prison maps linking prison names to predefined layouts
        const prisonMaps = {
            "Alcatraz Island": { layout: "predefined_map_1", guards: 5, difficulty: "Knight" },
            "Rikers Island": { layout: "predefined_map_2", guards: 6, difficulty: "Knight" },
            "San Quentin State Prison": { layout: "predefined_map_3", guards: 7, difficulty: "Rook" },
            "ADX Florence": { layout: "predefined_map_4", guards: 8, difficulty: "Rook" },
            "USP Marion": { layout: "predefined_map_5", guards: 5, difficulty: "Knight" },
            "Walla Walla State Penitentiary": { layout: "predefined_map_6", guards: 6, difficulty: "Knight" },
            "Eastern State Penitentiary": { layout: "predefined_map_7", guards: 4, difficulty: "Pawn" },
            "La Sabaneta Prison": { layout: "predefined_map_8", guards: 7, difficulty: "Rook" },
            "Bang Kwang Central Prison": { layout: "predefined_map_9", guards: 8, difficulty: "Rook" },
            "Puerto de Asturias Prison": { layout: "predefined_map_10", guards: 5, difficulty: "Knight" },
            "Cellular Jail": { layout: "predefined_map_11", guards: 6, difficulty: "Knight" },
            "Hỏa Lò Prison": { layout: "predefined_map_12", guards: 4, difficulty: "Pawn" },
            "Andersonville Prison": { layout: "predefined_map_13", guards: 7, difficulty: "Rook" },
            "Folsom State Prison": { layout: "predefined_map_14", guards: 5, difficulty: "Knight" },
            "Belmarsh Prison": { layout: "predefined_map_15", guards: 6, difficulty: "Knight" },
            "Guantanamo Bay": { layout: "predefined_map_16", guards: 8, difficulty: "Rook" },
            "Baikonur Prison": { layout: "predefined_map_17", guards: 5, difficulty: "Knight" },
            "Devil’s Island": { layout: "predefined_map_18", guards: 7, difficulty: "Rook" },
            "Robben Island": { layout: "predefined_map_19", guards: 4, difficulty: "Pawn" },
            "The Tower of London": { layout: "predefined_map_20", guards: 6, difficulty: "Knight" },
            "Reading Gaol": { layout: "predefined_map_21", guards: 5, difficulty: "Knight" },
            "Wormwood Scrubs": { layout: "predefined_map_22", guards: 6, difficulty: "Knight" },
            "Château d’If": { layout: "predefined_map_23", guards: 7, difficulty: "Rook" },
            "The Bastille": { layout: "predefined_map_24", guards: 5, difficulty: "Knight" },
            "Spandau Prison": { layout: "predefined_map_25", guards: 6, difficulty: "Knight" },
            "Tadmor Prison": { layout: "predefined_map_26", guards: 8, difficulty: "Rook" },
            "Ryukyu": { layout: "predefined_map_27", guards: 4, difficulty: "Pawn" },
            "Port Arthur": { layout: "predefined_map_28", guards: 5, difficulty: "Knight" },
            "The Labyrinth": { layout: "predefined_map_29", guards: 7, difficulty: "Rook" },
            "Tartarus": { layout: "predefined_map_30", guards: 9, difficulty: "Queen" }
        };

        // Function to initialize campaign progress
        function initializeCampaign() {
            const progress = {
                prisons: prisons.map((name, index) => ({
                    name: name,
                    unlocked: index === 0, // Only the first prison is unlocked initially
                    completed: false
                })),
                currentPrison: prisons[0] // Start with the first prison
            };
            saveCampaignProgress(progress);
            return progress;
        }

        // Function to save campaign progress to local storage
        function saveCampaignProgress(progress) {
            localStorage.setItem('campaignProgress', JSON.stringify(progress));
        }

        // Function to load campaign progress from local storage
        function loadCampaignProgress() {
            const progress = localStorage.getItem('campaignProgress');
            return progress ? JSON.parse(progress) : null;
        }

        // Function to get the current prison
        function getCurrentPrison(progress) {
            return progress.currentPrison;
        }

        // Function to set the current prison
        function setCurrentPrison(progress, prisonName) {
            if (prisons.includes(prisonName)) {
                progress.currentPrison = prisonName;
                saveCampaignProgress(progress);
            } else {
                console.error(`Prison ${prisonName} not found.`);
            }
        }

        // Function to mark a prison as completed and unlock the next one
        function completePrison(progress, prisonName) {
            const prisonIndex = progress.prisons.findIndex(p => p.name === prisonName);
            if (prisonIndex !== -1) {
                progress.prisons[prisonIndex].completed = true;
                if (prisonIndex + 1 < progress.prisons.length) {
                    progress.prisons[prisonIndex + 1].unlocked = true;
                }
                saveCampaignProgress(progress);
            }
        }

        // Function to load a prison map
        function loadMap(prisonName) {
            const prison = prisonMaps[prisonName];
            if (!prison) {
                console.error(`No prison data found for "${prisonName}". Available prisons: ${Object.keys(prisonMaps).join(', ')}`);
                return;
            }
            const layout = prison.layout;
            const mapData = predefinedMaps[layout];
            if (!mapData) {
                console.error(`No map data found for layout "${layout}"`);
                return;
            }
            // Set game state based on mapData
            state.king = [mapData.king.row, mapData.king.col];
            state.jail = [mapData.king.row, mapData.king.col]; // Jail starts at king's position
            state.escape = [mapData.escape.row, mapData.escape.col];
            state.opponents = mapData.guards.map(g => ({
                type: g.type.toLowerCase(),
                pos: [g.row, g.col],
                behavior: g.behavior.toLowerCase(),
                vision: getGuardVision({ type: g.type.toLowerCase(), pos: [g.row, g.col] })
            }));
            state.blocked = mapData.blocks.map(b => [b.row, b.col]);
            state.treasures = mapData.treasures.map(t => ({
                type: t.type.toLowerCase(),
                pos: [t.row, t.col]
            }));
            state.portalsList = mapData.portals.map(pair => pair.map(p => [p.row, p.col]));
            state.terrain = mapData.terrain.reduce((acc, t) => {
                if (t.type === 'Forest') acc.forest.push([t.row, t.col]);
                else if (t.type === 'Sand') acc.sand.push([t.row, t.col]);
                else if (t.type === 'Water') acc.water.push([t.row, t.col]);
                return acc;
            }, { forest: [], water: [], sand: [] });
            // Initialize state.initial for restarting the level
            state.initial = {
                king: [...state.king],
                jail: [...state.jail],
                escape: [...state.escape],
                opponents: JSON.parse(JSON.stringify(state.opponents)),
                blocked: JSON.parse(JSON.stringify(state.blocked)),
                treasures: JSON.parse(JSON.stringify(state.treasures)),
                portalsList: JSON.parse(JSON.stringify(state.portalsList)),
                terrain: JSON.parse(JSON.stringify(state.terrain))
            };
            state.phase = 'waiting';
            state.roll = 0;
            state.moves = 0;
            state.guards = 0;
            state.collectedTreasures = [];
            console.log(`Map loaded for ${prisonName}`);
            drawBoard();
        }

        // Function to show campaign completion screen
        function showCampaignCompletionScreen(prisonName) {
            const modal = document.getElementById('campaign-completion') || document.createElement('div');
            if (!modal.id) {
                modal.id = 'campaign-completion';
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <h3>Prison Escaped!</h3>
                    <p id="completed-prison"></p>
                    <button id="continue-to-next">Next Prison</button>
                    <button id="back-to-menu">Main Menu</button>
                `;
                document.body.appendChild(modal);
            }
            document.getElementById('completed-prison').textContent = `You escaped ${prisonName}!`;
            modal.style.display = 'block';
        }

        // Function to show campaign failure screen
        function showCampaignFailureScreen(prisonName) {
            const modal = document.getElementById('campaign-failure') || document.createElement('div');
            if (!modal.id) {
                modal.id = 'campaign-failure';
                modal.className = 'custom-modal';
                modal.innerHTML = `
                    <h3>Captured!</h3>
                    <p id="failed-prison"></p>
                    <button id="retry-prison">Retry</button>
                    <button id="back-to-menu-failure">Main Menu</button>
                `;
                document.body.appendChild(modal);
            }
            document.getElementById('failed-prison').textContent = `You were caught in ${prisonName}.`;
            modal.style.display = 'block';
        }

        const standardState = {
            board: Array(8).fill(null).map(() => Array(8).fill(null)),
            turn: 'white',
            selected: null,
            validMoves: [],
            castling: { white: { king: true, kingRook: true, queenRook: true }, black: { king: true, kingRook: true, queenRook: true } },
            enPassant: null,
            difficulty: 'medium',
            theme: 'light',
            whitePieceStyle: 'classic',
            blackPieceStyle: 'classic',
            turnTimer: 'off',
            timer: null,
            whiteTime: 600,
            blackTime: 600,
            aiPlaysAs: null,
            cursorRow: 0,
            cursorCol: 0,
            hero: null,
            lastMove: null,
            capturedWhite: [],
            capturedBlack: [],
            moveHistory: []
        };

        const state = {
            mode: 'fugitive',
            king: [0, 0],
            jail: [0, 0],
            escape: [7, 7],
            opponents: [],
            blocked: [],
            treasures: [],
            collectedTreasures: [],
            portals: 'off',
            portalsList: [],
            playerName: '',
            miniMapZoomed: false,
            lastMove: null,
            guardAggression: 'medium',
            treasureSpawnRate: 'medium',
            roll: 0,
            moves: 0,
            rolls: 0,
            guards: 0,
            levels: 0,
            terrain: { forest: [], water: [], sand: [] },
            phase: 'waiting',
            level: 1,
            difficulty: 'pawn',
            theme: 'light',
            pieceStyle: 'classic',
            hero: null,
            initial: null,
            turnTimer: 'off',
            turnLimit: 'none',
            timeAttack: 'off',
            totalTime: 1800,
            timeLeft: 1800,
            kingDisarmed: 'off',
            guardsEnabled: 'on',
            fogVision: 'off',
            treasureDrops: 'off',
            hiddenItems: 'off',
            heroAbility: 'off',
            arcadeMode: 'off',
            freezeTurns: 0,
            score: 0,
            hintEnabled: 'off',
            showHintPath: false,
            forceRedraw: false,
            invincibleTurns: 0,
            doubleMovesTurns: 0,
            heroCooldown: 0,
            pointItems: [],
            isStealth: false,
            selectingGuard: false,
            isSwapping: false,
            selectingTeleport: false,
            hasResurrection: false,
            wisdomActive: false,
            revealGuardVision: false,
            hiddenItemsOverride: false,
            canFly: false, 
            seeThroughWalls: false,
            isDefeating: false,
            isRangedAttack: false,
            canPhase: 0,
            invalidSquare: null,
            invisible: false,
            invisibilityTurns: 0,
            seenByGuard: false,
            wallsDestroyed: 0,
            decoyTurns: 0,
            decoyPos: null,
            selectingWall: false,
            revealTurns: 0,
            highlightSquare: null,
            paused: false,
            music: {
                audio: new Audio(),
                playlist: [
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(7).mp3', name: 'Il Gambetto del Re no.7', duration: '3:42' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(6).mp3', name: 'Il Gambetto del Re no.6', duration: '4:18' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(5).mp3', name: 'Il Gambetto del Re no.5', duration: '3:57' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(4).mp3', name: 'Il Gambetto del Re no.4', duration: '4:02' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(3).mp3', name: 'Il Gambetto del Re no.3', duration: '3:32' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(2).mp3', name: 'Il Gambetto del Re no.2', duration: '4:15' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/dc296967db5495f973bd1fbbd385fd74468e54dc/Il%20Gambetto%20del%20Re(1).mp3', name: 'Il Gambetto del Re no.1', duration: '3:48' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/470b9a7bab58eb92c6af096edad59fedb737a4d7/Il%20Gambetto%20del%20Re(8).mp3', name: 'Il Gambetto del Re no.8', duration: '3:52' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/470b9a7bab58eb92c6af096edad59fedb737a4d7/Il%20Gambetto%20del%20Re(9).mp3', name: 'Il Gambetto del Re no.9', duration: '4:08' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/470b9a7bab58eb92c6af096edad59fedb737a4d7/Il%20Gambetto%20del%20Re(10).mp3', name: 'Il Gambetto del Re no.10', duration: '3:38' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/470b9a7bab58eb92c6af096edad59fedb737a4d7/Il%20Gambetto%20del%20Re(11).mp3', name: 'Il Gambetto del Re no.11', duration: '4:12' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/470b9a7bab58eb92c6af096edad59fedb737a4d7/Il%20Gambetto%20del%20Re(12).mp3', name: 'Il Gambetto del Re no.12', duration: '3:47' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(13).mp3', name: 'Il Gambetto del Re no.13', duration: '4:07' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(14).mp3', name: 'Il Gambetto del Re no.14', duration: '3:53' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(15).mp3', name: 'Il Gambetto del Re no.15', duration: '4:13' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(16).mp3', name: 'Il Gambetto del Re no.16', duration: '3:37' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(17).mp3', name: 'Il Gambetto del Re no.17', duration: '4:27' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(18).mp3', name: 'Il Gambetto del Re no.18', duration: '3:49' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/7c3b9dd1d1eb8823253ab5096e8bdc41931e9aac/Il%20Gambetto%20del%20Re(19).mp3', name: 'Il Gambetto del Re no.19', duration: '4:03' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/ab80cba7747b619de38127c6a0841a41bf502347/Il%20Gambetto%20del%20Re(20).mp3', name: 'Il Gambetto del Re no.20', duration: '2:36' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/ab80cba7747b619de38127c6a0841a41bf502347/Il%20Gambetto%20del%20Re(21).mp3', name: 'Il Gambetto del Re no.21', duration: '2:32' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/ab80cba7747b619de38127c6a0841a41bf502347/Il%20Gambetto%20del%20Re(22).mp3', name: 'Il Gambetto del Re no.22', duration: '2:54' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/ab80cba7747b619de38127c6a0841a41bf502347/Il%20Gambetto%20del%20Re(23).mp3', name: 'Il Gambetto del Re no.23', duration: '1:27' },
                    { url: 'https://raw.githubusercontent.com/nickdoneysr/Fugitive/ab80cba7747b619de38127c6a0841a41bf502347/Il%20Gambetto%20del%20Re(24).mp3', name: 'Il Gambetto del Re no.24', duration: '0:58' },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(25).mp3", name: "Il Gambetto del Re no.25", duration: "3:02" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(26).mp3", name: "Il Gambetto del Re no.26", duration: "1:56" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(27).mp3", name: "Il Gambetto del Re no.27", duration: "2:29" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(28).mp3", name: "Il Gambetto del Re no.28", duration: "3:18" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(29).mp3", name: "Il Gambetto del Re no.29", duration: "3:57" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(30).mp3", name: "Il Gambetto del Re no.30", duration: "2:38" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(31).mp3", name: "Il Gambetto del Re no.31", duration: "3:24" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(32).mp3", name: "Il Gambetto del Re no.32", duration: "5:11" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(33).mp3", name: "Il Gambetto del Re no.33", duration: "3:08" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(34).mp3", name: "Il Gambetto del Re no.34", duration: "4:08" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(35).mp3", name: "Il Gambetto del Re no.35", duration: "3:15" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(36).mp3", name: "Il Gambetto del Re no.36", duration: "3:49" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(37).mp3", name: "Il Gambetto del Re no.37", duration: "4:13" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(38).mp3", name: "Il Gambetto del Re no.38", duration: "3:21" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(39).mp3", name: "Il Gambetto del Re no.39", duration: "2:24" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(40).mp3", name: "Il Gambetto del Re no.40", duration: "2:38" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(41).mp3", name: "Il Gambetto del Re no.41", duration: "3:24" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(42).mp3", name: "Il Gambetto del Re no.42", duration: "4:17" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(43).mp3", name: "Il Gambetto del Re no.43", duration: "2:43" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(44).mp3", name: "Il Gambetto del Re no.44", duration: "3:47" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(45).mp3", name: "Il Gambetto del Re no.45", duration: "3:18" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/ee2b1a2a2321a41d9e33a3ed5efcda94a1bb5064/Il%20Gambetto%20del%20Re(46).mp3", name: "Il Gambetto del Re no.46", duration: "3:29" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(47).mp3", name: "Il Gambetto del Re no.47", duration: "4:11" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(48).mp3", name: "Il Gambetto del Re no.48", duration: "3:34" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(49).mp3", name: "Il Gambetto del Re no.49", duration: "3:52" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(50).mp3", name: "Il Gambetto del Re no.50", duration: "2:37" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(51).mp3", name: "Il Gambetto del Re no.51", duration: "3:44" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(52).mp3", name: "Il Gambetto del Re no.52", duration: "3:57" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(53).mp3", name: "Il Gambetto del Re no.53", duration: "3:09" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(54).mp3", name: "Il Gambetto del Re no.54", duration: "4:24" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(55).mp3", name: "Il Gambetto del Re no.55", duration: "3:44" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(56).mp3", name: "Il Gambetto del Re no.56", duration: "2:57" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(57).mp3", name: "Il Gambetto del Re no.57", duration: "2:45" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(58).mp3", name: "Il Gambetto del Re no.58", duration: "3:19" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(59).mp3", name: "Il Gambetto del Re no.59", duration: "4:06" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(60).mp3", name: "Il Gambetto del Re no.60", duration: "4:34" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(61).mp3", name: "Il Gambetto del Re no.61", duration: "2:31" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(62).mp3", name: "Il Gambetto del Re no.62", duration: "4:19" },
                    { url: "https://raw.githubusercontent.com/nickdoneysr/Fugitive/a42b04c7cc397a975cb50eda4b290c99fa8e2eea/Il%20Gambetto%20del%20Re(63).mp3", name: "Il Gambetto del Re no.63", duration: "4:34" }
                ],
                currentTrack: 0,
                isPlaying: false,
                isMuted: false,
                isRepeating: false,
                hasErrored: false,
                animations: 'on',
                sfxVolume: 0.5,
                selectedSongs: [],
                playOrder: 'normal',
                currentPlaylist: []
            }
        };

        let previousState = {
            king: null,
            jail: null,
            escape: null,
            opponents: [],
            phase: null,
            tutorialStep: null,
            hoveredGuard: null,
            treasures: [],
            pointItems: [],
            validMoves: [],
            tutorialHighlights: [],
            guardVision: [],
            hintPath: []
        };

        const leaderboard = JSON.parse(localStorage.getItem('fugitiveLeaderboard')) || [];

        const keyState = {};
        document.addEventListener('keydown', (e) => {
            keyState[e.key] = true;
            handleKeyDown(e);
        });
        document.addEventListener('keyup', (e) => {
            keyState[e.key] = false;
        });

        const themesList = {
            'light': { light: '#f5f5f5', dark: '#a0a0a0', bg: '#e0e0e0', btn: '#4CAF50', btnHover: '#45a049', text: '#333', font: 'Arial, sans-serif' },
            'dark': { light: '#555', dark: '#222', bg: '#1a1a1a', btn: '#ff4444', btnHover: '#cc3333', text: '#fff', font: 'Arial, sans-serif' },
            'greyscale': { light: '#ccc', dark: '#666', bg: '#999', btn: '#555', btnHover: '#444', text: '#000', font: 'Cabin, sans-serif' },
            'rgb': { light: '#f00', dark: '#0f0', bg: '#00f', btn: '#ff0', btnHover: '#cc0', text: '#fff', font: 'Orbitron, sans-serif' },
            '90s': { light: '#ff69b4', dark: '#00ced1', bg: '#fffacd', btn: '#ff4500', btnHover: '#cc3700', text: '#000', font: 'VCR OSD Mono, monospace' },
            '80s': { light: '#ff00ff', dark: '#00ffff', bg: '#000', btn: '#ffff00', btnHover: '#cccc00', text: '#fff', font: 'Press Start 2P, cursive' },
            '70s': { light: '#ffa500', dark: '#8b4513', bg: '#ffd700', btn: '#228b22', btnHover: '#1a6b1a', text: '#000', font: 'Bubblegum Sans, cursive' },
            'neon': { light: '#ff0', dark: '#0ff', bg: '#000', btn: '#f0f', btnHover: '#c0c', text: '#fff', font: 'Audiowide, cursive' },
            'paint': { light: '#ff9999', dark: '#99ccff', bg: '#fff', btn: '#66cc66', btnHover: '#55aa55', text: '#000', font: 'Permanent Marker, cursive' },
            'galaxy': { light: '#d8bfd8', dark: '#4b0082', bg: '#000', btn: '#ff00ff', btnHover: '#cc00cc', text: '#fff', font: 'Exo 2, sans-serif' },
            'pirate': { light: '#d2b48c', dark: '#8b4513', bg: '#4682b4', btn: '#b22222', btnHover: '#8b1a1a', text: '#fff', font: 'Hanalei Fill, cursive' },
            'cyberpunk': { light: '#00ffff', dark: '#ff00ff', bg: '#1a1a1a', btn: '#ff1493', btnHover: '#cc1075', text: '#fff', font: 'Rajdhani, sans-serif' },
            'retro-arcade': { light: '#ff4500', dark: '#000080', bg: '#000', btn: '#00ff00', btnHover: '#00cc00', text: '#fff', font: 'Press Start 2P, cursive' },
            'nature': { light: '#98fb98', dark: '#228b22', bg: '#f0fff0', btn: '#8b4513', btnHover: '#6b3510', text: '#000', font: 'Cabin, sans-serif' },
            'steampunk': { light: '#cd853f', dark: '#8b4513', bg: '#2f2f2f', btn: '#4682b4', btnHover: '#36648b', text: '#fff', font: 'MedievalSharp, cursive' },
            'mythology': { light: '#ffd700', dark: '#b8860b', bg: '#4a2c2a', btn: '#dc143c', btnHover: '#b01030', text: '#fff', font: 'MedievalSharp, cursive' },
            'underwater': { light: '#00ced1', dark: '#1e90ff', bg: '#000080', btn: '#20b2aa', btnHover: '#1a8c8c', text: '#fff', font: 'Cabin, sans-serif' },
            'desert': { light: '#f4a460', dark: '#cd853f', bg: '#ffe4b5', btn: '#8b4513', btnHover: '#6b3510', text: '#000', font: 'Rajdhani, sans-serif' },
            'jungle': { light: '#9acd32', dark: '#228b22', bg: '#006400', btn: '#8b4513', btnHover: '#6b3510', text: '#fff', font: 'Cabin, sans-serif' },
            'space': { light: '#e6e6fa', dark: '#483d8b', bg: '#000', btn: '#ff00ff', btnHover: '#cc00cc', text: '#fff', font: 'Orbitron, sans-serif' },
            'ice': { light: '#f0f8ff', dark: '#b0c4de', bg: '#add8e6', btn: '#4682b4', btnHover: '#36648b', text: '#000', font: 'Exo 2, sans-serif' },
            'volcano': { light: '#ff4500', dark: '#8b0000', bg: '#2f2f2f', btn: '#ffa500', btnHover: '#cc8400', text: '#fff', font: 'Bebas Neue, sans-serif' },
            'candy': { light: '#ff69b4', dark: '#ff1493', bg: '#fff0f5', btn: '#00ff7f', btnHover: '#00cc66', text: '#000', font: 'Bubblegum Sans, cursive' },
            'haunted': { light: '#778899', dark: '#2f2f2f', bg: '#000', btn: '#ff4500', btnHover: '#cc3700', text: '#fff', font: 'Creepster, cursive' },
            'circus': { light: '#ff0000', dark: '#ffd700', bg: '#87ceeb', btn: '#0000ff', btnHover: '#0000cc', text: '#000', font: 'Permanent Marker, cursive' },
            'dream': { light: '#dda0dd', dark: '#9370db', bg: '#f8f0fa', btn: '#ff69b4', btnHover: '#cc5291', text: '#000', font: 'Exo 2, sans-serif' },
            'noir': { light: '#696969', dark: '#2f2f2f', bg: '#000000', btn: '#b0c4de', btnHover: '#8fa3c4', text: '#fff', font: 'Nosifer, cursive' },
            'forest': { light: '#228B22', dark: '#8B4513', bg: '#556B2F', btn: '#32CD32', btnHover: '#228B22', text: '#FFFFFF', font: 'Cabin, sans-serif' },
            'spring': { light: '#98FB98', dark: '#FFB6C1', bg: '#FFFFE0', btn: '#ADD8E6', btnHover: '#87CEEB', text: '#006400', font: 'Playfair Display, serif' },
            'summer': { light: '#FFFF00', dark: '#FFA500', bg: '#87CEEB', btn: '#FF0000', btnHover: '#CC0000', text: '#000000', font: 'Lobster, cursive' },
            'autumn': { light: '#F5F5DC', dark: '#A52A2A', bg: '#808000', btn: '#FFA500', btnHover: '#FF8C00', text: '#FFFFFF', font: 'Merriweather, serif' },
            'winter': { light: '#FFFFFF', dark: '#ADD8E6', bg: '#00008B', btn: '#C0C0C0', btnHover: '#A9A9A9', text: '#000000', font: 'Roboto, sans-serif' },
            'renaissance': { light: '#FFD700', dark: '#800000', bg: '#006400', btn: '#800080', btnHover: '#4B0082', text: '#FFFFF0', font: 'Cinzel, serif' },
            'victorian': { light: '#D3D3D3', dark: '#696969', bg: '#2F4F4F', btn: '#DAA520', btnHover: '#B8860B', text: '#FFFFFF', font: 'Old Standard TT, serif' },
            'art-deco': { light: '#FFD700', dark: '#000000', bg: '#2C3E50', btn: '#FF4500', btnHover: '#DC143C', text: '#FFFFFF', font: 'Abril Fatface, cursive' },
            'ancient-egypt': { light: '#F4C430', dark: '#8B4513', bg: '#000000', btn: '#4682B4', btnHover: '#4169E1', text: '#FFD700', font: 'Papyrus, fantasy' },
            'samurai': { light: '#D3D3D3', dark: '#000000', bg: '#8B0000', btn: '#FFD700', btnHover: '#FFA500', text: '#FFFFFF', font: 'Noto Serif JP, serif' },
            'fantasy': { light: '#E6E6FA', dark: '#9370DB', bg: '#4B0082', btn: '#FF69B4', btnHover: '#FF1493', text: '#FFFFFF', font: 'Uncial Antiqua, cursive' },
            'sci-fi': { light: '#00FF00', dark: '#0000FF', bg: '#000000', btn: '#FF00FF', btnHover: '#FF69B4', text: '#FFFFFF', font: 'Orbitron, sans-serif' },
            'steampunk-new': { light: '#DAA520', dark: '#8B4513', bg: '#2F4F4F', btn: '#4682B4', btnHover: '#4169E1', text: '#FFFFFF', font: 'Special Elite, cursive' },
            'cyberpunk-new': { light: '#FF00FF', dark: '#00FFFF', bg: '#000000', btn: '#FF4500', btnHover: '#FF6347', text: '#FFFFFF', font: 'Share Tech Mono, monospace' },
            'mythical': { light: '#FFD700', dark: '#4B0082', bg: '#000000', btn: '#DC143C', btnHover: '#B22222', text: '#FFFFFF', font: 'MedievalSharp, cursive' },
            'ocean': { light: '#00CED1', dark: '#4682B4', bg: '#000080', btn: '#20B2AA', btnHover: '#008B8B', text: '#FFFFFF', font: 'Cabin, sans-serif' },
            'desert-new': { light: '#F4A460', dark: '#CD853F', bg: '#FFE4B5', btn: '#8B4513', btnHover: '#A0522D', text: '#000000', font: 'Rajdhani, sans-serif' },
            'mountains': { light: '#B0C4DE', dark: '#4682B4', bg: '#2F4F4F', btn: '#696969', btnHover: '#808080', text: '#FFFFFF', font: 'Lato, sans-serif' },
            'forest-new': { light: '#228B22', dark: '#8B4513', bg: '#556B2F', btn: '#32CD32', btnHover: '#228B22', text: '#FFFFFF', font: 'Cabin, sans-serif' },
            'jungle-new': { light: '#9ACD32', dark: '#228B22', bg: '#006400', btn: '#8B4513', btnHover: '#A0522D', text: '#FFFFFF', font: 'Cabin, sans-serif' },
            'arctic': { light: '#F0F8FF', dark: '#B0C4DE', bg: '#ADD8E6', btn: '#4682B4', btnHover: '#4169E1', text: '#000000', font: 'Exo 2, sans-serif' },
            'minimalist': { light: '#FFFFFF', dark: '#D3D3D3', bg: '#F5F5F5', btn: '#A9A9A9', btnHover: '#808080', text: '#000000', font: 'Helvetica, sans-serif' },
            'vibrant': { light: '#FF4500', dark: '#FFD700', bg: '#000000', btn: '#00FF00', btnHover: '#32CD32', text: '#FFFFFF', font: 'Bebas Neue, sans-serif' },
            'monochrome': { light: '#D3D3D3', dark: '#808080', bg: '#000000', btn: '#A9A9A9', btnHover: '#696969', text: '#FFFFFF', font: 'Roboto Mono, monospace' },
            'pastel': { light: '#FFB6C1', dark: '#98FB98', bg: '#E6E6FA', btn: '#FFD700', btnHover: '#FFA500', text: '#000000', font: 'Quicksand, sans-serif' },
            'neon-new': { light: '#FF00FF', dark: '#00FF00', bg: '#000000', btn: '#FFFF00', btnHover: '#FFD700', text: '#FFFFFF', font: 'Audiowide, cursive' },
            'retro': { light: '#FFD700', dark: '#FF4500', bg: '#000000', btn: '#00FF00', btnHover: '#32CD32', text: '#FFFFFF', font: 'Press Start 2P, cursive' },
            'vintage': { light: '#F5DEB3', dark: '#8B4513', bg: '#D2B48C', btn: '#A0522D', btnHover: '#8B4513', text: '#000000', font: 'Great Vibes, cursive' },
            'luxury': { light: '#FFD700', dark: '#000000', bg: '#4B0082', btn: '#FF4500', btnHover: '#DC143C', text: '#FFFFFF', font: 'Playfair Display, serif' },
            'candy-new': { light: '#FF69B4', dark: '#FF1493', bg: '#FFF0F5', btn: '#00FF7F', btnHover: '#00CC66', text: '#000000', font: 'Bubblegum Sans, cursive' },
            'haunted-new': { light: '#778899', dark: '#2F2F2F', bg: '#000000', btn: '#FF4500', btnHover: '#CC3700', text: '#FFFFFF', font: 'Creepster, cursive' },
            'circus-new': { light: '#FF0000', dark: '#FFD700', bg: '#87CEEB', btn: '#0000FF', btnHover: '#0000CC', text: '#000000', font: 'Permanent Marker, cursive' },
            'dream-new': { light: '#DDA0DD', dark: '#9370DB', bg: '#F8F0FA', btn: '#FF69B4', btnHover: '#CC5291', text: '#000000', font: 'Exo 2, sans-serif' },
            'noir-new': { light: '#696969', dark: '#2F2F2F', bg: '#000000', btn: '#B0C4DE', btnHover: '#8FA3C4', text: '#FFFFFF', font: 'Nosifer, cursive' },
            'galactic': { light: '#E6E6FA', dark: '#483D8B', bg: '#000000', btn: '#FF00FF', btnHover: '#CC00CC', text: '#FFFFFF', font: 'Orbitron, sans-serif' },
            'pirate-new': { light: '#D2B48C', dark: '#8B4513', bg: '#4682B4', btn: '#B22222', btnHover: '#8B1A1A', text: '#FFFFFF', font: 'Hanalei Fill, cursive' },
            'volcano-new': { light: '#FF4500', dark: '#8B0000', bg: '#2F2F2F', btn: '#FFA500', btnHover: '#CC8400', text: '#FFFFFF', font: 'Bebas Neue, sans-serif' },
            'ice-new': { light: '#F0F8FF', dark: '#B0C4DE', bg: '#ADD8E6', btn: '#4682B4', btnHover: '#36648B', text: '#000000', font: 'Exo 2, sans-serif' },
            'paint-new': { light: '#FF9999', dark: '#99CCFF', bg: '#FFFFFF', btn: '#66CC66', btnHover: '#55AA55', text: '#000000', font: 'Permanent Marker, cursive' },
            'greyscale-new': { light: '#CCCCCC', dark: '#666666', bg: '#999999', btn: '#555555', btnHover: '#444444', text: '#000000', font: 'Cabin, sans-serif' },
            'rgb-new': { light: '#FF0000', dark: '#00FF00', bg: '#0000FF', btn: '#FFFF00', btnHover: '#FFCC00', text: '#FFFFFF', font: 'Orbitron, sans-serif' },
            '90s-new': { light: '#FF69B4', dark: '#00CED1', bg: '#FFFACD', btn: '#FF4500', btnHover: '#CC3700', text: '#000000', font: 'VCR OSD Mono, monospace' },
            '80s-new': { light: '#FF00FF', dark: '#00FFFF', bg: '#000000', btn: '#FFFF00', btnHover: '#CCCC00', text: '#FFFFFF', font: 'Press Start 2P, cursive' },
            '70s-new': { light: '#FFA500', dark: '#8B4513', bg: '#FFD700', btn: '#228B22', btnHover: '#1A6B1A', text: '#000000', font: 'Bubblegum Sans, cursive' },
            'nature-new': { light: '#98FB98', dark: '#228B22', bg: '#F0FFF0', btn: '#8B4513', btnHover: '#6B3510', text: '#000000', font: 'Cabin, sans-serif' },
            'retro-arcade-new': { light: '#FF4500', dark: '#000080', bg: '#000000', btn: '#00FF00', btnHover: '#00CC00', text: '#FFFFFF', font: 'Press Start 2P, cursive' },
            'galaxy-new': { light: '#D8BFD8', dark: '#4B0082', bg: '#000000', btn: '#FF00FF', btnHover: '#CC00CC', text: '#FFFFFF', font: 'Exo 2, sans-serif' },
            'cyberpunk-newer': { light: '#00FFFF', dark: '#FF00FF', bg: '#1A1A1A', btn: '#FF1493', btnHover: '#CC1075', text: '#FFFFFF', font: 'Rajdhani, sans-serif' },
            'mythology-new': { light: '#FFD700', dark: '#B8860B', bg: '#4A2C2A', btn: '#DC143C', btnHover: '#B01030', text: '#FFFFFF', font: 'MedievalSharp, cursive' },
            'underwater-new': { light: '#00CED1', dark: '#1E90FF', bg: '#000080', btn: '#20B2AA', btnHover: '#1A8C8C', text: '#FFFFFF', font: 'Cabin, sans-serif' },
            'twilight': { light: '#E0B0FF', dark: '#6A0DAD', bg: '#191970', btn: '#FF69B4', btnHover: '#FF1493', text: '#FFFFFF', font: 'Lora, serif' },
            'dystopian': { light: '#808080', dark: '#A52A2A', bg: '#2F4F4F', btn: '#FF4500', btnHover: '#DC143C', text: '#FFFFFF', font: 'Impact, sans-serif' },
            'utopian': { light: '#ADD8E6', dark: '#98FB98', bg: '#F0FFF0', btn: '#FFD700', btnHover: '#FFA500', text: '#000000', font: 'Futura, sans-serif' },
            'noir-detective': { light: '#D3D3D3', dark: '#696969', bg: '#000000', btn: '#A9A9A9', btnHover: '#808080', text: '#FFFFFF', font: 'Courier New, monospace' },
            'carnival': { light: '#FF0000', dark: '#FFD700', bg: '#87CEEB', btn: '#0000FF', btnHover: '#0000CC', text: '#000000', font: 'Showcard Gothic, fantasy' },
            'zen': { light: '#FFFFFF', dark: '#D3D3D3', bg: '#F5F5F5', btn: '#A9A9A9', btnHover: '#808080', text: '#000000', font: 'Gill Sans, sans-serif' },
            'baroque': { light: '#FFD700', dark: '#800000', bg: '#006400', btn: '#800080', btnHover: '#4B0082', text: '#FFFFF0', font: 'Palace Script MT, cursive' },
            'cyberpunk-noir': { light: '#00FFFF', dark: '#FF00FF', bg: '#1A1A1A', btn: '#FF1493', btnHover: '#CC1075', text: '#FFFFFF', font: 'Neuropol, sans-serif' },
            'apocalyptic': { light: '#BDB76B', dark: '#8B4513', bg: '#556B2F', btn: '#A0522D', btnHover: '#8B4513', text: '#FFFFFF', font: 'Destroyed, fantasy' },
            'magical-realism': { light: '#FFB6C1', dark: '#98FB98', bg: '#E6E6FA', btn: '#FFD700', btnHover: '#FFA500', text: '#000000', font: 'Amatic SC, cursive' },
            'retro-futurism': { light: '#00CED1', dark: '#FF4500', bg: '#000000', btn: '#FFD700', btnHover: '#FFA500', text: '#FFFFFF', font: 'Atomic Age, cursive' },
            'halloween': { light: '#FFA500', dark: '#8B4513', bg: '#000000', btn: '#FF4500', btnHover: '#CC3700', text: '#FFFFFF', font: 'Creepster, cursive' },
            'baroque-opulence': { light: '#F5E050', dark: '#4A2C2A', bg: '#1C2526', btn: '#8A2BE2', btnHover: '#6A0DAD', text: '#FFFFFF', font: 'Garamond, serif' },
            'cosmic-dawn': { light: '#FFB6C1', dark: '#4B0082', bg: '#0F0F2F', btn: '#FF69B4', btnHover: '#FF1493', text: '#FFFFFF', font: 'Alegreya, serif' },
            'sahara-sunset': { light: '#FF8C00', dark: '#8A360F', bg: '#FFF5E1', btn: '#D2691E', btnHover: '#A0522D', text: '#000000', font: 'Fira Sans, sans-serif' },
            'arctic-twilight': { light: '#E0FFFF', dark: '#4682B4', bg: '#191970', btn: '#00CED1', btnHover: '#008B8B', text: '#FFFFFF', font: 'Montserrat, sans-serif' },
            'gothic-romance': { light: '#D8BFD8', dark: '#4B0082', bg: '#2F004F', btn: '#800000', btnHover: '#5C0000', text: '#FFFFFF', font: 'EB Garamond, serif' },
            'urban-jungle': { light: '#9ACD32', dark: '#696969', bg: '#2F4F4F', btn: '#228B22', btnHover: '#1A6B1A', text: '#FFFFFF', font: 'Urbanist, sans-serif' },
            'retro-synthwave': { light: '#FF77FF', dark: '#00B7EB', bg: '#1B1B3A', btn: '#FFCC00', btnHover: '#FFA500', text: '#FFFFFF', font: 'Orbitron, sans-serif' },
            'mediterranean-coast': { light: '#F0E68C', dark: '#4682B4', bg: '#E0FFFF', btn: '#FF6347', btnHover: '#CD5C5C', text: '#000000', font: 'Lato, sans-serif' },
            'celestial-myth': { light: '#F0E68C', dark: '#2A4066', bg: '#0C0C1F', btn: '#DAA520', btnHover: '#B8860B', text: '#FFFFFF', font: 'Sorts Mill Goudy, serif' },
            'industrial-rust': { light: '#CD5C5C', dark: '#4A2C2A', bg: '#3C2F2F', btn: '#8B5A2B', btnHover: '#6B4226', text: '#FFFFFF', font: 'Oswald, sans-serif' },
            'beach': { light: '#FFFACD', dark: '#DAA520', bg: '#E0FFFF', btn: '#32CD32', btnHover: '#228B22', text: '#000000', font: 'Pacifico, cursive' },
            'sunset': { light: '#FFDAB9', dark: '#FF6347', bg: '#FFA07A', btn: '#FF4500', btnHover: '#FF0000', text: '#000000', font: 'Dancing Script, cursive' },
            'enchanted-forest': { light: '#E6E6FA', dark: '#483D8B', bg: '#228B22', btn: '#FFD700', btnHover: '#FFA500', text: '#FFFFFF', font: 'Cardo, serif' },
            'canyon': { light: '#FF7F50', dark: '#8B4513', bg: '#D2B48C', btn: '#CD853F', btnHover: '#A0522D', text: '#000000', font: 'Arvo, serif' }
        };

        const themes = { ...themesList };

        const pieceStylesList = {
            'classic': { pawn: '♟', rook: '♜', knight: '♞', bishop: '♝', queen: '♛', king: '👑' },
            'catholic': { pawn: '🙏', rook: '🏰', knight: '⚔️', bishop: '⛪', queen: '👿', king: '✝️' },
            'minimalist': { pawn: 'p', rook: 'r', knight: 'n', bishop: 'b', queen: 'q', king: 'k' },
            'fantasy': { pawn: '🧝', rook: '🏯', knight: '🐉', bishop: '🧙', queen: '🧚', king: '🧞' },
            'scifi': { pawn: '🤖', rook: '🛰️', knight: '👽', bishop: '🖖', queen: '🌌', king: '🚀' },
            'pirate-crew': { pawn: '🏴‍☠️', rook: '⚓', knight: '🗡️', bishop: '🧭', queen: '💰', king: '⚔️' },
            'circus-troupe': { pawn: '🤡', rook: '🎪', knight: '🐘', bishop: '🎩', queen: '🎭', king: '🎬' },
            'steampunk-gadgets': { pawn: '⚙️', rook: '🏭', knight: '🛩️', bishop: '🔧', queen: '⏰', king: '🛠️' },
            'elemental': { pawn: '💧', rook: '🔥', knight: '🌪️', bishop: '⛰️', queen: '☀️', king: '🌩️' },
            'candy-cast': { pawn: '🍬', rook: '🍫', knight: '🍭', bishop: '🍰', queen: '🍩', king: '🍪' },
            'ancient-egypt': { pawn: '𓃰', rook: '𓉔', knight: '𓃗', bishop: '𓋹', queen: '𓋨', king: '𓀭' },
            'musical-instruments': { pawn: '🎷', rook: '🥁', knight: '🎻', bishop: '🎺', queen: '🎹', king: '🎼' },
            'sports-equipment': { pawn: '⚽', rook: '🏈', knight: '🏀', bishop: '🎾', queen: '🏆', king: '🥇' },
            'fruits': { pawn: '🍎', rook: '🍌', knight: '🍇', bishop: '🍓', queen: '🍍', king: '🍉' },
            'zodiac-signs': { pawn: '♈', rook: '♉', knight: '♊', bishop: '♋', queen: '♌', king: '♍' },
            'braille': { pawn: '⠐', rook: '⠿', knight: '⠸', bishop: '⠼', queen: '⠾', king: '⠷' },
            'musical': { pawn: '♩', rook: '𝄻', knight: '♫', bishop: '𝄢', queen: '♬', king: '𝄐' },
            'geometric': { pawn: '⚬', rook: '⧫', knight: '△', bishop: '♦', queen: '★', king: '◯' },
            'math': { pawn: '+', rook: '×', knight: '÷', bishop: '∫', queen: '∞', king: '∑' },
            'currency': { pawn: '¢', rook: '$', knight: '€', bishop: '¥', queen: '£', king: '₿' },
            'arrows': { pawn: '→', rook: '⇉', knight: '↬', bishop: '↗', queen: '↻', king: '🡆' },
            'letterlike': { pawn: '℘', rook: 'ℝ', knight: 'ℕ', bishop: 'ℬ', queen: 'ℚ', king: '𝕂' },
            'supersub': { pawn: 'ₚ', rook: 'ʳ', knight: 'ₙ', bishop: 'ᵇ', queen: 'ᵩ', king: 'ᵏ' },
            'dingbats': { pawn: '✶', rook: '❒', knight: '✪', bishop: '✝', queen: '❀', king: '♔' },
            'emoticons': { pawn: '😐', rook: '🏢', knight: '🐴', bishop: '👤', queen: '👩', king: '👨' }
        };

        const pieceStyles = pieceStylesList;

        function createCustomPieceStyle() {
            const name = prompt('Enter a name for your custom piece style:');
            if (!name) return;
            const pawn = prompt('Enter symbol for Pawn (e.g., emoji):') || '♟';
            const rook = prompt('Enter symbol for Rook:') || '♜';
            const knight = prompt('Enter symbol for Knight:') || '♞';
            const bishop = prompt('Enter symbol for Bishop:') || '♝';
            const queen = prompt('Enter symbol for Queen:') || '♛';
            const king = prompt('Enter symbol for King:') || '👑';
            pieceStyles[`custom:${name}`] = { pawn, rook, knight, bishop, queen, king };
            localStorage.setItem('fugitivePieceStyles', JSON.stringify(pieceStyles));
            initPieceStyleDropdown();
            state.pieceStyle = `custom:${name}`;
            document.getElementById('piece-style').value = `custom:${name}`;
            drawBoard();
            showMessage(`Custom piece style "${name}" created!`);
        }

        document.getElementById('btn-custom-piece').addEventListener('click', createCustomPieceStyle);

        const blocks = {
            pawn: 4,
            knight: 8,
            rook: 12,
            bishop: 16,
            queen: 20,
            king: 24
        };

        const levels = Array(100).fill().map((_, i) => {
            const level = i + 1;
            if (level <= 20) return { pawns: Math.min(3 + Math.floor(level / 5), 8), rooks: 0, knights: 0, bishops: 0, queen: 0 };
            if (level <= 40) return { pawns: 4, rooks: Math.floor(level / 20), knights: Math.floor(level / 15), bishops: 0, queen: 0 };
            if (level <= 60) return { pawns: 5, rooks: 1, knights: 1, bishops: Math.floor(level / 25), queen: 0 };
            if (level <= 80) return { pawns: 6, rooks: 1, knights: 1, bishops: 1, queen: Math.floor(level / 50) };
            return { pawns: 8, rooks: 2, knights: 2, bishops: 2, queen: 1 };
        });

        const stats = {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            totalMoves: 0,
            totalRolls: 0,
            guardsDefeated: 0,
            treasuresCollected: 0,
            highestScore: 0,
            achievementsUnlocked: 0,
            totalTimePlayed: 0
        };

        // Load stats from local storage if available
        const savedStats = JSON.parse(localStorage.getItem('fugitiveStats')) || {};
        Object.assign(stats, savedStats);

        const achievements = [
            { id: 'pacifist', name: 'Pacifist', description: 'Win a game without capturing any guards', achieved: false },
            { id: 'speedrunner', name: 'Speedrunner', description: 'Complete a level in under 10 moves', achieved: false },
            { id: 'level-novice', name: 'Level Novice', description: 'Complete level 1', achieved: false },
            { id: 'level-apprentice', name: 'Level Apprentice', description: 'Complete level 10', achieved: false },
            { id: 'level-expert', name: 'Level Expert', description: 'Complete level 50', achieved: false },
            { id: 'level-master', name: 'Level Master', description: 'Complete all 100 levels', achieved: false },
            { id: 'difficulty-pawn', name: 'Pawn Difficulty', description: 'Win a level on Pawn difficulty', achieved: false },
            { id: 'difficulty-knight', name: 'Knight Difficulty', description: 'Win a level on Knight difficulty', achieved: false },
            { id: 'difficulty-rook', name: 'Rook Difficulty', description: 'Win a level on Rook difficulty', achieved: false },
            { id: 'difficulty-bishop', name: 'Bishop Difficulty', description: 'Win a level on Bishop difficulty', achieved: false },
            { id: 'difficulty-queen', name: 'Queen Difficulty', description: 'Win a level on Queen difficulty', achieved: false },
            { id: 'difficulty-king', name: 'King Difficulty', description: 'Win a level on King difficulty', achieved: false },
            { id: 'quick-escape', name: 'Quick Escape', description: 'Complete a level in under 5 turns', achieved: false },
            { id: 'stealthy-escape', name: 'Stealthy Escape', description: 'Win a level without entering any guard\'s vision', achieved: false },
            { id: 'treasure-collector', name: 'Treasure Collector', description: 'Collect all treasures in a level', achieved: false },
            { id: 'minimalist', name: 'Minimalist', description: 'Win a level without collecting any treasures', achieved: false },
            { id: 'hero-user', name: 'Hero User', description: 'Win a level using a hero\'s ability', achieved: false },
            { id: 'disarmed-victory', name: 'Disarmed Victory', description: 'Win a level with King Disarmed on', achieved: false },
            { id: 'time-pressure', name: 'Time Pressure', description: 'Win a level with Turn Timer on', achieved: false },
            { id: 'limited-turns', name: 'Limited Turns', description: 'Win a level with Turn Limit set to 5', achieved: false },
            { id: 'fog-navigator', name: 'Fog Navigator', description: 'Win a level with Fog Vision on', achieved: false },
            { id: 'hidden-treasures', name: 'Hidden Treasures', description: 'Win a level with Hidden Items on', achieved: false },
            { id: 'portal-jumper', name: 'Portal Jumper', description: 'Use a portal to reach the escape directly', achieved: false },
            { id: 'guard-slayer', name: 'Guard Slayer', description: 'Defeat 5 guards in a single level', achieved: false },
            { id: 'untouchable', name: 'Untouchable', description: 'Win a level without the king being in a guard\'s vision at any point', achieved: false },
            { id: 'arcade-beginner', name: 'Arcade Beginner', description: 'Reach 100 points in Arcade Mode', achieved: false },
            { id: 'arcade-pro', name: 'Arcade Pro', description: 'Reach 500 points in Arcade Mode', achieved: false },
            { id: 'arcade-master', name: 'Arcade Master', description: 'Reach 1000 points in Arcade Mode', achieved: false },
            { id: 'level-conqueror', name: 'Level Conqueror', description: 'Complete 50 levels in total', achieved: false },
            { id: 'treasure-hoarder', name: 'Treasure Hoarder', description: 'Collect 100 treasures in total', achieved: false },
            { id: 'guard-nemesis', name: 'Guard Nemesis', description: 'Defeat 100 guards in total', achieved: false },
            { id: 'treasure-hunter', name: 'Treasure Hunter', description: 'Collect 5 treasures in a single game', achieved: false },
            { id: 'guard-slayer-extreme', name: 'Guard Slayer Extreme', description: 'Defeat 10 guards in a single game', achieved: false },
            { id: 'decoy-master', name: 'Decoy Master', description: 'Use the decoy treasure to avoid capture', achieved: false },
            { id: 'wall-destroyer', name: 'Wall Destroyer', description: 'Destroy 3 walls in one game', achieved: false },
            { id: 'portal-explorer', name: 'Portal Explorer', description: 'Use 3 different portals in one game', achieved: false },
            { id: 'time-attack-champ', name: 'Time Attack Champion', description: 'Win with Time Attack mode in under 15 minutes', achieved: false }
        ];

        function updateAchievementsList() {
            const list = document.getElementById('achievements-list');
            list.innerHTML = '';
            achievements.forEach(ach => {
                const div = document.createElement('div');
                const checkmark = ach.achieved ? '✅ ' : '❌ ';
                div.textContent = `${checkmark}${ach.name}: ${ach.description}`;
                list.appendChild(div);
            });
        }

        function clearAchievements() {
            if (confirm('Are you sure you want to clear all achievements?')) {
                achievements.forEach(ach => ach.achieved = false);
                localStorage.removeItem('fugitiveAchievements');
                updateAchievementsList();
                updateStatsDisplay();
                alert('Achievements cleared.');
            }
        }

        const openingBook = {
            'white': [
                { move: [6, 4, 4, 4], response: [1, 4, 3, 4] }, // e4 e5
                { move: [6, 3, 4, 3], response: [1, 4, 3, 4] }, // d4 e5
                { move: [6, 6, 4, 6], response: [1, 4, 3, 4] }, // g4 e5
                { move: [6, 1, 5, 2], response: [1, 4, 3, 4] }  // Nf3 e5
            ],
            'black': [
                { move: [1, 4, 3, 4], condition: [6, 4, 4, 4] }, // e5 after e4
                { move: [1, 6, 3, 6], condition: [6, 4, 4, 4] }, // g6 after e4
                { move: [1, 5, 2, 5], condition: [6, 4, 4, 4] }, // Nf6 after e4
                { move: [1, 3, 3, 3], condition: [6, 3, 4, 3] }  // d5 after d4
            ]
        };

        // --- Navigation Functions ---
        function showSection(sectionId) {
            const sections = ['start-page', 'fugitive-menu', 'game-area', 'creative-mode', 'tutorial-section', 'settings-section', 'rules-content', 'standard-chess-section', 'achievements-section', 'tips-strategy-section', 'store-section'];
            sections.forEach(id => {
                const section = document.getElementById(id);
                if (section) {
                    if (id === sectionId) {
                        section.style.display = 'flex';
                        section.classList.add('active');
                        setTimeout(() => section.style.opacity = '1', 0);
                    } else {
                        section.style.opacity = '0';
                        section.classList.remove('active');
                        setTimeout(() => section.style.display = 'none', 500);
                    }
                } else {
                    console.warn(`Section with id "${id}" not found.`);
                }
            });
            const customPrompt = document.getElementById('custom-prompt');
            if (customPrompt) {
                customPrompt.style.display = 'none';
            } else {
                console.warn('Custom prompt element not found.');
            }
            if (sectionId === 'start-page') {
                generateAdBoard();
                adBoardInterval = setInterval(generateAdBoard, 2000);
            } else {
                clearInterval(adBoardInterval);
            }
            clearInterval(turnTimer);
            clearInterval(standardState.timer);

            const canvases = {
                'game-area': 'board',
                'tutorial-section': 'tutorial-board',
                'creative-mode': 'creative-board',
                'standard-chess-section': 'standard-chess-board'
            };
            Object.entries(canvases).forEach(([section, canvasId]) => {
                const canvas = document.getElementById(canvasId);
                if (canvas) canvas.style.display = section === sectionId ? 'block' : 'none';
            });

            if (sectionId === 'standard-chess-section' && state.mode === 'standard') {
                setTimeout(drawStandardBoard, 0);
                standardState.moveHistory = [];
            } else if (sectionId === 'game-area' && state.mode === 'fugitive') {
                setTimeout(drawBoard, 0);
            } else if (sectionId === 'creative-mode' && state.mode === 'creative') {
                setTimeout(drawCreativeBoard, 0);
            } else if (sectionId === 'tutorial-section' && state.mode === 'tutorial') {
                setTimeout(drawBoard, 0);
            }
            if (sectionId === 'achievements-section') {
                updateAchievementsList();
            }
        }

        function openTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => {
                if (tab.id === tabName) {
                    tab.classList.add('active');
                    setTimeout(() => {
                        tab.style.opacity = '1';
                        const tabContainer = tab.closest('.tab-container');
                        if (tabContainer) {
                            tabContainer.style.height = `${tab.offsetHeight}px`;
                        }
                    }, 10);
                } else {
                    tab.style.opacity = '0';
                    tab.classList.remove('active');
                }
            });
            buttons.forEach(btn => {
                btn.classList.toggle('active', btn.onclick.toString().includes(tabName));
            });
        }

        function showStartPage() {
            showSection('start-page');
            clearInterval(turnTimer);
        }

        // --- Campaign Functions ---
        function initializeCampaign() {
            const progress = {
                prisons: prisons.map((name, index) => ({
                    name: name,
                    unlocked: index === 0, // Only the first prison is unlocked initially
                    completed: false
                })),
                currentPrison: prisons[0] // Start with the first prison
            };
            saveCampaignProgress(progress);
            return progress;
        }

        // Function to save campaign progress to local storage
        function saveCampaignProgress(progress) {
            localStorage.setItem('campaignProgress', JSON.stringify(progress));
        }

        // Function to load campaign progress from local storage
        function loadCampaignProgress() {
            const progress = localStorage.getItem('campaignProgress');
            return progress ? JSON.parse(progress) : null;
        }

        // Function to get the current prison
        function getCurrentPrison(progress) {
            return progress.currentPrison;
        }

        // Function to set the current prison
        function setCurrentPrison(progress, prisonName) {
            if (prisons.includes(prisonName)) {
                progress.currentPrison = prisonName;
                saveCampaignProgress(progress);
            } else {
                console.error(`Prison ${prisonName} not found.`);
            }
        }

        // Function to mark a prison as completed and unlock the next one
        function completePrison(progress, prisonName) {
            const prisonIndex = progress.prisons.findIndex(p => p.name === prisonName);
            if (prisonIndex !== -1) {
                progress.prisons[prisonIndex].completed = true;
                if (prisonIndex + 1 < progress.prisons.length) {
                    progress.prisons[prisonIndex + 1].unlocked = true;
                }
                saveCampaignProgress(progress);
            }
        }

        // --- Utility Functions ---
        function getSpiralPathClockwise() {
            let path = [];
            let top = 0, bottom = 7, left = 0, right = 7;
            while (top <= bottom && left <= right) {
                for (let col = left; col <= right; col++) path.push([top, col]);
                top++;
                for (let row = top; row <= bottom; row++) path.push([row, right]);
                right--;
                if (top <= bottom) {
                    for (let col = right; col >= left; col--) path.push([bottom, col]);
                    bottom--;
                }
                if (left <= right) {
                    for (let row = bottom; row >= top; row--) path.push([row, left]);
                    left++;
                }
            }
            return path;
        }

        function getSpiralPathCounterclockwise() {
            let path = [];
            let top = 0, bottom = 7, left = 0, right = 7;
            while (top <= bottom && left <= right) {
                for (let row = top; row <= bottom; row++) path.push([row, right]);
                right--;
                for (let col = right; col >= left; col--) path.push([bottom, col]);
                bottom--;
                if (left <= right) {
                    for (let row = bottom; row >= top; row--) path.push([row, left]);
                    left++;
                }
                if (top <= bottom) {
                    for (let col = left; col <= right; col++) path.push([top, col]);
                    top++;
                }
            }
            return path;
        }

        function generateAdBoard() {
            const themeKeys = Object.keys(themes);
            const randomThemeKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];
            const theme = themes[randomThemeKey];
            const patterns = [
                'horizontal-forward', 'horizontal-backward', 'diagonal', 'reverse-diagonal',
                'diagonal-backward', 'reverse-diagonal-backward', 'vertical-forward', 'vertical-backward',
                'column-cycling', 'row-cycling', 'random-8', 'spiral',
                'spiral-clockwise', 'spiral-counterclockwise', 'snake-2x4', 'snake-4x2', 'wave',
                'spiral-reverse-clockwise', 'spiral-reverse-counterclockwise', 'snake-2x4-reverse',
                'snake-4x2-reverse', 'wave-reverse', 'wave-backward'
            ];
            const currentPattern = patterns[patternIndex];
            // const effects = ['glow']; // Keeping glow as the only working effect
            let positions = [];
            const letters = 'FUGITIVE'.split('');

            if (currentPattern === 'horizontal-forward') {
                const row = horizontalRow;
                for (let col = 0; col < 8; col++) positions.push([row, col]);
                horizontalRow = (horizontalRow + 1) % 8;
            } else if (currentPattern === 'horizontal-backward') {
                const row = horizontalRow;
                for (let col = 7; col >= 0; col--) positions.push([row, col]);
                horizontalRow = (horizontalRow + 1) % 8;
            } else if (currentPattern === 'diagonal') {
                for (let i = 0; i < 8; i++) positions.push([i, i]);
            } else if (currentPattern === 'reverse-diagonal') {
                for (let i = 0; i < 8; i++) positions.push([i, 7 - i]);
            } else if (currentPattern === 'diagonal-backward') {
                for (let i = 7; i >= 0; i--) positions.push([i, i]);
            } else if (currentPattern === 'reverse-diagonal-backward') {
                for (let i = 7; i >= 0; i--) positions.push([i, 7 - i]);
            } else if (currentPattern === 'vertical-forward') {
                const col = verticalCol;
                for (let row = 0; row < 8; row++) positions.push([row, col]);
                verticalCol = (verticalCol + 1) % 8;
            } else if (currentPattern === 'vertical-backward') {
                const col = verticalCol;
                for (let row = 7; row >= 0; row--) positions.push([row, col]);
                verticalCol = (verticalCol + 1) % 8;
            } else if (currentPattern === 'column-cycling') {
                for (let i = 0; i < 8; i++) {
                    const col = (columnStart + i) % 8;
                    positions.push([0, col]);
                }
                columnStart = (columnStart + 1) % 8;
            } else if (currentPattern === 'row-cycling') {
                const row = rowCycleIndex;
                for (let col = 0; col < 8; col++) {
                    positions.push([row, col]);
                }
                rowCycleIndex = (rowCycleIndex + 1) % 8;
            } else if (currentPattern === 'random-8') {
                let allPositions = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        allPositions.push([row, col]);
                    }
                }
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }
                positions = allPositions.slice(0, 8);
            } else if (currentPattern === 'spiral') {
                let spiralPath = getSpiralPathClockwise();
                let start = spiralShift % 64;
                positions = [];
                for (let i = 0; i < 8; i++) {
                    positions.push(spiralPath[(start + i) % 64]);
                }
                spiralShift = (spiralShift + 1) % 64;
            } else if (currentPattern === 'spiral-clockwise') {
                let spiralPath = getSpiralPathClockwise();
                let start = spiralClockwiseShift % 64;
                positions = [];
                for (let i = 0; i < 8; i++) {
                    positions.push(spiralPath[(start + i) % 64]);
                }
                spiralClockwiseShift = (spiralClockwiseShift + 1) % 64;
            } else if (currentPattern === 'spiral-counterclockwise') {
                let spiralPath = getSpiralPathCounterclockwise();
                let start = spiralCounterclockwiseShift % 64;
                positions = [];
                for (let i = 0; i < 8; i++) {
                    positions.push(spiralPath[(start + i) % 64]);
                }
                spiralCounterclockwiseShift = (spiralCounterclockwiseShift + 1) % 64;
            } else if (currentPattern === 'snake-2x4') {
                let rowStart = snake2x4RowShift % 7; // 0 to 6 (8-2)
                let colStart = snake2x4ColShift % 5; // 0 to 4 (8-4)
                positions = [
                    [rowStart, colStart], [rowStart, colStart+1], [rowStart, colStart+2], [rowStart, colStart+3],
                    [rowStart+1, colStart+3], [rowStart+1, colStart+2], [rowStart+1, colStart+1], [rowStart+1, colStart]
                ];
                snake2x4ColShift = (snake2x4ColShift + 1) % 5;
                if (snake2x4ColShift === 0) {
                    snake2x4RowShift = (snake2x4RowShift + 1) % 7;
                }
            } else if (currentPattern === 'snake-4x2') {
                let rowStart = snake4x2RowShift % 5; // 0 to 4 (8-4)
                let colStart = snake4x2ColShift % 7; // 0 to 6 (8-2)
                positions = [
                    [rowStart, colStart], [rowStart+1, colStart], [rowStart+2, colStart], [rowStart+3, colStart],
                    [rowStart+3, colStart+1], [rowStart+2, colStart+1], [rowStart+1, colStart+1], [rowStart, colStart+1]
                ];
                snake4x2ColShift = (snake4x2ColShift + 1) % 7;
                if (snake4x2ColShift === 0) {
                    snake4x2RowShift = (snake4x2RowShift + 1) % 5;
                }
            } else if (currentPattern === 'wave') {
                positions = [];
                for (let col = 0; col < 8; col++) {
                    let row = Math.round(3.5 + 3.5 * Math.sin(2 * Math.PI * (col + waveShift) / 8));
                    positions.push([row, col]);
                }
                waveShift = (waveShift + 1) % 8;
            } else if (currentPattern === 'spiral-reverse-clockwise') {
                let spiralPath = getSpiralPathClockwise().reverse();
                let start = spiralReverseClockwiseShift % 64;
                positions = [];
                for (let i = 0; i < 8; i++) {
                    positions.push(spiralPath[(start + i) % 64]);
                }
                spiralReverseClockwiseShift = (spiralReverseClockwiseShift + 1) % 64;
            } else if (currentPattern === 'spiral-reverse-counterclockwise') {
                let spiralPath = getSpiralPathCounterclockwise().reverse();
                let start = spiralReverseCounterclockwiseShift % 64;
                positions = [];
                for (let i = 0; i < 8; i++) {
                    positions.push(spiralPath[(start + i) % 64]);
                }
                spiralReverseCounterclockwiseShift = (spiralReverseCounterclockwiseShift + 1) % 64;
            } else if (currentPattern === 'snake-2x4-reverse') {
                let rowStart = snake2x4RowShift % 7;
                let colStart = snake2x4ColShift % 5;
                positions = [
                    [rowStart, colStart], [rowStart, colStart+1], [rowStart, colStart+2], [rowStart, colStart+3],
                    [rowStart+1, colStart+3], [rowStart+1, colStart+2], [rowStart+1, colStart+1], [rowStart+1, colStart]
                ].reverse();
                snake2x4ColShift = (snake2x4ColShift + 1) % 5;
                if (snake2x4ColShift === 0) {
                    snake2x4RowShift = (snake2x4RowShift + 1) % 7;
                }
            } else if (currentPattern === 'snake-4x2-reverse') {
                let rowStart = snake4x2RowShift % 5;
                let colStart = snake4x2ColShift % 7;
                positions = [
                    [rowStart, colStart], [rowStart+1, colStart], [rowStart+2, colStart], [rowStart+3, colStart],
                    [rowStart+3, colStart+1], [rowStart+2, colStart+1], [rowStart+1, colStart+1], [rowStart, colStart+1]
                ].reverse();
                snake4x2ColShift = (snake4x2ColShift + 1) % 7;
                if (snake4x2ColShift === 0) {
                    snake4x2RowShift = (snake4x2RowShift + 1) % 5;
                }
            } else if (currentPattern === 'wave-reverse') {
                positions = [];
                for (let col = 0; col < 8; col++) {
                    let row = Math.round(3.5 - 3.5 * Math.sin(2 * Math.PI * (col + waveReverseShift) / 8));
                    positions.push([row, col]);
                }
                waveReverseShift = (waveReverseShift + 1) % 8;
            } else if (currentPattern === 'wave-backward') {
                positions = [];
                for (let col = 0; col < 8; col++) {
                    let row = Math.round(3.5 + 3.5 * Math.sin(2 * Math.PI * (col + waveBackwardShift) / 8));
                    positions.push([row, col]);
                }
                waveBackwardShift = (waveBackwardShift - 1 + 8) % 8;
            }

            patternIndex = (patternIndex + 1) % patterns.length;
            const board = document.getElementById('ad-board-container');
            board.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'square';
                    const isLight = (row + col) % 2 === 0;
                    cell.style.backgroundColor = isLight ? theme.light : theme.dark;
                    const letterIndex = positions.findIndex(p => p[0] === row && p[1] === col);
                    if (letterIndex !== -1) {
                        const span = document.createElement('span');
                        span.className = 'text glow fade-in';
                        span.textContent = letters[letterIndex];
                        span.style.color = theme.text;
                        span.style.animationDelay = `${letterIndex * 0.1}s`;
                        cell.appendChild(span);
                    }
                    board.appendChild(cell);
                }
            }
        }

        document.getElementById('ad-board-container').addEventListener('click', () => {
            patternIndex = (patternIndex + 1) % patterns.length;
            generateAdBoard();
            if (!state.music.isMuted && state.music.sfxVolume > 0) {
                sounds.click.volume = state.music.sfxVolume;
                sounds.click.play();
            }
            const board = document.getElementById('ad-board-container');
            board.classList.add('pulse-highlight');
            setTimeout(() => board.classList.remove('pulse-highlight'), 500);
            board.style.transition = 'background-color 0.5s ease';
            board.style.backgroundColor = themes[state.theme].bg;
            setTimeout(() => {
                board.style.backgroundColor = '';
                board.style.transition = '';
            }, 500);
        });

        function getDirtySquares() {
            const dirty = new Set();

            if (previousState.king && (previousState.king[0] !== state.king[0] || previousState.king[1] !== state.king[1])) {
                dirty.add(`${previousState.king[0]},${previousState.king[1]}`);
                dirty.add(`${state.king[0]},${state.king[1]}`);
            }

            if (previousState.jail && (previousState.jail[0] !== state.jail[0] || previousState.jail[1] !== state.jail[1])) {
                dirty.add(`${previousState.jail[0]},${previousState.jail[1]}`);
                dirty.add(`${state.jail[0]},${state.jail[1]}`);
            }

            if (previousState.escape && (previousState.escape[0] !== state.escape[0] || previousState.escape[1] !== state.escape[1])) {
                dirty.add(`${previousState.escape[0]},${previousState.escape[1]}`);
                dirty.add(`${state.escape[0]},${state.escape[1]}`);
            }

            const previousOpponents = new Map(previousState.opponents.map(op => [`${op.pos[0]},${op.pos[1]}`, op]));
            const currentOpponents = new Map(state.opponents.map(op => [`${op.pos[0]},${op.pos[1]}`, op]));
            previousState.opponents.forEach(op => {
                const key = `${op.pos[0]},${op.pos[1]}`;
                if (!currentOpponents.has(key)) {
                    dirty.add(key);
                }
            });
            state.opponents.forEach(op => {
                const key = `${op.pos[0]},${op.pos[1]}`;
                if (!previousOpponents.has(key) || previousOpponents.get(key).type !== op.type) {
                    dirty.add(key);
                }
            });

            const previousTreasures = new Set(previousState.treasures.map(t => `${t.pos[0]},${t.pos[1]}`));
            const currentTreasures = new Set(state.treasures.map(t => `${t.pos[0]},${t.pos[1]}`));
            previousTreasures.forEach(key => {
                if (!currentTreasures.has(key)) dirty.add(key);
            });
            currentTreasures.forEach(key => {
                if (!previousTreasures.has(key)) dirty.add(key);
            });
            const previousPointItems = new Set(previousState.pointItems.map(item => `${item.pos[0]},${item.pos[1]}`));
            const currentPointItems = new Set(state.pointItems.map(item => `${item.pos[0]},${item.pos[1]}`));
            previousPointItems.forEach(key => {
                if (!currentPointItems.has(key)) dirty.add(key);
            });
            currentPointItems.forEach(key => {
                if (!previousPointItems.has(key)) dirty.add(key);
            });

            const previousValidMovesSet = new Set(previousState.validMoves.map(m => `${m[0]},${m[1]}`));
            const currentValidMoves = state.phase === 'moving' ? getValidMoves() : [];
            const currentValidMovesSet = new Set(currentValidMoves.map(m => `${m[0]},${m[1]}`));
            previousValidMovesSet.forEach(key => {
                if (!currentValidMovesSet.has(key)) dirty.add(key);
            });
            currentValidMovesSet.forEach(key => {
                if (!previousValidMovesSet.has(key)) dirty.add(key);
            });

            const previousTutorialHighlightsSet = new Set(previousState.tutorialHighlights.map(h => `${h[0]},${h[1]}`));
            const currentTutorialHighlights = state.mode === 'tutorial' && tutorialSteps[tutorialStep]?.highlight || [];
            const currentTutorialHighlightsSet = new Set(currentTutorialHighlights.map(h => `${h[0]},${h[1]}`));
            previousTutorialHighlightsSet.forEach(key => {
                if (!currentTutorialHighlightsSet.has(key)) dirty.add(key);
            });
            currentTutorialHighlightsSet.forEach(key => {
                if (!previousTutorialHighlightsSet.has(key)) dirty.add(key);
            });

            const previousGuardVisionSet = new Set(previousState.guardVision.map(v => `${v[0]},${v[1]}`));
            const currentGuardVision = window.hoveredGuard ? getGuardVision(window.hoveredGuard) : [];
            const currentGuardVisionSet = new Set(currentGuardVision.map(v => `${v[0]},${v[1]}`));
            previousGuardVisionSet.forEach(key => {
                if (!currentGuardVisionSet.has(key)) dirty.add(key);
            });
            currentGuardVisionSet.forEach(key => {
                if (!previousGuardVisionSet.has(key)) dirty.add(key);
            });

            if (state.hintEnabled === 'on') {
                const previousHintSet = new Set(previousState.hintPath.map(h => `${h[0]},${h[1]}`));
                const currentHintPath = showMoveHints();
                const currentHintSet = new Set(currentHintPath.map(h => `${h[0]},${h[1]}`));
                previousHintSet.forEach(key => {
                    if (!currentHintSet.has(key)) dirty.add(key);
                });
                currentHintSet.forEach(key => {
                    if (!previousHintSet.has(key)) dirty.add(key);
                });
            }

            if (state.fogVision === 'on' && previousState.king && (previousState.king[0] !== state.king[0] || previousState.king[1] !== state.king[1])) {
                for (let row = 0; row < BOARD; row++) {
                    for (let col = 0; col < BOARD; col++) {
                        dirty.add(`${row},${col}`);
                    }
                }
            }

            return dirty;
        }

        function drawSquare(ctx, row, col) {
            const theme = themes[state.theme] || themes.light;
            const pieceStyle = pieceStyles[state.pieceStyle] || pieceStyles.classic;
            const x = col * SQUARE;
            const y = row * SQUARE;
            ctx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;

            if (state.fogVision === 'on' && state.fogDisabledTurns <= 0) {
                const vision = getKingVision();
                const visionSet = new Set(vision.map(([r, c]) => `${r},${c}`));
                if (visionSet.has(`${row},${col}`)) {
                    ctx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;
                } else {
                    ctx.fillStyle = '#808080';
                }
            } else {
                ctx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;
            }
            ctx.fillRect(x, y, SQUARE, SQUARE);

            // Tutorial highlight
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep]?.highlight?.some(h => h[0] === row && h[1] === col)) {
                const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Portals
            if (state.portals === 'on') {
                state.portalsList.forEach((pair, index) => {
                    const colors = ['#800080', '#FFA500', '#0000FF']; // Purple, Orange, Blue
                    const color = colors[index % colors.length];
                    pair.forEach(([pr, pc]) => {
                        if (pr === row && pc === col) {
                            ctx.fillStyle = color; // Fixed 'currentCtx' to 'ctx'
                            ctx.fillRect(x, y, SQUARE, SQUARE);
                        }
                    });
                });
            }

            // Blocked squares
            if (state.blocked.some(b => b[0] === row && b[1] === col)) {
                ctx.fillStyle = '#000';
                ctx.fillRect(x, y, SQUARE, SQUARE);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(x, y, SQUARE, SQUARE);
            }

            // Jail and Escape
            if (state.jail[0] === row && state.jail[1] === col) {
                ctx.fillStyle = '#f00';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }
            if (state.escape[0] === row && state.escape[1] === col) {
                ctx.fillStyle = '#0f0';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Valid moves highlight
            if (state.phase === 'moving' && getValidMoves().some(m => m[0] === row && m[1] === col)) {
                ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Hint square
            if (state.hintSquare && state.hintSquare[0] === row && state.hintSquare[1] === col) {
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; // Cyan for hint, fixed 'currentCtx' to 'ctx'
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Tutorial highlight (repeated in original, kept for consistency)
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep]?.highlight?.some(h => h[0] === row && h[1] === col)) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Guard vision
            if (state.revealGuardVision && state.opponents.some(op => getGuardVision(op).some(v => v[0] === row && v[1] === col))) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            } else if (window.hoveredGuard && getGuardVision(window.hoveredGuard).some(v => v[0] === row && v[1] === col)) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Move hints
            if (state.phase === 'moving' && showMoveHints().some(h => h[0] === row && h[1] === col)) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Invalid move
            if (state.invalidSquare && state.invalidSquare[0] === row && state.invalidSquare[1] === col) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }

            // Treasures
            state.treasures.forEach(t => {
                if (t.pos[0] === row && t.pos[1] === col && (state.hiddenItems === 'off' || state.hiddenItemsOverride)) {
                    ctx.font = `24px ${theme.font}`;
                    ctx.fillStyle = '#FFD700';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(treasures[t.type].symbol, x + SQUARE / 2, y + SQUARE / 2);
                }
            });

            // Point items
            state.pointItems.forEach(item => {
                if (item.pos[0] === row && item.pos[1] === col && (state.hiddenItems === 'off' || state.hiddenItemsOverride)) {
                    ctx.font = `24px ${theme.font}`;
                    ctx.fillStyle = '#FFD700';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.type, x + SQUARE / 2, y + SQUARE / 2);
                }
            });

            // Opponents (guards)
            state.opponents.forEach(op => {
                if (op.pos[0] === row && op.pos[1] === col) {
                    ctx.font = `28px ${theme.font}`;
                    if (state.pieceStyle === 'minimalist') ctx.font = `24px ${theme.font}`;
                    ctx.fillStyle = theme.btn;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const symbol = pieceStyle[op.type] || pieceStyle.pawn;
                    ctx.fillText(symbol, x + SQUARE / 2, y + SQUARE / 2);
                    if (state.guardsEnabled === 'on' && !state.invincible && !state.isStealth && !state.invisible && !op.peaceful) {
                        const vision = getGuardVision(op);
                        if (vision.some(([vr, vc]) => vr === state.king[0] && vc === state.king[1])) {
                            const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                            ctx.beginPath();
                            ctx.arc(x + SQUARE / 2, y + SQUARE / 2, SQUARE / 2 * pulse, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.5 * pulse})`;
                            ctx.fill();
                        }
                    }
                }
            });

            // Player (king or hero)
            if (state.king[0] === row && state.king[1] === col) {
                ctx.font = `36px ${theme.font}`;
                if (state.pieceStyle === 'minimalist') ctx.font = `30px ${theme.font}`;
                ctx.fillStyle = theme.dark;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const symbol = state.hero ? heroes[state.hero].emoji : pieceStyle.king;
                ctx.fillText(symbol, x + SQUARE / 2, y + SQUARE / 2);
            }

            // Highlight square
            if (state.highlightSquare && state.highlightSquare[0] === row && state.highlightSquare[1] === col) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)'; // Gold highlight
                ctx.fillRect(x, y, SQUARE, SQUARE);
            }
        }

        function hasPathToEscape() {
            const visited = new Set();
            const queue = [[state.king[0], state.king[1]]];
            visited.add(`${state.king[0]},${state.king[1]}`);

            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];

            while (queue.length > 0) {
                const [row, col] = queue.shift();
                if (row === state.escape[0] && col === state.escape[1]) return true;

                for (const [dr, dc] of directions) {
                    const r = row + dr;
                    const c = col + dc;
                    const key = `${r},${c}`;
                    if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                        !visited.has(key) &&
                        !state.blocked.some(b => b[0] === r && b[1] === c) &&
                        (state.kingDisarmed === 'off' || !state.opponents.some(op => op.pos[0] === r && op.pos[1] === c))) {
                        visited.add(key);
                        queue.push([r, c]);
                    }
                }

                if (state.portals !== 'off') {
                    const linked = getLinkedPortal([row, col]);
                    if (linked) {
                        const linkedKey = `${linked[0]},${linked[1]}`;
                        if (!visited.has(linkedKey) && !state.blocked.some(b => b[0] === linked[0] && b[1] === linked[1])) {
                            visited.add(linkedKey);
                            queue.push(linked);
                        }
                    }
                }
            }
            return false;
        }

        function hasPathToEscapeCreative() {
            if (!creativeState.king || !creativeState.escape) return false;
            const visited = new Set();
            const queue = [[creativeState.king[0], creativeState.king[1]]];
            visited.add(`${creativeState.king[0]},${creativeState.king[1]}`);

            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];

            while (queue.length > 0) {
                const [row, col] = queue.shift();
                if (row === creativeState.escape[0] && col === creativeState.escape[1]) return true;

                for (const [dr, dc] of directions) {
                    const r = row + dr;
                    const c = col + dc;
                    const key = `${r},${c}`;
                    if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                        !visited.has(key) &&
                        !creativeState.blocked.some(b => b[0] === r && b[1] === c) &&
                        !creativeState.opponents.some(op => op.pos[0] === r && op.pos[1] === c)) {
                        visited.add(key);
                        queue.push([r, c]);
                    }
                }

                creativeState.portalsList.forEach(pair => {
                    if (pair.length === 2) {
                        if (pair[0][0] === row && pair[0][1] === col) {
                            const linked = pair[1];
                            const linkedKey = `${linked[0]},${linked[1]}`;
                            if (!visited.has(linkedKey) && !creativeState.blocked.some(b => b[0] === linked[0] && b[1] === linked[1])) {
                                visited.add(linkedKey);
                                queue.push(linked);
                            }
                        } else if (pair[1][0] === row && pair[1][1] === col) {
                            const linked = pair[0];
                            const linkedKey = `${linked[0]},${linked[1]}`;
                            if (!visited.has(linkedKey) && !creativeState.blocked.some(b => b[0] === linked[0] && b[1] === linked[1])) {
                                visited.add(linkedKey);
                                queue.push(linked);
                            }
                        }
                    }
                });
            }
            return false;
        }

        function getSongDisplayName(track) {
            return track.name;
        }

        function manhattanDistance(pos1, pos2) {
            return Math.abs(pos1[0] - pos2[0]) + Math.abs(pos1[1] - pos2[1]);
        }

        function getGuardMoves(guard) {
            const [row, col] = guard.pos;
            const moves = [];
            const kingPos = state.king;

            switch (guard.type) {
                case 'pawn':
                    const pawnRowDir = kingPos[0] > row ? 1 : -1;
                    const pawnColDir = kingPos[1] > col ? 1 : -1;
                    const pawnR = row + pawnRowDir;
                    const pawnC = col + pawnColDir;
                    if (pawnR >= 0 && pawnR < BOARD && pawnC >= 0 && pawnC < BOARD &&
                        !state.blocked.some(b => b[0] === pawnR && b[1] === pawnC) &&
                        !(state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === pawnR && w[1] === pawnC)) &&
                        !(state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === pawnR && w[1] === pawnC)) &&
                        !state.opponents.some(op => op.pos[0] === pawnR && op.pos[1] === pawnC && op !== guard)) {
                        moves.push([pawnR, pawnC]);
                    }
                    break;
                case 'rook':
                    const colDir = kingPos[1] > col ? 1 : -1;
                    for (let c = col + colDir; c >= 0 && c < BOARD; c += colDir) {
                        if (state.blocked.some(b => b[0] === row && b[1] === c) || 
                            (state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === row && w[1] === c)) ||
                            (state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === row && w[1] === c)) || 
                            state.opponents.some(op => op.pos[0] === row && op.pos[1] === c && op !== guard)) break;
                        moves.push([row, c]);
                        if (c === kingPos[1]) break;
                    }
                    const rowDir = kingPos[0] > row ? 1 : -1;
                    for (let r = row + rowDir; r >= 0 && r < BOARD; r += rowDir) {
                        if (state.blocked.some(b => b[0] === r && b[1] === col) || 
                            (state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === r && w[1] === col)) ||
                            (state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === r && w[1] === col)) || 
                            state.opponents.some(op => op.pos[0] === r && op.pos[1] === col && op !== guard)) break;
                        moves.push([r, col]);
                        if (r === kingPos[0]) break;
                    }
                    break;
                case 'bishop':
                    const bishopRowDir = kingPos[0] > row ? 1 : -1;
                    const bishopColDir = kingPos[1] > col ? 1 : -1;
                    let r = row + bishopRowDir;
                    let c = col + bishopColDir;
                    while (r >= 0 && r < BOARD && c >= 0 && c < BOARD) {
                        if (state.blocked.some(b => b[0] === r && b[1] === c) || 
                            (state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === r && w[1] === c)) ||
                            (state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === r && w[1] === c)) || 
                            state.opponents.some(op => op.pos[0] === r && op.pos[1] === c && op !== guard)) break;
                        moves.push([r, c]);
                        if (r === kingPos[0] && c === kingPos[1]) break;
                        r += bishopRowDir;
                        c += bishopColDir;
                    }
                    break;
                case 'queen':
                    getGuardMoves({ type: 'rook', pos: [row, col], vision: guard.vision }).forEach(m => moves.push(m));
                    getGuardMoves({ type: 'bishop', pos: [row, col], vision: guard.vision }).forEach(m => moves.push(m));
                    break;
                case 'knight':
                    const knightDirs = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightDirs.forEach(([dr, dc]) => {
                        const r = row + dr;
                        const c = col + dc;
                        if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                            !state.blocked.some(b => b[0] === r && b[1] === c) &&
                            !(state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === r && w[1] === c)) &&
                            !(state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === r && w[1] === c)) &&
                            !state.opponents.some(op => op.pos[0] === r && op.pos[1] === c && op !== guard)) {
                            moves.push([r, c]);
                        }
                    });
                    break;
                case 'sentry':
                    return [];
            }
            if (guard.type !== 'knight') {
                const currentDist = manhattanDistance([row, col], kingPos);
                moves.sort((a, b) => manhattanDistance(a, kingPos) - manhattanDistance(b, kingPos));
            }
            moves.sort((a, b) => {
                const aSeesKing = isKingInVisionAfterMove(guard, a);
                const bSeesKing = isKingInVisionAfterMove(guard, b);
                if (aSeesKing && !bSeesKing) return -1;
                if (!aSeesKing && bSeesKing) return 1;
                return manhattanDistance(a, state.king) - manhattanDistance(b, state.king);
            });
            return moves;
        }

        function isKingInVisionAfterMove(guard, newPos) {
            const tempGuard = { ...guard, pos: newPos };
            const vision = getGuardVision(tempGuard);
            return vision.some(([r, c]) => r === state.king[0] && c === state.king[1]);
        }

        function shuffleAvailableSquares() {
            availableSquares = [];
            for (let row = 0; row < BOARD; row++) {
                for (let col = 0; col < BOARD; col++) {
                    availableSquares.push([row, col]);
                }
            }
            // Fisher-Yates shuffle
            for (let i = availableSquares.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [availableSquares[i], availableSquares[j]] = [availableSquares[j], availableSquares[i]];
            }
            availableIndex = 0;
        }

        function getRandomSquare(occupied, exclude = []) {
            if (availableIndex >= availableSquares.length) {
                shuffleAvailableSquares();
            }
            while (availableIndex < availableSquares.length) {
                const pos = availableSquares[availableIndex];
                availableIndex++;
                if (!occupied.some(p => p[0] === pos[0] && p[1] === pos[1]) &&
                    !exclude.some(p => p[0] === pos[0] && p[1] === pos[1])) {
                    return pos;
                }
            }
            console.warn('No available squares for placement.');
            return null;
        }

        function placeTreasures(occupied) {
            if (state.treasureDrops === 'on') {
                const treasureKeys = Object.keys(treasures);
                const rateMap = { low: 1, medium: 3, high: 5 };
                const count = rateMap[state.treasureSpawnRate] || 3;
                for (let i = 0; i < count; i++) {
                    const treasureType = treasureKeys[Math.floor(Math.random() * treasureKeys.length)];
                    const pos = getRandomSquare(occupied) || [0, 0];
                    state.treasures.push({ type: treasureType, pos });
                    occupied.push(pos);
                }
            }
        }

        function getLinkedPortal(pos) {
            for (const pair of state.portalsList) {
                if (pair[0][0] === pos[0] && pair[0][1] === pos[1]) return pair[1];
                else if (pair[1][0] === pos[0] && pair[1][1] === pos[1]) return pair[0];
            }
            return null;
        }

        function isSquareOccupied(row, col, modeState = state) {
            if (modeState === state || modeState.mode === 'tutorial') {
                return (
                    state.blocked.some(b => b[0] === row && b[1] === col) ||
                    state.opponents.some(op => op.pos[0] === row && op.pos[1] === col) ||
                    state.treasures.some(t => t.pos[0] === row && t.pos[1] === col) ||
                    (state.king && state.king[0] === row && state.king[1] === col) ||
                    (state.jail[0] === row && state.jail[1] === col) ||
                    (state.escape[0] === row && state.escape[1] === col) ||
                    state.portalsList.some(pair => pair.some(p => p[0] === row && p[1] === col))
                );
            } else if (modeState === creativeState) {
                return (
                    (creativeState.king && creativeState.king[0] === row && creativeState.king[1] === col) ||
                    (creativeState.jail && creativeState.jail[0] === row && creativeState.jail[1] === col) ||
                    (creativeState.escape && creativeState.escape[0] === row && creativeState.escape[1] === col) ||
                    creativeState.opponents.some(op => op.pos[0] === row && op.pos[1] === col) ||
                    creativeState.blocked.some(b => b[0] === row && b[1] === col) ||
                    creativeState.treasures.some(t => t.pos[0] === row && t.pos[1] === col) ||
                    creativeState.portalsList.some(pair => pair.some(p => p[0] === row && p[1] === col))
                );
            }
            return false;
        }

        // --- Initialization Functions ---
        function validateState() {
            let isValid = true;
            if (!state.king || !Array.isArray(state.king) || state.king.length !== 2) {
                console.warn('Invalid king state, resetting to jail or default:', state.king);
                state.king = state.jail && Array.isArray(state.jail) && state.jail.length === 2 ? [...state.jail] : [0, 0];
                isValid = false;
            }
            if (!state.jail || !Array.isArray(state.jail) || state.jail.length !== 2) {
                console.warn('Invalid jail state, resetting:', state.jail);
                state.jail = [0, 0];
                isValid = false;
            }
            if (!state.escape || !Array.isArray(state.escape) || state.escape.length !== 2) {
                console.warn('Invalid escape state, resetting:', state.escape);
                state.escape = [7, 7];
                isValid = false;
            }
            return isValid;
        }

        document.getElementById('btn-standard-undo').addEventListener('click', () => {
            if (standardState.moveHistory.length > 0) {
                const lastState = standardState.moveHistory.pop();
                standardState.board = lastState.board;
                standardState.turn = lastState.turn;
                standardState.castling = lastState.castling;
                standardState.enPassant = lastState.enPassant;
                drawStandardBoard();
                updateStandardInfo();
            }
        });

        function initializeGame() {
            try {
                const savedAchievements = JSON.parse(localStorage.getItem('fugitiveAchievements')) || {};
                achievements.forEach(ach => {
                    if (savedAchievements[ach.id]) ach.achieved = savedAchievements[ach.id];
                });

                const requiredElements = [
                    'board', 'tutorial-board', 'creative-board', 'standard-chess-board',
                    'fugitive-menu', 'game-area', 'custom-prompt', 'start-page'
                ];
                let missingElements = [];
                requiredElements.forEach(id => {
                    if (!document.getElementById(id)) missingElements.push(id);
                });
                if (missingElements.length > 0) {
                    showFallbackMessage(`Missing critical elements: ${missingElements.join(', ')}. Attempting to recover...`);
                    setTimeout(initializeGame, 1000);
                    return;
                }

                const canvas = document.getElementById('board');
                if (!canvas) throw new Error('Main game canvas (#board) not found');
                ctx = canvas.getContext('2d') || createFallbackCanvas('board');

                const tutorialCanvas = document.getElementById('tutorial-board');
                if (!tutorialCanvas) throw new Error('Tutorial canvas (#tutorial-board) not found');
                tutorialCtx = tutorialCanvas.getContext('2d') || createFallbackCanvas('tutorial-board');

                const creativeCanvas = document.getElementById('creative-board');
                if (!creativeCanvas) throw new Error('Creative canvas (#creative-board) not found');
                creativeCtx = creativeCanvas.getContext('2d') || createFallbackCanvas('creative-board');

                const standardCanvas = document.getElementById('standard-chess-board');
                if (!standardCanvas) throw new Error('Standard Chess canvas (#standard-chess-board) not found');
                standardChessCtx = standardCanvas.getContext('2d') || createFallbackCanvas('standard-chess-board');

                state.king = [0, 0];
                state.kingAnimatedPixelCenter = null;

                Object.values(sounds).forEach(sound => {
                    sound.volume = state.music.sfxVolume;
                    sound.preload = 'auto';
                    sound.load();
                    sound.onerror = () => console.error(`Failed to load audio: ${sound.src}`);
                });

                Object.values(sounds).forEach(sound => {
                    sound.volume = state.music.sfxVolume;
                    sound.onerror = () => console.error(`Failed to load audio: ${sound.src}`);
                });

                const customThemes = JSON.parse(localStorage.getItem('fugitiveCustomThemes')) || {};
                Object.keys(customThemes).forEach(key => {
                    themes[`custom:${key}`] = customThemes[key];
                });

                const fugitiveMenu = document.getElementById('fugitive-menu');
                if (!fugitiveMenu) throw new Error('Fugitive menu (#fugitive-menu) not found');

                const gameArea = document.getElementById('game-area');
                if (!gameArea) throw new Error('Game area (#game-area) not found');

                state.music.audio.volume = 0.5;
                state.music.audio.addEventListener('ended', () => {
                    if (state.music.isRepeating) {
                        playMusic();
                    } else {
                        skipTrack();
                    }
                });
                state.music.audio.onerror = () => {
                    state.music.hasErrored = true;
                    console.error('Audio error:', state.music.audio.error);
                    skipTrack();
                };
                state.music.audio.oncanplay = () => {
                    if (!state.music.hasErrored && state.music.isPlaying) state.music.audio.play().catch(console.error);
                };

                state.music.currentTrack = 0;
                document.getElementById('song-select').value = "0";
                document.getElementById('btn-pause').textContent = 'Play';
                document.getElementById('track-info').textContent = `Selected: ${getSongDisplayName(state.music.playlist[state.music.currentTrack])}`;

                standardState.moveHistory = [];
                initLevelDropdown();
                initDifficultyDropdown();
                initThemeDropdown();
                initPieceStyleDropdown();
                initHeroDropdown();
                initSongSelect();
                loadMusicSettings();
                populateSongList();
                addTooltips();
                initButtons();
                initCanvasEvents();
                addTreasureTooltips();
                initStandardDropdowns();
                initStandardButtons();
                initStandardCanvasEvents();
                initKeyboardNavigation();

                const savedSettings = JSON.parse(localStorage.getItem('fugitiveSettings')) || {};
                if (savedSettings.difficulty) document.getElementById('difficulty').value = savedSettings.difficulty;
                if (savedSettings.level) document.getElementById('level').value = savedSettings.level;
                if (savedSettings.theme) document.getElementById('theme').value = savedSettings.theme;
                if (savedSettings.pieceStyle) document.getElementById('piece-style').value = savedSettings.pieceStyle;
                if (savedSettings.turnTimer) document.getElementById('turn-timer').value = savedSettings.turnTimer;
                if (savedSettings.turnLimit) document.getElementById('turn-limit').value = savedSettings.turnLimit;
                if (savedSettings.kingDisarmed) document.getElementById('king-disarmed').value = savedSettings.kingDisarmed;
                if (savedSettings.guardsEnabled) document.getElementById('guards').value = savedSettings.guardsEnabled;
                if (savedSettings.treasureDrops) document.getElementById('treasure-drops').value = savedSettings.treasureDrops;
                if (savedSettings.hiddenItems) document.getElementById('hidden-items').value = savedSettings.hiddenItems;
                if (savedSettings.heroAbility) document.getElementById('hero-ability').value = savedSettings.heroAbility;
                if (savedSettings.fogVision) document.getElementById('fog-vision').value = savedSettings.fogVision;
                if (savedSettings.portals) document.getElementById('portals').value = savedSettings.portals.toString();
                if (savedSettings.arcadeMode) document.getElementById('arcade-mode').value = savedSettings.arcadeMode;
                if (savedSettings.hintEnabled) document.getElementById('move-hints').value = savedSettings.hintEnabled;

                applyTheme();
                updateStats();
                updateStatsDisplay();
                updateLeaderboardDisplay();
                requestAnimationFrame(gameLoop);

                document.querySelectorAll('button').forEach(btn => btn.classList.add('button'));

                function startAutosave() {
                    setInterval(autosaveGame, 300000);
                }

                const resetButton = document.getElementById('btn-standard-reset');
                if (resetButton) {
                    resetButton.addEventListener('click', resetStandardChess);
                } else {
                    console.warn('Reset button (#btn-standard-reset) not found');
                }

                const useTreasureBtn = document.createElement('button');
                useTreasureBtn.textContent = 'Use Treasure';
                useTreasureBtn.id = 'btn-use-treasure';
                useTreasureBtn.onclick = () => showTreasureSelection();
                document.getElementById('game-area').appendChild(useTreasureBtn);

                fugitiveMenu.addEventListener('click', startMusicOnInteraction);
                const selects = fugitiveMenu.querySelectorAll('select');
                selects.forEach(select => select.addEventListener('change', startMusicOnInteraction));

                showStartPage();

                document.getElementById('music-volume').addEventListener('input', (e) => {
                    state.music.audio.volume = parseFloat(e.target.value);
                });

                document.getElementById('sfx-volume').addEventListener('input', (e) => {
                    state.music.sfxVolume = parseFloat(e.target.value);
                    Object.values(sounds).forEach(sound => {
                        sound.volume = state.music.sfxVolume;
                    });
                });

                const songSelect = document.getElementById('footer-song-select');
                state.music.playlist.forEach((track, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = getSongDisplayName(track);
                    songSelect.appendChild(option);
                });
                songSelect.addEventListener('change', (e) => {
                    const index = parseInt(e.target.value, 10);
                    if (!isNaN(index)) {
                        state.music.currentTrack = index;
                        if (state.music.isPlaying) playMusic();
                        else document.getElementById('track-info').textContent = `Selected: ${getSongDisplayName(state.music.playlist[state.music.currentTrack])}`;
                    }
                });

                document.getElementById('btn-mute-music').addEventListener('click', () => {
                  const slider = document.getElementById('music-volume');
                  const muted = slider.value > 0;
                  slider.value = muted ? 0 : 1;
                  state.music.audio.volume = parseFloat(slider.value);
                });

                document.getElementById('btn-mute-sfx').addEventListener('click', () => {
                  const slider = document.getElementById('sfx-volume');
                  const muted = slider.value > 0;
                  slider.value = muted ? 0 : 1;
                  state.music.sfxVolume = parseFloat(slider.value);
                  Object.values(sounds).forEach(s => s.volume = state.music.sfxVolume);
                });
                document.getElementById('play-order').addEventListener('change', (e) => {
                    state.music.playOrder = e.target.value;
                    generateCurrentPlaylist();
                    saveMusicSettings();
                });

                document.getElementById('btn-save').addEventListener('click', () => {
                    saveGame();
                    showMessage("Game saved!");
                });

                document.getElementById('btn-options-help').addEventListener('click', () => {
                    document.getElementById('options-help-modal').style.display = 'block';
                });
                document.getElementById('btn-close-options-help').addEventListener('click', () => {
                    document.getElementById('options-help-modal').style.display = 'none';
                });

            } catch (error) {
                console.error('Initialization failed:', error);
                showFallbackMessage(`Game failed to load: ${error.message}. Please refresh the page.`);
            }
            document.addEventListener('click', function startMusic() {
                startMusicOnInteraction();
                document.removeEventListener('click', startMusic);
            }, { once: true });
        }

        function createFallbackCanvas(id) {
            const canvas = document.createElement('canvas');
            canvas.id = id;
            canvas.width = 400;
            canvas.height = 400;
            document.body.appendChild(canvas);
            return canvas.getContext('2d');
        }

        function showFallbackMessage(message) {
            const div = document.createElement('div');
            div.style.position = 'fixed';
            div.style.top = '20px';
            div.style.left = '50%';
            div.style.transform = 'translateX(-50%)';
            div.style.background = 'rgba(255, 0, 0, 0.9)';
            div.style.color = '#fff';
            div.style.padding = '10px 20px';
            div.style.borderRadius = '5px';
            div.style.zIndex = '2000';
            div.textContent = message;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 5000);
        }

        function initLevelDropdown() {
            const level = document.getElementById('level');
            if (!level) return;
            level.innerHTML = '';
            for (let i = 1; i <= 100; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Level ${i}`;
                if (i === state.level) option.selected = true;
                level.appendChild(option);
            }
            level.addEventListener('change', (e) => {
                state.level = parseInt(e.target.value, 10) || 1;
                state.level = Math.max(1, Math.min(state.level, 100));
                document.getElementById('level-info').textContent = `Level ${state.level}`;
                updateStats();
                if (document.getElementById('game-area').style.display === 'flex') {
                    initBoard();
                    drawBoard();
                }
            });
            level.value = state.level;
        }

        function initDifficultyDropdown() {
            const difficulty = document.getElementById('difficulty');
            if (!difficulty) return;
            difficulty.value = state.difficulty;
            difficulty.addEventListener('change', (e) => {
                state.difficulty = e.target.value;
                updateStats();
                if (document.getElementById('game-area').style.display === 'flex') {
                    initBoard();
                    drawBoard();
                }
            });
        }

        function initThemeDropdown() {
            const theme = document.getElementById('theme');
            if (!theme) return;
            theme.innerHTML = '';
            Object.keys(themes).forEach(themeKey => {
                if (themeKey !== 'random') {
                    const option = document.createElement('option');
                    option.value = themeKey;
                    if (themeKey.startsWith('custom:')) {
                        const name = themeKey.slice(7);
                        option.textContent = `${name} (custom)`;
                    } else {
                        option.textContent = themeKey.charAt(0).toUpperCase() + themeKey.slice(1);
                    }
                    theme.appendChild(option);
                }
            });
            const randomOption = document.createElement('option');
            randomOption.value = 'random';
            randomOption.textContent = 'Random';
            theme.appendChild(randomOption);
            theme.value = state.theme;
            theme.addEventListener('change', (e) => {
                const selected = e.target.value;
                if (selected === 'random') {
                    setRandomTheme();
                } else {
                    state.theme = selected;
                    applyTheme();
                    if (document.getElementById('game-area').style.display === 'flex') drawBoard();
                }
            });
        }

        function initPieceStyleDropdown() {
            const pieceStyleSelect = document.getElementById('piece-style');
            if (!pieceStyleSelect) return;

            pieceStyleSelect.innerHTML = '';

            Object.keys(pieceStyles).forEach(style => {
                const option = document.createElement('option');
                option.value = style;
                option.textContent = style
                    .split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                pieceStyleSelect.appendChild(option);
            });

            pieceStyleSelect.value = state.pieceStyle || 'classic';

            pieceStyleSelect.addEventListener('change', (e) => {
                state.pieceStyle = e.target.value;
                if (!pieceStyles[state.pieceStyle]) state.pieceStyle = 'classic';
                if (document.getElementById('game-area').style.display === 'flex') drawBoard();
            });
        }

        function initHeroDropdown() {
            const select = document.getElementById('hero-select');
            select.innerHTML = '<option value="-1">None Selected</option>';
            Object.keys(heroes).forEach((heroKey) => {
                const hero = heroes[heroKey];
                const option = document.createElement('option');
                option.value = heroKey;
                option.textContent = hero.name;
                select.appendChild(option);
            });
            const customOption = document.createElement('option');
            customOption.value = 'create_custom';
            customOption.textContent = 'Create Custom Hero';
            select.appendChild(customOption);
            select.value = state.hero || '-1';
            select.addEventListener('change', (e) => {
                const heroKey = e.target.value;
                if (heroKey === 'create_custom') {
                    createCustomHero();
                } else {
                    state.hero = heroKey !== '-1' ? heroKey : null;
                    if (document.getElementById('game-area').style.display === 'flex') drawBoard();
                }
            });
            document.getElementById('hero-select').addEventListener('change', (e) => {
                const heroKey = e.target.value;
                if (heroKey !== '-1' && heroKey !== 'create_custom') {
                    showTooltip('hero-select', heroes[heroKey].description);
                }
            });
        }

        function initSongSelect() {
            const select = document.getElementById('song-select');
            state.music.playlist.forEach((track, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = getSongDisplayName(track);
                select.appendChild(option);
            });
            select.value = "0";
            select.addEventListener('change', (e) => {
                const index = parseInt(e.target.value, 10);
                if (!isNaN(index)) {
                    state.music.currentTrack = index;
                    if (state.music.isPlaying) playMusic();
                    else document.getElementById('track-info').textContent = `Selected: ${getSongDisplayName(state.music.playlist[state.music.currentTrack])}`;
                }
            });
        }

        function initStandardDropdowns() {
            const themeSelect = document.getElementById('standard-theme');
            if (!themeSelect) {
                console.error('Standard theme select not found');
                return;
            }
            themeSelect.innerHTML = '';
            Object.keys(themes).forEach(themeKey => {
                if (themeKey !== 'random') {
                    const option = document.createElement('option');
                    option.value = themeKey;
                    option.textContent = themeKey.startsWith('custom:') ? `${themeKey.slice(7)} (custom)` : themeKey.charAt(0).toUpperCase() + themeKey.slice(1);
                    themeSelect.appendChild(option);
                }
            });
            const randomOption = document.createElement('option');
            randomOption.value = 'random';
            randomOption.textContent = 'Random';
            themeSelect.appendChild(randomOption);
            themeSelect.value = standardState.theme || 'light';
            themeSelect.addEventListener('change', (e) => {
                const selected = e.target.value;
                if (selected === 'random') setRandomTheme();
                else {
                    standardState.theme = selected;
                    drawStandardBoard();
                    state.forceRedraw = true;
                }
            });

            const whitePieceStyleSelect = document.getElementById('standard-white-piece-style');
            const blackPieceStyleSelect = document.getElementById('standard-black-piece-style');
            if (!whitePieceStyleSelect || !blackPieceStyleSelect) {
                console.error('Piece style selects not found');
                return;
            }
            whitePieceStyleSelect.innerHTML = '';
            blackPieceStyleSelect.innerHTML = '';
            Object.keys(pieceStyles).forEach(style => {
                const optionWhite = document.createElement('option');
                optionWhite.value = style;
                optionWhite.textContent = style.charAt(0).toUpperCase() + style.slice(1);
                whitePieceStyleSelect.appendChild(optionWhite);

                const optionBlack = document.createElement('option');
                optionBlack.value = style;
                optionBlack.textContent = style.charAt(0).toUpperCase() + style.slice(1);
                blackPieceStyleSelect.appendChild(optionBlack);
            });
            whitePieceStyleSelect.value = standardState.whitePieceStyle || 'classic';
            blackPieceStyleSelect.value = standardState.blackPieceStyle || 'classic';

            whitePieceStyleSelect.addEventListener('change', (e) => {
                standardState.whitePieceStyle = e.target.value;
                drawStandardBoard();
                state.forceRedraw = true;
            });

            blackPieceStyleSelect.addEventListener('change', (e) => {
                standardState.blackPieceStyle = e.target.value;
                drawStandardBoard();
                state.forceRedraw = true;
            });

            const songSelect = document.getElementById('standard-song-select');
            state.music.playlist.forEach((track, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = getSongDisplayName(track);
                songSelect.appendChild(option);
            });
            songSelect.addEventListener('change', (e) => {
                const index = parseInt(e.target.value, 10);
                if (!isNaN(index)) {
                    state.music.currentTrack = index;
                    if (state.music.isPlaying) playMusic();
                    else document.getElementById('track-info').textContent = `Selected: ${getSongDisplayName(state.music.playlist[state.music.currentTrack])}`;
                }
            });

            const heroSelect = document.getElementById('standard-hero-select');
            heroSelect.innerHTML = '<option value="-1">None Selected</option>';
            Object.keys(heroes).forEach((heroKey) => {
                const hero = heroes[heroKey];
                const option = document.createElement('option');
                option.value = heroKey;
                option.textContent = hero.name;
                heroSelect.appendChild(option);
            });
            heroSelect.value = standardState.hero || '-1';
            heroSelect.addEventListener('change', (e) => {
                const heroKey = e.target.value;
                standardState.hero = heroKey !== '-1' ? heroKey : null;
                drawStandardBoard();
                state.forceRedraw = true;
            });
        }

        /**
         * Executes the selected hero's ability if conditions are met, updating game state and UI.
         */
        function useHeroAbility() {
            // Check if the ability can be used based on game state
            if (state.heroAbility !== 'on' || !state.hero || state.phase !== 'moving') {
                return; // Exit if ability is disabled, no hero is selected, or not in moving phase
            }

            // Check if the ability is on cooldown
            if (state.heroCooldown > 0) {
                const infoElementId = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                document.getElementById(infoElementId).textContent = `Ability on cooldown! ${state.heroCooldown} turns left.`;
                playSoundIfEnabled(sounds.invalid);
                return;
            }

            // Play the ability sound effect if audio is enabled
            playSoundIfEnabled(sounds.ability);

            // Initialize common variables
            const currentHero = heroes[state.hero];
            const infoElementId = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
            const adjacentSquares = getValidMoves();

            // Execute the ability based on the hero's effect
            switch (currentHero.effect) {
                case 'strength':
                    // Hercules: Defeat guards in adjacent squares
                    state.opponents = state.opponents.filter(opponent =>
                        !adjacentSquares.some(([row, col]) => row === opponent.pos[0] && col === opponent.pos[1])
                    );
                    document.getElementById(infoElementId).textContent = 'Hercules defeated adjacent guards!';
                    playSoundIfEnabled(sounds.capture);
                    animateHeroAbility(state.hero);
                    break;

                case 'magic':
                    // Merlin: Apply a random treasure effect
                    const treasureKeys = Object.keys(treasures);
                    const randomTreasure = treasures[treasureKeys[Math.floor(Math.random() * treasureKeys.length)]];
                    applyTreasureEffect({ type: randomTreasure.effect });
                    state.collectedTreasures.push({ type: randomTreasure.effect, pos: state.king });
                    document.getElementById(infoElementId).textContent = `Merlin cast ${randomTreasure.description}!`;
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'stealth':
                    // Hanzo: Enable stealth movement for this turn
                    state.isStealth = true;
                    document.getElementById(infoElementId).textContent = 'Hanzo moves stealthily this turn!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'duel':
                    // Musashi: Prompt to select a guard to duel
                    if (state.opponents.length === 0) {
                        document.getElementById(infoElementId).textContent = 'No guards to duel!';
                        return;
                    }
                    state.selectingGuard = true;
                    document.getElementById(infoElementId).textContent = 'Click a guard to duel with Musashi!';
                    drawBoard();
                    return;

                case 'charge':
                    // Alexander: Double the player’s moves this turn
                    state.moves *= 2;
                    document.getElementById(infoElementId).textContent = 'Alexander charges with double moves!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'charm':
                    // Cleopatra: Distract all guards
                    state.opponents.forEach(opponent => opponent.distracted = true);
                    document.getElementById(infoElementId).textContent = 'Cleopatra distracts all guards!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'peace':
                    // Siddhartha: Prevent guard attacks for one turn
                    state.opponents.forEach(opponent => opponent.peaceful = true);
                    document.getElementById(infoElementId).textContent = 'Siddhartha brings peace for one turn!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'protection':
                    // Michael: Grant invincibility for one turn
                    state.invincible = true;
                    document.getElementById(infoElementId).textContent = 'Michael grants invincibility this turn!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'wisdom':
                    // Solomon: Reveal the optimal path for one turn
                    state.hintEnabled = 'on';
                    document.getElementById(infoElementId).textContent = 'Solomon reveals the optimal path!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'explore':
                    // Gagarin: Prompt to teleport to any square
                    state.selectingTeleport = true;
                    document.getElementById(infoElementId).textContent = 'Click a square to teleport with Gagarin!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'resurrection':
                    // Jesus: Enable one-time resurrection
                    if (state.hasResurrection) {
                        document.getElementById(infoElementId).textContent = 'Resurrection already active!';
                        return;
                    }
                    state.hasResurrection = true;
                    document.getElementById(infoElementId).textContent = 'Jesus grants one-time resurrection!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'trickery':
                    // Loki: Prompt to swap places with a guard
                    if (state.opponents.length === 0) {
                        document.getElementById(infoElementId).textContent = 'No guards to swap with!';
                        return;
                    }
                    state.selectingGuard = true;
                    state.isSwapping = true;
                    document.getElementById(infoElementId).textContent = 'Click a guard to swap with Loki!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'reveal':
                    // Oracle: Reveal all guard positions
                    state.revealGuardVision = true;
                    document.getElementById(infoElementId).textContent = 'Oracle reveals all guard positions!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'rangedAttack':
                    // Robin Hood/Zeus: Prompt to attack a guard within two squares
                    state.selectingGuard = true;
                    state.isRangedAttack = true;
                    document.getElementById(infoElementId).textContent = 'Click a guard within two squares to attack!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'disableVision':
                    // Shadow: Prompt to disable a guard’s vision
                    if (state.opponents.length === 0) {
                        document.getElementById(infoElementId).textContent = 'No guards to target!';
                        return;
                    }
                    state.selectingGuard = true;
                    document.getElementById(infoElementId).textContent = 'Click a guard to disable its vision!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'timeWarp':
                case 'spell':
                    // Time Wizard/Wizard: Stun all guards for one turn
                    state.opponents.forEach(opponent => opponent.stunned = true);
                    document.getElementById(infoElementId).textContent = `${currentHero.name} stunned all guards for one turn!`;
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'steal':
                    // Thief: Steal a treasure from a nearby guard
                    const nearbyGuard = state.opponents.find(opponent =>
                        Math.abs(opponent.pos[0] - state.king[0]) <= 1 &&
                        Math.abs(opponent.pos[1] - state.king[1]) <= 1
                    );
                    if (nearbyGuard && state.treasures.length > 0) {
                        const stolenTreasure = state.treasures.shift();
                        state.collectedTreasures.push(stolenTreasure);
                        applyTreasureEffect(stolenTreasure);
                        document.getElementById(infoElementId).textContent = 'Thief stole a treasure!';
                        animateHeroAbility(state.hero);
                    } else {
                        document.getElementById(infoElementId).textContent = 'No nearby guard or treasure to steal!';
                        return;
                    }
                    break;

                case 'assassinate':
                    // Assassin: Prompt to eliminate a guard within two squares
                    state.selectingGuard = true;
                    state.isRangedAttack = true; // Reused for range check
                    document.getElementById(infoElementId).textContent = 'Click a guard within two squares to assassinate!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'freeze':
                    // Frost Mage: Freeze all guards for two turns
                    state.opponents.forEach(opponent => opponent.stunned = true);
                    state.freezeTurns = 2;
                    document.getElementById(infoElementId).textContent = 'Frost Mage froze all guards for two turns!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'timeSkip':
                    // Chronomancer: Skip a random guard’s turn
                    if (state.opponents.length > 0) {
                        const guardIndex = Math.floor(Math.random() * state.opponents.length);
                        state.opponents[guardIndex].skipTurn = true;
                        document.getElementById(infoElementId).textContent = 'Chronomancer skipped a guard\'s turn!';
                        animateHeroAbility(state.hero);
                    } else {
                        document.getElementById(infoElementId).textContent = 'No guards to skip!';
                    }
                    break;

                case 'decoy':
                    // Illusionist: Create a decoy to distract guards
                    const decoyPosition = getRandomSquare(state.blocked.concat(state.opponents.map(op => op.pos)));
                    if (decoyPosition) {
                        state.decoyTurns = 3;
                        state.decoyPos = decoyPosition;
                        document.getElementById(infoElementId).textContent = 'Illusionist created a decoy!';
                        animateHeroAbility(state.hero);
                    } else {
                        document.getElementById(infoElementId).textContent = 'No space for a decoy!';
                    }
                    break;

                case 'teleport':
                    // Teleporter: Prompt to teleport with limited uses
                    if (state.heroUses === undefined) state.heroUses = currentHero.uses;
                    if (state.heroUses <= 0) {
                        document.getElementById(infoElementId).textContent = 'No teleport uses left!';
                        playSoundIfEnabled(sounds.invalid);
                        return;
                    }
                    state.selectingTeleport = true;
                    document.getElementById(infoElementId).textContent = 'Click an empty square to teleport!';
                    drawBoard();
                    animateHeroAbility(state.hero);
                    return;

                case 'intangibility':
                    // Phantom: Enable phasing through walls for 3 moves
                    if (state.heroUses === undefined) state.heroUses = currentHero.uses;
                    if (state.heroUses <= 0) {
                        document.getElementById(infoElementId).textContent = 'No intangibility uses left!';
                        playSoundIfEnabled(sounds.invalid);
                        return;
                    }
                    state.canPhase = 3;
                    state.heroUses--;
                    document.getElementById(infoElementId).textContent = 'Phantom becomes intangible for 3 moves!';
                    playSoundIfEnabled(sounds.ability);
                    animateHeroAbility(state.hero);
                    break;

                case 'windwalk':
                    // Zephyr: Ignore blocks for one turn
                    state.windwalkTurns = 1;
                    document.getElementById(infoElementId).textContent = 'Zephyr lets you walk through obstacles!';
                    animateHeroAbility(state.hero);
                    break;

                case 'destroyWalls':
                    // Bomb: Destroy adjacent walls
                    state.blocked = state.blocked.filter(block =>
                        !adjacentSquares.some(([row, col]) => row === block[0] && col === block[1])
                    );
                    document.getElementById(infoElementId).textContent = 'Bomb destroyed adjacent walls!';
                    playSoundIfEnabled(sounds.capture);
                    animateHeroAbility(state.hero);
                    break;

                default:
                    document.getElementById(infoElementId).textContent = 'Ability effect not implemented.';
                    break;
            }

            // Perform post-ability updates
            state.heroCooldown = currentHero.cooldown; // Set cooldown
            state.moves--; // Decrease remaining moves
            if (state.moves <= 0) endPlayerTurn(); // End turn if no moves remain
            updateStats(); // Update game statistics
            drawBoard(); // Redraw the game board
            updateHeroAbilityUI(); // Update ability UI elements
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep].expectedAction === 'useHeroAbility') {
                advanceTutorial(); // Progress tutorial if applicable
            }
        }

        /**
        * Plays a sound if audio is enabled in the game state.
        * @param {Audio} sound - The sound object to play
        */
        function playSoundIfEnabled(sound) {
            if (!state.music.isMuted && state.music.sfxVolume > 0) {
                sound.volume = state.music.sfxVolume;
                sound.play();
            }
        }

        function updateHeroAbilityUI() {
            let heroBtn = document.getElementById('btn-use-hero');
            if (!heroBtn) {
                // Check for hint button first
                const hintBtn = document.getElementById('btn-hint');
                if (!hintBtn) {
                    console.error('Hint button not found in the DOM.');
                    return;
                }

                // Create the hero button
                heroBtn = document.createElement('button');
                heroBtn.id = 'btn-use-hero';
                heroBtn.textContent = 'Use Hero Ability';
                heroBtn.setAttribute('aria-label', 'Use hero ability if available');
                heroBtn.tabIndex = 0;

                // Insert heroBtn before hintBtn using hintBtn's parent
                try {
                    hintBtn.parentNode.insertBefore(heroBtn, hintBtn);
                    heroBtn.addEventListener('click', useHeroAbility);
                } catch (error) {
                    console.error('Failed to insert hero button:', error);
                    return;
                }
            }

            // Update button state based on game logic
            if (state.heroAbility === 'on' && state.hero) {
                const hero = heroes[state.hero];
                heroBtn.style.display = 'inline-block';
                if (state.heroCooldown > 0) {
                    heroBtn.textContent = `Ability (${state.heroCooldown})`;
                    heroBtn.disabled = true;
                    heroBtn.style.background = '#888';
                } else {
                    heroBtn.textContent = `Use ${hero.name}'s Ability`;
                    heroBtn.disabled = false;
                    heroBtn.style.background = themes[state.theme].btn;
                }
            } else {
                heroBtn.style.display = 'none';
            }
        }

        function applyTreasureEffect(treasure) {
            const effect = treasures[treasure.type].effect;
            const duration = treasures[treasure.type].duration || 1;
            const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';

            switch (effect) {
                case 'reroll':
                    state.roll = Math.floor(Math.random() * 6) + 1;
                    state.moves = state.roll;
                    document.getElementById(info).textContent = `Diamond rerolled to ${state.roll}! Use arrow keys or WASD`;
                    break;

                case 'unlock':
                    if (state.blocked.length > 0) {
                        state.blocked.pop();
                        document.getElementById(info).textContent = 'Key unlocked a path!';
                    }
                    break;

                case 'score':
                    state.score += 100;
                    document.getElementById(info).textContent = 'Gold added 100 points!';
                    break;

                case 'invincible':
                    state.invincible = true;
                    state.invincibleTurns = duration;
                    document.getElementById(info).textContent = `Shield granted invincibility for ${duration} turns!`;
                    break;

                case 'attack':
                    const adjacent = getValidMoves();
                    state.opponents = state.opponents.filter(op => !adjacent.some(([r, c]) => r === op.pos[0] && c === op.pos[1]));
                    document.getElementById(info).textContent = 'Sword defeated adjacent guards!';
                    break;

                case 'double-moves':
                    state.doubleMovesTurns = duration;
                    state.moves *= 2;
                    document.getElementById(info).textContent = `Boots grant double moves for ${duration} turns!`;
                    break;

                case 'phase':
                    state.canPhase = 3;
                    document.getElementById(info).textContent = 'Phase Stone allows moving through walls for 3 moves!';
                    break;

                case 'invisibility':
                    state.invisible = true;
                    state.invisibilityTurns = duration;
                    document.getElementById(info).textContent = `Cloak makes you invisible for ${duration} moves!`;
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.ability.volume = state.music.sfxVolume;
                        sounds.ability.play();
                    }
                    break;

                case 'disable-fog':
                    state.fogDisabledTurns = duration;
                    document.getElementById(info).textContent = `Lantern disabled fog vision for ${duration} turns!`;
                    break;

                case 'timeFreeze':
                    state.opponents.forEach(op => op.stunned = true);
                    state.timeFreezeTurns = duration;
                    document.getElementById(info).textContent = `Time Crystal froze guards for ${duration} turns!`;
                    break;

                case 'reflect':
                    state.opponents.forEach(op => op.visionDisrupted = true);
                    document.getElementById(info).textContent = 'Mirror reflects guard vision for one turn!';
                    break;

                case 'shuffle':
                    const occupiedShuffle = [state.king, state.jail, state.escape];
                    state.opponents.forEach(op => occupiedShuffle.push(op.pos));
                    state.treasures.forEach(t => occupiedShuffle.push(t.pos));
                    state.opponents.forEach(op => {
                        const newPos = getRandomSquare(occupiedShuffle);
                        if (newPos) {
                            op.pos = newPos;
                            occupiedShuffle.push(newPos);
                        }
                    });
                    document.getElementById(info).textContent = 'Whirlwind shuffled all guards!';
                    break;

                case 'speed':
                    state.moves *= 2;
                    document.getElementById(info).textContent = 'Speed Boost: Moves doubled!';
                    break;

                case 'decoy':
                    state.decoyTurns = 3;
                    state.decoyPos = [...state.king];
                    document.getElementById(info).textContent = 'Decoy deployed for 3 turns!';
                    break;

                case 'breakWall':
                    state.selectingWall = true;
                    document.getElementById(info).textContent = 'Click a blocked square to destroy it!';
                    break;

                case 'reveal':
                    state.revealTurns = 3;
                    document.getElementById(info).textContent = 'Guards revealed for 3 turns!';
                    break;

                case 'reveal-guards':
                    state.revealGuardVisionTurns = duration;
                    document.getElementById(info).textContent = 'Guard vision revealed!';
                    break;

                case 'teleport':
                    const occupiedTeleport = [state.jail, state.escape].concat(state.blocked, state.opponents.map(op => op.pos), state.treasures.map(t => t.pos));
                    const newPos = getRandomSquare(occupiedTeleport);
                    if (newPos) {
                        state.king = newPos;
                        document.getElementById(info).textContent = 'Teleported to a random square!';
                    } else {
                        document.getElementById(info).textContent = 'No space to teleport!';
                    }
                    break;

                case 'restore-moves':
                    state.moves = state.roll;
                    document.getElementById(info).textContent = 'Moves restored!';
                    break;

                case 'reveal-treasures':
                    state.revealTreasuresTurns = duration;
                    document.getElementById(info).textContent = 'All treasures revealed!';
                    break;

                case 'push-guards':
                    state.opponents.forEach(op => {
                        const [px, py] = state.king;
                        const [gx, gy] = op.pos;
                        const dx = Math.sign(gx - px);
                        const dy = Math.sign(gy - py);
                        const newGuardPos = [gx + dx, gy + dy];
                        if (isValidSquare(newGuardPos) && !isBlocked(newGuardPos) && !isOccupied(newGuardPos)) {
                            op.pos = newGuardPos;
                        }
                    });
                    document.getElementById(info).textContent = 'Guards pushed back!';
                    break;

                case 'defeat-guard':
                    if (state.opponents.length > 0) {
                        state.selectingGuardToDefeat = true;
                        document.getElementById(info).textContent = 'Click a guard to defeat!';
                    } else {
                        document.getElementById(info).textContent = 'No guards to defeat!';
                    }
                    break;

                case 'stun-guards':
                    state.opponents.forEach(op => op.stunned = true);
                    state.stunTurns = duration;
                    document.getElementById(info).textContent = 'All guards stunned!';
                    break;

                case 'distract-guards':
                    state.opponents.forEach(op => op.distracted = true);
                    state.distractTurns = duration;
                    document.getElementById(info).textContent = 'Guards distracted!';
                    break;

                case 'ranged-attack':
                    if (state.opponents.length > 0) {
                        state.selectingGuardForRangedAttack = true;
                        document.getElementById(info).textContent = 'Click a guard within range to attack!';
                    } else {
                        document.getElementById(info).textContent = 'No guards to attack!';
                    }
                    break;

                case 'double-score':
                    state.score *= 2;
                    document.getElementById(info).textContent = 'Score doubled!';
                    break;

                case 'fly':
                    state.canFly = true;
                    state.flyTurns = duration;
                    document.getElementById(info).textContent = 'You can fly over walls!';
                    break;

                case 'see-through':
                    state.seeThroughWalls = true;
                    state.seeThroughTurns = duration;
                    document.getElementById(info).textContent = 'You can see through walls!';
                    break;

                case 'disrupt-vision':
                    state.opponents.forEach(op => op.visionDisrupted = true);
                    state.disruptVisionTurns = duration;
                    document.getElementById(info).textContent = 'Guard vision disrupted!';
                    break;

                case 'destroyWalls':
                    const adjacentSquares = getValidMoves();
                    state.blocked = state.blocked.filter(b => !adjacentSquares.some(([r, c]) => r === b[0] && c === b[1]));
                    document.getElementById(info).textContent = 'Adjacent walls destroyed!';
                    break;

                default:
                    document.getElementById(info).textContent = 'Unknown treasure effect.';
                    break;
            }
            updateStats();
            animateTreasureEffect(effect);
        }

        function animateTreasureEffect(effect) {
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            let animationFrame;

            switch (effect) {
                case 'reroll':
                    let rollValue = 1;
                    function animateDice() {
                        currentCtx.save();
                        currentCtx.fillStyle = 'white';
                        currentCtx.fillRect(state.king[1] * SQUARE, state.king[0] * SQUARE, SQUARE, SQUARE);
                        currentCtx.fillStyle = 'black';
                        currentCtx.font = '20px Arial';
                        currentCtx.textAlign = 'center';
                        currentCtx.textBaseline = 'middle';
                        currentCtx.fillText(rollValue, state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.restore();
                        rollValue = (rollValue % 6) + 1;
                        if (rollValue !== state.roll) {
                            animationFrame = requestAnimationFrame(animateDice);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateDice);
                    break;

                case 'unlock':
                    let keyAngle = 0;
                    function animateKey() {
                        currentCtx.save();
                        currentCtx.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.rotate(keyAngle);
                        currentCtx.fillStyle = 'gold';
                        currentCtx.fillRect(-5, -10, 10, 20);
                        currentCtx.restore();
                        keyAngle += Math.PI / 20;
                        if (keyAngle < Math.PI / 2) {
                            animationFrame = requestAnimationFrame(animateKey);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateKey);
                    break;

                case 'score':
                    let coinOffset = 0;
                    function animateCoins() {
                        currentCtx.save();
                        currentCtx.fillStyle = 'yellow';
                        currentCtx.beginPath();
                        currentCtx.arc(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2 - coinOffset, 10, 0, Math.PI * 2);
                        currentCtx.fill();
                        currentCtx.restore();
                        coinOffset += 2;
                        if (coinOffset < SQUARE) {
                            animationFrame = requestAnimationFrame(animateCoins);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateCoins);
                    break;

                case 'invincible':
                    let shieldSize = 0;
                    function animateShield() {
                        currentCtx.save();
                        currentCtx.strokeStyle = 'blue';
                        currentCtx.lineWidth = 2;
                        currentCtx.beginPath();
                        currentCtx.arc(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2, shieldSize, 0, Math.PI * 2);
                        currentCtx.stroke();
                        currentCtx.restore();
                        shieldSize += 1;
                        if (shieldSize < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateShield);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateShield);
                    break;

                case 'attack':
                    let slashProgress = 0;
                    function animateSlash() {
                        currentCtx.save();
                        getValidMoves().forEach(([row, col]) => {
                            currentCtx.translate(col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2);
                            currentCtx.rotate(slashProgress * Math.PI);
                            currentCtx.strokeStyle = 'red';
                            currentCtx.lineWidth = 2;
                            currentCtx.beginPath();
                            currentCtx.moveTo(-SQUARE / 2, 0);
                            currentCtx.lineTo(SQUARE / 2, 0);
                            currentCtx.stroke();
                            currentCtx.resetTransform();
                        });
                        currentCtx.restore();
                        slashProgress += 0.1;
                        if (slashProgress < 1) {
                            animationFrame = requestAnimationFrame(animateSlash);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSlash);
                    break;

                case 'double-moves':
                case 'speed':
                    let scale = 1;
                    function animateBoots() {
                        currentCtx.save();
                        currentCtx.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.scale(scale, scale);
                        currentCtx.font = '20px Arial';
                        currentCtx.fillStyle = 'green';
                        currentCtx.textAlign = 'center';
                        currentCtx.textBaseline = 'middle';
                        currentCtx.fillText('🏃', 0, 0);
                        currentCtx.restore();
                        scale += 0.05;
                        if (scale < 1.5) {
                            animationFrame = requestAnimationFrame(animateBoots);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateBoots);
                    break;

                case 'phase':
                    let opacity = 1;
                    function animatePhase() {
                        currentCtx.save();
                        currentCtx.globalAlpha = opacity;
                        currentCtx.fillStyle = 'purple';
                        currentCtx.fillRect(state.king[1] * SQUARE, state.king[0] * SQUARE, SQUARE, SQUARE);
                        currentCtx.restore();
                        opacity -= 0.05;
                        if (opacity > 0.5) {
                            animationFrame = requestAnimationFrame(animatePhase);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animatePhase);
                    break;

                case 'invisibility':
                    let fade = 1;
                    function animateFade() {
                        currentCtx.save();
                        currentCtx.globalAlpha = fade;
                        currentCtx.fillStyle = 'gray';
                        currentCtx.fillRect(state.king[1] * SQUARE, state.king[0] * SQUARE, SQUARE, SQUARE);
                        currentCtx.restore();
                        fade -= 0.05;
                        if (fade > 0) {
                            animationFrame = requestAnimationFrame(animateFade);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateFade);
                    break;

                case 'disable-fog':
                    let lightRadius = 0;
                    function animateLight() {
                        currentCtx.save();
                        currentCtx.beginPath();
                        currentCtx.arc(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2, lightRadius, 0, Math.PI * 2);
                        currentCtx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                        currentCtx.fill();
                        currentCtx.restore();
                        lightRadius += 2;
                        if (lightRadius < SQUARE * 2) {
                            animationFrame = requestAnimationFrame(animateLight);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateLight);
                    break;

                case 'timeFreeze':
                case 'stun-guards':
                    let freezeProgress = 0;
                    function animateFreeze() {
                        currentCtx.save();
                        state.opponents.forEach(op => {
                            currentCtx.fillStyle = `rgba(0, 0, 255, ${freezeProgress})`;
                            currentCtx.fillRect(op.pos[1] * SQUARE, op.pos[0] * SQUARE, SQUARE, SQUARE);
                        });
                        currentCtx.restore();
                        freezeProgress += 0.05;
                        if (freezeProgress < 0.5) {
                            animationFrame = requestAnimationFrame(animateFreeze);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateFreeze);
                    break;

                case 'reflect':
                case 'disrupt-vision':
                    let mirrorAngle = 0;
                    function animateMirror() {
                        currentCtx.save();
                        state.opponents.forEach(op => {
                            currentCtx.translate(op.pos[1] * SQUARE + SQUARE / 2, op.pos[0] * SQUARE + SQUARE / 2);
                            currentCtx.rotate(mirrorAngle);
                            currentCtx.fillStyle = 'silver';
                            currentCtx.fillRect(-5, -5, 10, 10);
                            currentCtx.resetTransform();
                        });
                        currentCtx.restore();
                        mirrorAngle += Math.PI / 20;
                        if (mirrorAngle < Math.PI) {
                            animationFrame = requestAnimationFrame(animateMirror);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateMirror);
                    break;

                case 'shuffle':
                    let swirlRadius = 0;
                    function animateSwirl() {
                        currentCtx.save();
                        currentCtx.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.rotate(swirlRadius);
                        currentCtx.strokeStyle = 'gray';
                        currentCtx.lineWidth = 2;
                        currentCtx.beginPath();
                        currentCtx.arc(0, 0, swirlRadius, 0, Math.PI * 2);
                        currentCtx.stroke();
                        currentCtx.restore();
                        swirlRadius += 2;
                        if (swirlRadius < SQUARE) {
                            animationFrame = requestAnimationFrame(animateSwirl);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSwirl);
                    break;

                case 'decoy':
                    let decoyScale = 1;
                    function animateDecoy() {
                        currentCtx.save();
                        currentCtx.translate(state.decoyPos[1] * SQUARE + SQUARE / 2, state.decoyPos[0] * SQUARE + SQUARE / 2);
                        currentCtx.scale(decoyScale, decoyScale);
                        currentCtx.fillStyle = 'gray';
                        currentCtx.fillRect(-SQUARE / 4, -SQUARE / 4, SQUARE / 2, SQUARE / 2);
                        currentCtx.restore();
                        decoyScale += 0.05;
                        if (decoyScale < 1.5) {
                            animationFrame = requestAnimationFrame(animateDecoy);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateDecoy);
                    break;

                case 'breakWall':
                case 'destroyWalls':
                    let explosionSize = 0;
                    function animateExplosion() {
                        currentCtx.save();
                        getValidMoves().forEach(([row, col]) => {
                            currentCtx.beginPath();
                            currentCtx.arc(col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2, explosionSize, 0, Math.PI * 2);
                            currentCtx.fillStyle = 'orange';
                            currentCtx.fill();
                        });
                        currentCtx.restore();
                        explosionSize += 2;
                        if (explosionSize < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateExplosion);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateExplosion);
                    break;

                case 'reveal':
                case 'reveal-guards':
                    let revealPulse = 0;
                    function animateReveal() {
                        currentCtx.save();
                        state.opponents.forEach(op => {
                            currentCtx.beginPath();
                            currentCtx.arc(op.pos[1] * SQUARE + SQUARE / 2, op.pos[0] * SQUARE + SQUARE / 2, revealPulse, 0, Math.PI * 2);
                            currentCtx.strokeStyle = 'yellow';
                            currentCtx.lineWidth = 2;
                            currentCtx.stroke();
                        });
                        currentCtx.restore();
                        revealPulse += 2;
                        if (revealPulse < SQUARE) {
                            animationFrame = requestAnimationFrame(animateReveal);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateReveal);
                    break;

                case 'teleport':
                    let portalSize = 0;
                    function animatePortal() {
                        currentCtx.save();
                        currentCtx.beginPath();
                        currentCtx.arc(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2, portalSize, 0, Math.PI * 2);
                        currentCtx.strokeStyle = 'purple';
                        currentCtx.lineWidth = 2;
                        currentCtx.stroke();
                        currentCtx.restore();
                        portalSize += 2;
                        if (portalSize < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animatePortal);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animatePortal);
                    break;

                case 'restore-moves':
                    let textOffset = 0;
                    function animateRestore() {
                        currentCtx.save();
                        currentCtx.font = '20px Arial';
                        currentCtx.fillStyle = 'green';
                        currentCtx.textAlign = 'center';
                        currentCtx.textBaseline = 'middle';
                        currentCtx.fillText('+Moves', state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2 - textOffset);
                        currentCtx.restore();
                        textOffset += 2;
                        if (textOffset < SQUARE) {
                            animationFrame = requestAnimationFrame(animateRestore);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateRestore);
                    break;

                case 'reveal-treasures':
                    let treasurePulse = 0;
                    function animateTreasureReveal() {
                        currentCtx.save();
                        state.treasures.forEach(t => {
                            currentCtx.beginPath();
                            currentCtx.arc(t.pos[1] * SQUARE + SQUARE / 2, t.pos[0] * SQUARE + SQUARE / 2, treasurePulse, 0, Math.PI * 2);
                            currentCtx.strokeStyle = 'gold';
                            currentCtx.lineWidth = 2;
                            currentCtx.stroke();
                        });
                        currentCtx.restore();
                        treasurePulse += 2;
                        if (treasurePulse < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateTreasureReveal);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateTreasureReveal);
                    break;

                case 'push-guards':
                    let pushProgress = 0;
                    function animatePush() {
                        currentCtx.save();
                        state.opponents.forEach(op => {
                            currentCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                            currentCtx.fillRect(op.pos[1] * SQUARE, op.pos[0] * SQUARE, SQUARE * pushProgress, SQUARE * pushProgress);
                        });
                        currentCtx.restore();
                        pushProgress += 0.1;
                        if (pushProgress < 1) {
                            animationFrame = requestAnimationFrame(animatePush);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animatePush);
                    break;

                case 'defeat-guard':
                case 'ranged-attack':
                    let crossSize = 0;
                    function animateCross() {
                        currentCtx.save();
                        currentCtx.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.strokeStyle = 'red';
                        currentCtx.lineWidth = 2;
                        currentCtx.beginPath();
                        currentCtx.moveTo(-crossSize, -crossSize);
                        currentCtx.lineTo(crossSize, crossSize);
                        currentCtx.moveTo(crossSize, -crossSize);
                        currentCtx.lineTo(-crossSize, crossSize);
                        currentCtx.stroke();
                        currentCtx.restore();
                        crossSize += 2;
                        if (crossSize < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateCross);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateCross);
                    break;

                case 'distract-guards':
                    let distractWave = 0;
                    function animateDistract() {
                        currentCtx.save();
                        state.opponents.forEach(op => {
                            currentCtx.beginPath();
                            currentCtx.arc(op.pos[1] * SQUARE + SQUARE / 2, op.pos[0] * SQUARE + SQUARE / 2, distractWave, 0, Math.PI * 2);
                            currentCtx.strokeStyle = 'orange';
                            currentCtx.lineWidth = 2;
                            currentCtx.stroke();
                        });
                        currentCtx.restore();
                        distractWave += 2;
                        if (distractWave < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateDistract);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateDistract);
                    break;

                case 'double-score':
                    let scoreTextOffset = 0;
                    function animateScore() {
                        currentCtx.save();
                        currentCtx.font = '20px Arial';
                        currentCtx.fillStyle = 'gold';
                        currentCtx.textAlign = 'center';
                        currentCtx.textBaseline = 'middle';
                        currentCtx.fillText('x2', state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2 - scoreTextOffset);
                        currentCtx.restore();
                        scoreTextOffset += 2;
                        if (scoreTextOffset < SQUARE) {
                            animationFrame = requestAnimationFrame(animateScore);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateScore);
                    break;

                case 'fly':
                    let wingFlap = 0;
                    function animateWings() {
                        currentCtx.save();
                        currentCtx.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentCtx.fillStyle = 'white';
                        currentCtx.beginPath();
                        currentCtx.moveTo(-wingFlap, 0);
                        currentCtx.lineTo(0, -wingFlap);
                        currentCtx.lineTo(wingFlap, 0);
                        currentCtx.fill();
                        currentCtx.restore();
                        wingFlap += 2;
                        if (wingFlap < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateWings);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateWings);
                    break;

                case 'see-through':
                    let visionPulse = 0;
                    function animateVision() {
                        currentCtx.save();
                        currentCtx.beginPath();
                        currentCtx.arc(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2, visionPulse, 0, Math.PI * 2);
                        currentCtx.strokeStyle = 'cyan';
                        currentCtx.lineWidth = 2;
                        currentCtx.stroke();
                        currentCtx.restore();
                        visionPulse += 2;
                        if (visionPulse < SQUARE * 2) {
                            animationFrame = requestAnimationFrame(animateVision);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateVision);
                    break;

                default:
                    let sparkleParticles = [];
                    for (let i = 0; i < 20; i++) {
                        sparkleParticles.push({
                            x: state.king[1] * SQUARE + SQUARE / 2,
                            y: state.king[0] * SQUARE + SQUARE / 2,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 1
                        });
                    }
                    function animateSparkle() {
                        currentCtx.save();
                        sparkleParticles = sparkleParticles.filter(p => p.life > 0);
                        sparkleParticles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= 0.05;
                            currentCtx.fillStyle = `rgba(255, 255, 0, ${p.life})`;
                            currentCtx.beginPath();
                            currentCtx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                            currentCtx.fill();
                        });
                        currentCtx.restore();
                        if (sparkleParticles.length > 0) {
                            animationFrame = requestAnimationFrame(animateSparkle);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSparkle);
                    break;
            }
        }

        function showTreasureSelection() {
            const modal = document.getElementById('treasure-modal');
            const list = document.getElementById('treasure-list');
            list.innerHTML = '';
            state.collectedTreasures.forEach((treasure, index) => {
                const btn = document.createElement('button');
                btn.textContent = treasure.type;
                btn.onclick = () => {
                    applyTreasureEffect(treasure);
                    state.collectedTreasures.splice(index, 1);
                    modal.style.display = 'none';
                    drawBoard();
                };
                list.appendChild(btn);
            });
            modal.style.display = 'block';
        }

        function updateTreasureInventoryUI() {
            const inventoryDiv = document.getElementById('treasure-inventory');
            if (!inventoryDiv) {
                const gameArea = document.getElementById('game-area');
                const newDiv = document.createElement('div');
                newDiv.id = 'treasure-inventory';
                newDiv.style.margin = '10px 0';
                newDiv.style.display = 'flex';
                newDiv.style.flexWrap = 'wrap';
                newDiv.style.gap = '5px';
                gameArea.insertBefore(newDiv, document.getElementById('btn-roll'));
            }
            inventoryDiv.innerHTML = '<h4>Collected Treasures:</h4>';
            state.collectedTreasures.forEach((treasure, index) => {
                const btn = document.createElement('button');
                btn.textContent = treasures[treasure.type].symbol;
                btn.title = treasures[treasure.type].description;
                btn.setAttribute('aria-label', `Use ${treasure.type} treasure: ${treasures[treasure.type].description}`);
                btn.style.fontSize = '20px';
                btn.style.padding = '5px';
                btn.disabled = state.phase !== 'moving';
                btn.onclick = () => {
                    applyTreasureEffect(treasure);
                    state.collectedTreasures.splice(index, 1);
                    updateTreasureInventoryUI();
                    if (state.moves <= 0) endPlayerTurn();
                    updateStats();
                    drawBoard();
                };
                inventoryDiv.appendChild(btn);
            });
            if (state.collectedTreasures.length === 0) {
                inventoryDiv.innerHTML = '<h4>Collected Treasures: None</h4>';
            }
        }

        function initStandardButtons() {
            const buttons = [
                { id: 'btn-random-theme', fn: setRandomTheme },
                { id: 'btn-mute', fn: toggleMute },
                { id: 'btn-pause', fn: togglePause },
                { id: 'btn-skip', fn: skipTrack },
                { id: 'btn-shuffle', fn: shufflePlaylist },
                { id: 'btn-repeat', fn: toggleRepeat },
                { id: 'btn-save', fn: saveGame },
                { id: 'btn-load', fn: loadGame },
                { id: 'btn-to-standard', fn: () => showSection('standard-chess-section') },
                { id: 'btn-standard-random-theme', fn: setRandomTheme },
                { id: 'btn-standard-play', fn: startStandardChess },
                { id: 'btn-back-to-start-standard', fn: showStartPage }
            ];
            buttons.forEach(({ id, fn }) => {
                const btn = document.getElementById(id);
                if (btn) btn.addEventListener('click', fn);
            });
            document.getElementById('btn-hint').addEventListener('click', showHint);
            document.getElementById('btn-resign').addEventListener('click', () => {
                const winner = standardState.turn === 'white' ? 'Black' : 'White';
                endStandardGame(`${winner} wins by resignation!`);
            });
        }

        function initButtons() {
            const buttons = [
                { id: 'btn-to-fugitive', fn: () => showSection('fugitive-menu') },
                { id: 'btn-to-creative', fn: () => { showSection('creative-mode'); startCreativeMode(); } },
                { id: 'btn-to-tutorial', fn: () => { showSection('tutorial-section'); startTutorial(); } },
                { id: 'btn-to-settings', fn: () => showSection('settings-section') },
                { id: 'btn-to-rules', fn: () => showSection('rules-content') },
                { id: 'btn-random-theme', fn: setRandomTheme },
                { id: 'btn-play', fn: startGame },
                { id: 'btn-random-theme', fn: setRandomTheme },
                { id: 'btn-play', fn: startGame },
                { id: 'btn-random-start', fn: randomStart },
                { id: 'btn-to-tips-strategy', fn: () => showSection('tips-strategy-section') },
                { id: 'btn-back-to-start-tips', fn: showStartPage },
                { id: 'btn-to-store', fn: () => showSection('store-section') },
                { id: 'btn-back-to-start-store', fn: showStartPage },
                { id: 'btn-quick-start', fn: () => {
                    state.difficulty = 'knight';
                    state.level = 1;
                    state.theme = 'light';
                    state.pieceStyle = 'classic';
                    state.hero = null;
                    state.turnTimer = 'off';
                    state.turnLimit = 'none';
                    state.kingDisarmed = 'off';
                    state.guardsEnabled = 'on';
                    state.treasureDrops = 'off';
                    state.hiddenItems = 'off';
                    state.heroAbility = 'off';
                    state.fogVision = 'off';
                    state.portals = 0;
                    state.arcadeMode = 'off';
                    state.hintEnabled = 'off';
                    // Update dropdowns
                    document.getElementById('difficulty').value = 'knight';
                    document.getElementById('level').value = '1';
                    document.getElementById('theme').value = 'light';
                    document.getElementById('piece-style').value = 'classic';
                    document.getElementById('hero-select').value = '-1';
                    document.getElementById('turn-timer').value = 'off';
                    document.getElementById('turn-limit').value = 'none';
                    document.getElementById('king-disarmed').value = 'off';
                    document.getElementById('guards').value = 'on';
                    document.getElementById('treasure-drops').value = 'off';
                    document.getElementById('hidden-items').value = 'off';
                    document.getElementById('hero-ability').value = 'off';
                    document.getElementById('fog-vision').value = 'off';
                    document.getElementById('portals').value = '0';
                    document.getElementById('arcade-mode').value = 'off';
                    document.getElementById('move-hints').value = 'off';
                    document.getElementById('level-info').textContent = 'Level 1';
                    startGame();
                } },
                { id: 'btn-beginner-preset', fn: () => {
                    state.difficulty = 'pawn';
                    state.level = 1;
                    state.turnTimer = 'off';
                    state.turnLimit = 'none';
                    state.kingDisarmed = 'off';
                    state.guardsEnabled = 'on';
                    state.fogVision = 'off';
                    state.treasureDrops = 'off';
                    state.hiddenItems = 'off';
                    state.heroAbility = 'off';
                    state.portals = 0;
                    state.arcadeMode = 'off';
                    state.hintEnabled = 'on';
                    // Update dropdowns to reflect preset
                    document.getElementById('difficulty').value = 'pawn';
                    document.getElementById('level').value = '1';
                    document.getElementById('turn-timer').value = 'off';
                    document.getElementById('turn-limit').value = 'none';
                    document.getElementById('king-disarmed').value = 'off';
                    document.getElementById('guards').value = 'on';
                    document.getElementById('fog-vision').value = 'off';
                    document.getElementById('treasure-drops').value = 'off';
                    document.getElementById('hidden-items').value = 'off';
                    document.getElementById('hero-ability').value = 'off';
                    document.getElementById('portals').value = '0';
                    document.getElementById('arcade-mode').value = 'off';
                    document.getElementById('move-hints').value = 'on';
                    document.getElementById('level-info').textContent = 'Level 1';
                    startGame();
                } },
                { id: 'btn-roll', fn: rollDice },
                { id: 'btn-menu', fn: () => showSection('fugitive-menu') },
                { id: 'btn-toggle-minimap', fn: () => {
                    state.miniMapZoomed = !state.miniMapZoomed;
                    drawMiniMap();
                    document.getElementById('btn-toggle-minimap').textContent = state.miniMapZoomed ? 'Shrink Mini-Map' : 'Enlarge Mini-Map';
                } },
                { id: 'btn-reset', fn: resetLevel },
                { id: 'btn-restart', fn: restartLevel },
                { id: 'btn-replay', fn: replayLevel },
                { id: 'btn-next-level', fn: nextLevel },
                { id: 'btn-back-to-menu', fn: () => showSection('fugitive-menu') },
                { id: 'btn-mute', fn: toggleMute },
                { id: 'btn-pause', fn: togglePause },
                { id: 'btn-skip', fn: skipTrack },
                { id: 'btn-shuffle', fn: shufflePlaylist },
                { id: 'btn-repeat', fn: toggleRepeat },
                { id: 'btn-save', fn: saveGame },
                { id: 'btn-load', fn: loadGame },
                { id: 'btn-back-to-start-fugitive', fn: showStartPage },
                { id: 'btn-back-to-start-game', fn: showStartPage },
                { id: 'btn-back-to-start-creative', fn: showStartPage },
                { id: 'btn-back-to-start-tutorial', fn: showStartPage },
                { id: 'btn-back-to-start-settings', fn: showStartPage },
                { id: 'btn-back-to-start-rules', fn: showStartPage },
                { id: 'btn-save-theme', fn: saveCurrentTheme },
                { id: 'btn-start-tutorial', fn: () => { setupTutorialStep(); toggleTutorialButtons(true); } },
                { id: 'btn-next-tutorial', fn: advanceTutorial },
                { id: 'btn-undo', fn: undoMove },
                { id: 'btn-customize-theme', fn: customizeTheme },
                { id: 'btn-clear-saves', fn: () => {
                    if (confirm('Are you sure you want to clear all saved games?')) {
                        localStorage.removeItem('fugitiveChessSave');
                        localStorage.removeItem('fugitiveChessAutosave');
                        alert('Saved games cleared.');
                    }
                } },
                { id: 'btn-clear-stats', fn: () => {
                    if (confirm('Are you sure you want to clear all statistics?')) {
                        localStorage.removeItem('fugitiveStats');
                        Object.keys(stats).forEach(key => stats[key] = 0);
                        updateStatsDisplay();
                        alert('Statistics cleared.');
                    }
                } },
                { id: 'btn-clear-themes', fn: () => {
                    if (confirm('Are you sure you want to clear all custom themes?')) {
                        localStorage.removeItem('fugitiveCustomThemes');
                        Object.keys(themes).forEach(key => {
                            if (key.startsWith('custom:')) delete themes[key];
                        });
                        initThemeDropdown();
                        alert('Custom themes cleared.');
                    }
                } },
                { id: 'btn-to-achievements', fn: () => showSection('achievements-section') },
                { id: 'btn-back-to-start-achievements', fn: showStartPage },
                { id: 'btn-back-to-settings-achievements', fn: () => showSection('settings-section') },
                { id: 'btn-clear-achievements', fn: clearAchievements },
                { id: 'btn-pause-game', fn: togglePauseGame },
                { id: 'btn-hint', fn: showFugitiveHint }
            ];
            buttons.forEach(({ id, fn }) => {
                const btn = document.getElementById(id);
                if (btn) btn.addEventListener('click', fn);
            });

            const mobileDirections = {
                'btn-up': [-1, 0],
                'btn-down': [1, 0],
                'btn-left': [0, -1],
                'btn-right': [0, 1],
                'btn-up-left': [-1, -1],
                'btn-up-right': [-1, 1],
                'btn-down-left': [1, -1],
                'btn-down-right': [1, 1]
            };
            Object.keys(mobileDirections).forEach(id => {
                document.getElementById(id).addEventListener('click', () => {
                    if (state.phase === 'moving') {
                        const [dr, dc] = mobileDirections[id];
                        const newRow = state.king[0] + dr;
                        const newCol = state.king[1] + dc;
                        moveKing(newRow, newCol);
                    }
                });
            });
        }
        document.getElementById('btn-back-from-rules').addEventListener('click', showStartPage);

        document.getElementById('btn-random-start-page').addEventListener('click', randomStart);

        document.getElementById('btn-skip-tutorial').addEventListener('click', () => {
            showPrompt("Tutorial skipped. Start playing or explore other modes.");
            showSection('start-page');
        });

        document.querySelector('#hintButton').addEventListener('click', provideHint);

        // Event listener for Start Campaign button
        document.getElementById('start-campaign').addEventListener('click', function() {
            isCampaignMode = true;
            const progress = initializeCampaign();
            const firstPrison = prisons[0];
            setCurrentPrison(progress, firstPrison);
            loadMap(firstPrison);
            startGame();
        });

        // Event listener for Continue Campaign button
        document.getElementById('continue-campaign').addEventListener('click', function() {
            isCampaignMode = true;
            let progress = loadCampaignProgress();
            if (!progress) {
                progress = initializeCampaign();
            }
            const currentPrison = getCurrentPrison(progress);
            loadMap(currentPrison);
            startGame();
        });

        // Event listener for Select Level button
        document.getElementById('select-level').addEventListener('click', function() {
            const progress = loadCampaignProgress();
            if (!progress) {
                alert("No campaign progress found. Please start a new campaign.");
                return;
            }
            const prisonList = document.getElementById('prison-list');
            prisonList.innerHTML = ''; // Clear previous list
            progress.prisons.forEach(prison => {
                if (prison.unlocked) {
                    const button = document.createElement('button');
                    button.textContent = prison.name;
                    button.style.margin = '5px';
                    button.addEventListener('click', function() {
                        isCampaignMode = true;
                        setCurrentPrison(progress, prison.name);
                        loadMap(prison.name);
                        startGame();
                        document.getElementById('level-selection').style.display = 'none';
                    });
                    prisonList.appendChild(button);
                }
            });
            document.getElementById('level-selection').style.display = 'block';
        });

        // Event listener for Close Level Selection
        document.getElementById('close-level-selection').addEventListener('click', function() {
            document.getElementById('level-selection').style.display = 'none';
        });

        // Event listener for Continue to Next Prison button
        document.getElementById('continue-to-next').addEventListener('click', function() {
            const progress = loadCampaignProgress();
            const currentIndex = progress.prisons.findIndex(p => p.name === getCurrentPrison(progress));
            if (currentIndex + 1 < progress.prisons.length) {
                const nextPrison = progress.prisons[currentIndex + 1].name;
                setCurrentPrison(progress, nextPrison);
                loadMap(nextPrison);
                startGame();
            } else {
                alert("Congratulations! You’ve completed the campaign!");
                showSection('fugitive-menu');
            }
            document.getElementById('campaign-completion').style.display = 'none';
        });

        // Event listener for Retry Prison button
        document.getElementById('retry-prison').addEventListener('click', function() {
            isCampaignMode = true;
            const progress = loadCampaignProgress();
            const currentPrison = getCurrentPrison(progress);
            loadMap(currentPrison);
            startGame();
            document.getElementById('campaign-failure').style.display = 'none';
        });

        // Event listeners for Back to Menu buttons in modals
        document.getElementById('back-to-menu').addEventListener('click', function() {
            document.getElementById('campaign-completion').style.display = 'none';
            showSection('fugitive-menu');
        });
        document.getElementById('back-to-menu-failure').addEventListener('click', function() {
            document.getElementById('campaign-failure').style.display = 'none';
            showSection('fugitive-menu');
        });

        const guidedSteps = [
            { text: "Welcome! Let's set up your game. Choose a difficulty:", options: ['pawn', 'knight', 'rook', 'bishop', 'queen', 'king'], key: 'difficulty' },
            { text: "Select a level (1-100):", options: Array.from({length: 100}, (_, i) => (i + 1).toString()), key: 'level' },
            { text: "Want a timer per turn? (30s)", options: ['off', 'on'], key: 'turnTimer' },
            { text: "Enable guards?", options: ['on', 'off'], key: 'guardsEnabled' },
            { text: "Enable treasure drops?", options: ['off', 'on'], key: 'treasureDrops' },
            { text: "Enable hidden items?", options: ['off', 'on'], key: 'hiddenItems' },
            { text: "Enable hero ability?", options: ['off', 'on'], key: 'heroAbility' },
            { text: "Enable portals?", options: ['off', '1 Pair', '2 Pairs', '3 Pairs'], key: 'portals' },
            { text: "Ready to play?", options: ['yes'], key: 'finish' }
        ];
        let guidedStepIndex = 0;

        function startGuidedSetup() {
            guidedStepIndex = 0;
            document.getElementById('guided-setup-modal').style.display = 'block';
            updateGuidedStep();
        }

        function updateGuidedStep() {
            const step = guidedSteps[guidedStepIndex];
            const stepText = document.getElementById('guided-step-text');
            const select = document.getElementById('guided-option');
            const backBtn = document.getElementById('guided-back');
            const nextBtn = document.getElementById('guided-next');
            const finishBtn = document.getElementById('guided-finish');

            if (!stepText || !select || !backBtn || !nextBtn || !finishBtn) {
                console.error('Guided setup elements missing');
                return;
            }

            stepText.textContent = step.text;
            select.innerHTML = '';
            step.options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt;
                option.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
                select.appendChild(option);
            });

            backBtn.style.display = guidedStepIndex === 0 ? 'none' : 'inline';
            nextBtn.style.display = guidedStepIndex < guidedSteps.length - 1 ? 'inline' : 'none';
            finishBtn.style.display = guidedStepIndex === guidedSteps.length - 1 ? 'inline' : 'none';
        }

        document.getElementById('btn-guided-setup').addEventListener('click', startGuidedSetup);

        document.getElementById('guided-next').addEventListener('click', () => {
            const step = guidedSteps[guidedStepIndex];
            if (step.key !== 'finish') {
                state[step.key] = document.getElementById('guided-option').value;
                const elementId = {
                    difficulty: 'difficulty',
                    level: 'level',
                    turnTimer: 'turnTimer',
                    guardsEnabled: 'guards',
                    treasureDrops: 'treasureDrops',
                    hiddenItems: 'hiddenItems',
                    heroAbility: 'heroAbility',
                    portals: 'portals'
                }[step.key];
                document.getElementById(elementId).value = state[step.key];
                if (step.key === 'level') document.getElementById('level-info').textContent = `Level ${state.level}`;
            }
            if (guidedStepIndex < guidedSteps.length - 1) {
                guidedStepIndex++;
                updateGuidedStep();
            }
        });

        document.getElementById('guided-back').addEventListener('click', () => {
            if (guidedStepIndex > 0) {
                guidedStepIndex--;
                updateGuidedStep();
            }
        });

        document.getElementById('guided-finish').addEventListener('click', () => {
            document.getElementById('guided-setup-modal').style.display = 'none';
            startGame();
        });

        document.getElementById('btn-use-treasure').addEventListener('click', () => {
            if (state.phase !== 'moving') {
                alert('Can only use treasures during your turn!');
                return;
            }
            if (state.collectedTreasures.length === 0) {
                alert('No treasures to use!');
                return;
            }
            showTreasureSelection();
        });

        function showTreasureSelection() {
            const modal = document.getElementById('treasure-modal');
            const list = document.getElementById('treasure-list');
            list.innerHTML = '';
            state.collectedTreasures.forEach((treasure, index) => {
                const btn = document.createElement('button');
                btn.textContent = treasure.type.charAt(0).toUpperCase() + treasure.type.slice(1);
                btn.setAttribute('aria-label', `Use ${treasure.type} treasure: ${treasures[treasure.type].description}`);
                btn.onclick = () => {
                    applyTreasureEffect(treasure);
                    state.collectedTreasures.splice(index, 1);
                    modal.style.display = 'none';
                    if (state.moves <= 0) endPlayerTurn();
                    updateStats();
                    drawBoard();
                };
                list.appendChild(btn);
            });
            modal.style.display = 'block';
        }

        document.getElementById('btn-close-treasure').addEventListener('click', () => {
            document.getElementById('treasure-modal').style.display = 'none';
        });

        function showHelpModal() {
            const hotkeys = {
                'Space': 'Roll dice (when waiting)',
                'Arrow Keys/WASD': 'Move king (orthogonal)',
                'Shift + Arrow Keys': 'Move king (diagonal)',
                'Q/E/Z/C': 'Move diagonally (alternative)',
                'H': 'Use hero ability (if enabled)',
                'Ctrl+R': 'Replay level',
                'Ctrl+N': 'Next level',
                'Ctrl+S': 'Save game',
                'Ctrl+L': 'Load game',
                'Ctrl+M': 'Return to menu',
                'Ctrl+T': 'Toggle mute',
                'Ctrl+P': 'Play/pause music',
                'Ctrl+K': 'Skip track',
                'Ctrl+H': 'Shuffle playlist',
                'Ctrl+E': 'Toggle repeat'
            };
            const helpList = document.getElementById('help-list');
            helpList.innerHTML = '';
            Object.entries(hotkeys).forEach(([key, desc]) => {
                const li = document.createElement('li');
                li.textContent = `${key}: ${desc}`;
                helpList.appendChild(li);
            });
            document.getElementById('help-modal').style.display = 'block';
        }

        function initHelpButton() {
            const btnHelp = document.getElementById('btn-help');
            const btnCloseHelp = document.getElementById('btn-close-help');
            btnHelp.addEventListener('click', showHelpModal);
            btnCloseHelp.addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'none';
            });
        }

        function showTooltip(elementId, text) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = text;
            tooltip.style.position = 'absolute';
            tooltip.style.backgroundColor = '#333';
            tooltip.style.color = '#fff';
            tooltip.style.padding = '5px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.zIndex = '1001';
            document.body.appendChild(tooltip);
            const element = document.getElementById(elementId);
            const rect = element.getBoundingClientRect();
            tooltip.style.left = `${rect.left}px`;
            tooltip.style.top = `${rect.bottom}px`;
            element.addEventListener('mouseleave', () => tooltip.remove());
        }

        function addTooltips() {
            const options = {
                'difficulty': 'Choose game difficulty. Higher levels increase guard numbers and aggression.',
                'level': 'Select the level (1-100). Affects guard types and numbers.',
                'turn-timer': 'Enable a 30-second timer per turn when On.',
                'turn-limit': 'Set a maximum number of turns (None, 5, 10, 15).',
                'king-disarmed': 'Prevent the king from attacking guards when On.',
                'guards': 'Enable or disable guards on the board.',
                'fog-vision': 'Limit visibility to the king’s adjacent squares when On.',
                'treasure-drops': 'Enable random treasure drops on the board when On.',
                'hidden-items': 'Make treasures invisible until collected when On.',
                'arcade-mode': 'Enable point collection and scoring when On.',
                'hero-ability': 'Enable the selected hero’s special ability when On.',
                'portals': 'Add 0-3 pairs of teleporting portals to the board.',
                'move-hints': 'Show hints towards the escape: Off, Next Move, or Full Path.',
                'theme': 'Choose the visual theme of the game board and UI.',
                'piece-style': 'Select the style of game pieces.',
                'hero-select': 'Choose a hero with a special ability (optional).',
                'song-select': 'Choose background music for the game.',
                'animations': 'Enable or disable animations.',
                'time-attack': 'Enable a 30-minute total time limit across all levels when On.'
            };

            const selects = document.querySelectorAll('#fugitive-menu select');
            selects.forEach(select => {
                select.addEventListener('mouseover', (e) => {
                    const description = options[select.id] || select.getAttribute('title') || 'No description available.';
                    showTooltip(select.id, description);
                });
                select.addEventListener('focus', (e) => {
                    const description = options[select.id] || select.getAttribute('title') || 'No description available.';
                    showTooltip(select.id, description);
                });
            });
        }

        function initCanvasEvents() {
            const canvas = document.getElementById('board');
            const ctx = canvas.getContext('2d'); // Ensure ctx is defined
            if (canvas && ctx) {
                let hoveredGuard = null;

                // Mouse move event for hovering over guards
                canvas.addEventListener('mousemove', (e) => {
                    if (!state.king || !Array.isArray(state.king) || state.king.length !== 2) {
                        console.warn('Ignoring mousemove event: invalid king state');
                        return;
                    }
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width; // Adjust for canvas scaling
                    const scaleY = canvas.height / rect.height;
                    const col = Math.floor(((e.clientX - rect.left) * scaleX) / SQUARE);
                    const row = Math.floor(((e.clientY - rect.top) * scaleY) / SQUARE);
                    if (state.fogVision === 'on') {
                        const vision = getKingVision();
                        const visionSet = new Set(vision.map(([r, c]) => `${r},${c}`));
                        hoveredGuard = visionSet.has(`${row},${col}`) ? state.opponents.find(op => op.pos[0] === row && op.pos[1] === col) || null : null;
                    } else {
                        hoveredGuard = state.opponents.find(op => op.pos[0] === row && op.pos[1] === col) || null;
                    }
                    window.hoveredGuard = hoveredGuard;
                    drawBoard();
                });

                // Click event for game actions
                canvas.addEventListener('click', (e) => {
                    console.log('Canvas clicked'); // Debug: Verify click is registered
                    if (state.paused) {
                        console.log('Game is paused');
                        return;
                    }
                    if (!state.king || !Array.isArray(state.king) || state.king.length !== 2) {
                        console.warn('Ignoring click event: invalid king state');
                        return;
                    }
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width; // Adjust for scaling
                    const scaleY = canvas.height / rect.height;
                    const col = Math.floor(((e.clientX - rect.left) * scaleX) / SQUARE);
                    const row = Math.floor(((e.clientY - rect.top) * scaleY) / SQUARE);
                    console.log(`Clicked on row: ${row}, col: ${col}`); // Debug: Check coordinates
                    console.log(`Current phase: ${state.phase}`); // Debug: Verify game phase
                    console.log(`state.selectingWall: ${state.selectingWall}`);
                    console.log(`state.selectingGuard: ${state.selectingGuard}`);
                    console.log(`state.selectingTeleport: ${state.selectingTeleport}`);

                    // Temporary debug drawing to visualize click position
                    ctx.beginPath();
                    ctx.arc(col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    setTimeout(() => drawBoard(), 500); // Clear after 500ms

                    if (state.selectingWall) {
                        const index = state.blocked.findIndex(b => b[0] === row && b[1] === col);
                        if (index !== -1) {
                            state.blocked.splice(index, 1);
                            state.selectingWall = false;
                            document.getElementById('game-info').textContent = 'Wall destroyed!';
                            drawBoard();
                        } else {
                            document.getElementById('game-info').textContent = 'Click a blocked square!';
                        }
                        return;
                    }
                    if (state.selectingGuard) {
                        const guardIndex = state.opponents.findIndex(op => op.pos[0] === row && op.pos[1] === col);
                        if (guardIndex !== -1) {
                            if (state.isSwapping) {
                                const guardPos = [...state.opponents[guardIndex].pos];
                                state.opponents[guardIndex].pos = [...state.king];
                                state.opponents[guardIndex].vision = getGuardVision(state.opponents[guardIndex]);
                                state.king = guardPos;
                                document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Loki swapped with a guard!';
                                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                    sounds.move.volume = state.music.sfxVolume;
                                    sounds.move.play();
                                }
                                state.moves--;
                            } else if (state.isDefeating) {
                                state.opponents.splice(guardIndex, 1);
                                state.guards++;
                                if (state.arcadeMode === 'on') state.score += 10;
                                document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Excalibur defeated the guard!';
                                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                    sounds.capture.volume = state.music.sfxVolume;
                                    sounds.capture.play();
                                }
                                state.moves--;
                            } else if (state.isRangedAttack) {
                                if (Math.abs(row - state.king[0]) + Math.abs(col - state.king[1]) <= 2) {
                                    state.opponents.splice(guardIndex, 1);
                                    state.guards++;
                                    if (state.arcadeMode === 'on') state.score += 10;
                                    document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Bow attacked the guard!';
                                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                        sounds.capture.volume = state.music.sfxVolume;
                                        sounds.capture.play();
                                    }
                                    state.moves--;
                                } else {
                                    document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Guard too far for Bow!';
                                    return;
                                }
                            } else {
                                state.opponents.splice(guardIndex, 1);
                                state.guards++;
                                if (state.arcadeMode === 'on') state.score += 10;
                                document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Musashi defeated the guard in a duel!';
                                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                    sounds.capture.volume = state.music.sfxVolume;
                                    sounds.capture.play();
                                }
                                state.moves--;
                            }
                            state.selectingGuard = false;
                            state.isSwapping = false;
                            state.isDefeating = false;
                            state.isRangedAttack = false;
                            if (state.moves <= 0) endPlayerTurn();
                            updateStats();
                            drawBoard();
                        } else {
                            document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = state.isRangedAttack ? 'Click a guard within two squares!' : 'Click a guard!';
                        }
                    } else if (state.selectingTeleport) {
                        if (!isSquareOccupied(row, col) || (row === state.escape[0] && col === state.escape[1])) {
                            state.king = [row, col];
                            state.selectingTeleport = false;
                            document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Gagarin teleported to a new square!';
                            if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                sounds.move.volume = state.music.sfxVolume;
                                sounds.move.play();
                            }
                            state.moves--;
                            if (state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) {
                                state.phase = 'win';
                                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                    sounds.win.volume = state.music.sfxVolume;
                                    sounds.win.play();
                                }
                                showPrompt('You reached the safe spot!');
                            }
                            if (state.moves <= 0) endPlayerTurn();
                            updateStats();
                            drawBoard();
                        } else {
                            document.getElementById(state.mode === 'tutorial' ? 'tutorial-info' : 'game-info').textContent = 'Choose an empty or escape square!';
                        }
                    } else if (state.phase === 'moving') {
                        const validMoves = getValidMoves();
                        if (validMoves.some(m => m[0] === row && m[1] === col)) moveKing(row, col);
                    } else {
                        if (row >= 0 && row < BOARD && col >= 0 && col < BOARD) {
                            flashInvalidSquare(row, col);
                            if (!state.music.isMuted && state.music.sfxVolume > 0) {
                                sounds.invalid.volume = state.music.sfxVolume;
                                sounds.invalid.play();
                            }
                        }
                        document.getElementById('game-info').textContent = 'Invalid move. Use arrow keys or WASD';
                    }
                });

                // Keydown event (already working)
                canvas.addEventListener('keydown', (e) => {
                    if (state.paused) return;
                    const directions = {
                        'ArrowUp': [-1, 0], 'w': [-1, 0],
                        'ArrowDown': [1, 0], 's': [1, 0],
                        'ArrowLeft': [0, -1], 'a': [0, -1],
                        'ArrowRight': [0, 1], 'd': [0, 1],
                        'q': [-1, -1], 'e': [-1, 1],
                        'z': [1, -1], 'c': [1, 1]
                    };
                    const move = directions[e.key];
                    if (move && state.phase === 'moving') {
                        const [dr, dc] = move;
                        const newRow = state.king[0] + dr;
                        const newCol = state.king[1] + dc;
                        moveKing(newRow, newCol);
                    }
                });

                // Ensure canvas is focusable for key events
                canvas.tabIndex = 0;
                canvas.setAttribute('aria-label', 'Fugitive Chess game board');
            }

            // Tutorial canvas setup
            const tutorialCanvas = document.getElementById('tutorial-board');
            const tutorialCtx = tutorialCanvas ? tutorialCanvas.getContext('2d') : null;
            if (tutorialCanvas && tutorialCtx) {
                tutorialCanvas.addEventListener('click', (e) => {
                    if (state.phase !== 'moving' || state.mode !== 'tutorial') return;
                    if (!state.king || !Array.isArray(state.king) || state.king.length !== 2) {
                        console.warn('Ignoring tutorial click event: invalid king state');
                        return;
                    }
                    const rect = tutorialCanvas.getBoundingClientRect();
                    const scaleX = tutorialCanvas.width / rect.width;
                    const scaleY = tutorialCanvas.height / rect.height;
                    const col = Math.floor(((e.clientX - rect.left) * scaleX) / SQUARE);
                    const row = Math.floor(((e.clientY - rect.top) * scaleY) / SQUARE);
                    console.log(`Tutorial canvas clicked: row ${row}, col ${col}`); // Debug
                    const validMoves = getValidMoves();
                    if (validMoves.some(m => m[0] === row && m[1] === col)) moveKing(row, col);
                });

                // Tutorial canvas touch event
                if (tutorialCanvas && tutorialCtx) {
                    tutorialCanvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleCanvasClick(e.touches[0], tutorialCanvas, tutorialCtx);
                    });
                }
            }
        }

        function handleCanvasClick(touch, canvas, ctx) {
            if (!canvas || !ctx) {
                console.error('handleCanvasClick: Invalid canvas or context');
                return;
            }

            const isTutorial = canvas.id === 'tutorial-board';
            console.log(`Touch event on ${isTutorial ? 'tutorial' : 'main'} canvas`);

            if (state.paused) {
                console.log('Game is paused');
                return;
            }
            if (!state.king || !Array.isArray(state.king) || state.king.length !== 2) {
                console.warn('Ignoring touch event: invalid king state');
                return;
            }
            if (isTutorial && state.mode !== 'tutorial') {
                console.log('Ignoring touch on tutorial canvas: not in tutorial mode');
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width; // Adjust for scaling
            const scaleY = canvas.height / rect.height;
            const col = Math.floor(((touch.clientX - rect.left) * scaleX) / SQUARE);
            const row = Math.floor(((touch.clientY - rect.top) * scaleY) / SQUARE);
            console.log(`Touched on row: ${row}, col: ${col}`);

            // Temporary debug drawing to visualize touch position
            ctx.save(); // Save context to avoid affecting other drawings
            ctx.beginPath();
            ctx.arc(col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2, 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.restore();
            setTimeout(() => drawBoard(), 500); // Clear after 500ms

            const infoElement = isTutorial ? 'tutorial-info' : 'game-info';

            if (state.selectingWall && !isTutorial) {
                const index = state.blocked.findIndex(b => b[0] === row && b[1] === col);
                if (index !== -1) {
                    state.blocked.splice(index, 1);
                    state.selectingWall = false;
                    document.getElementById(infoElement).textContent = 'Wall destroyed!';
                    drawBoard();
                } else {
                    document.getElementById(infoElement).textContent = 'Click a blocked square!';
                }
                return;
            }
            if (state.selectingGuard && !isTutorial) {
                const guardIndex = state.opponents.findIndex(op => op.pos[0] === row && op.pos[1] === col);
                if (guardIndex !== -1) {
                    if (state.isSwapping) {
                        const guardPos = [...state.opponents[guardIndex].pos];
                        state.opponents[guardIndex].pos = [...state.king];
                        state.opponents[guardIndex].vision = getGuardVision(state.opponents[guardIndex]);
                        state.king = guardPos;
                        document.getElementById(infoElement).textContent = 'Loki swapped with a guard!';
                        if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                            sounds.move.volume = state.music.sfxVolume;
                            sounds.move.play();
                        }
                        state.moves--;
                    } else if (state.isDefeating) {
                        state.opponents.splice(guardIndex, 1);
                        state.guards++;
                        if (state.arcadeMode === 'on') state.score += 10;
                        document.getElementById(infoElement).textContent = 'Excalibur defeated the guard!';
                        if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                            sounds.capture.volume = state.music.sfxVolume;
                            sounds.capture.play();
                        }
                        state.moves--;
                    } else if (state.isRangedAttack) {
                        if (Math.abs(row - state.king[0]) + Math.abs(col - state.king[1]) <= 2) {
                            state.opponents.splice(guardIndex, 1);
                            state.guards++;
                            if (state.arcadeMode === 'on') state.score += 10;
                            document.getElementById(infoElement).textContent = 'Bow attacked the guard!';
                            if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                                sounds.capture.volume = state.music.sfxVolume;
                                sounds.capture.play();
                            }
                            state.moves--;
                        } else {
                            document.getElementById(infoElement).textContent = 'Guard too far for Bow!';
                            return;
                        }
                    } else {
                        state.opponents.splice(guardIndex, 1);
                        state.guards++;
                        if (state.arcadeMode === 'on') state.score += 10;
                        document.getElementById(infoElement).textContent = 'Musashi defeated the guard in a duel!';
                        if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                            sounds.capture.volume = state.music.sfxVolume;
                            sounds.capture.play();
                        }
                        state.moves--;
                    }
                    state.selectingGuard = false;
                    state.isSwapping = false;
                    state.isDefeating = false;
                    state.isRangedAttack = false;
                    if (state.moves <= 0) endPlayerTurn();
                    updateStats();
                    drawBoard();
                } else {
                    document.getElementById(infoElement).textContent = state.isRangedAttack ? 'Click a guard within two squares!' : 'Click a guard!';
                }
            } else if (state.selectingTeleport && !isTutorial) {
                if (!isSquareOccupied(row, col) || (row === state.escape[0] && col === state.escape[1])) {
                    state.king = [row, col];
                    state.selectingTeleport = false;
                    document.getElementById(infoElement).textContent = 'Gagarin teleported to a new square!';
                    if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                        sounds.move.volume = state.music.sfxVolume;
                        sounds.move.play();
                    }
                    state.moves--;
                    if (state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) {
                        state.phase = 'win';
                        if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                            sounds.win.volume = state.music.sfxVolume;
                            sounds.win.play();
                        }
                        showPrompt('You reached the safe spot!');
                    }
                    if (state.moves <= 0) endPlayerTurn();
                    updateStats();
                    drawBoard();
                } else {
                    document.getElementById(infoElement).textContent = 'Choose an empty or escape square!';
                }
            } else if (state.phase === 'moving') {
                const validMoves = getValidMoves();
                if (validMoves.some(m => m[0] === row && m[1] === col)) moveKing(row, col);
            } else {
                if (row >= 0 && row < BOARD && col >= 0 && col < BOARD) {
                    flashInvalidSquare(row, col);
                    if (!state.music?.isMuted && state.music?.sfxVolume > 0) {
                        sounds.invalid.volume = state.music.sfxVolume;
                        sounds.invalid.play();
                    }
                }
                document.getElementById(infoElement).textContent = 'Invalid move. Use arrow keys or WASD';
            }
        }

        function addTreasureTooltips() {
            const canvas = document.getElementById('board');
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / SQUARE);
                const row = Math.floor((e.clientY - rect.top) / SQUARE);
                const treasure = state.treasures.find(t => t.pos[0] === row && t.pos[1] === col);
                if (treasure && (state.hiddenItems === 'off' || state.hiddenItemsOverride)) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = treasures[treasure.type].description;
                    tooltip.style.position = 'absolute';
                    tooltip.style.backgroundColor = '#333';
                    tooltip.style.color = '#fff';
                    tooltip.style.padding = '5px';
                    tooltip.style.borderRadius = '3px';
                    tooltip.style.zIndex = '1001';
                    document.body.appendChild(tooltip);
                    tooltip.style.left = `${e.clientX + 10}px`;
                    tooltip.style.top = `${e.clientY + 10}px`;
                    canvas.addEventListener('mouseout', () => tooltip.remove(), { once: true });
                }
            });
        }

        function initKeyboardNavigation() {
            const sections = [
                'start-page', 'fugitive-menu', 'game-area', 'standard-chess-section',
                'creative-mode', 'tutorial-section', 'settings-section', 'rules-content', 'achievements-section', 'tips-strategy-section', 'store-section'
            ].map(id => document.getElementById(id)).filter(section => section);

            sections.forEach(section => {
                const elements = Array.from(section.querySelectorAll('button, select, input, [tabindex="0"]'));
                let currentIndex = 0;

                section.addEventListener('keydown', (e) => {
                    if (section.style.display !== 'flex') return;
                    switch (e.key) {
                        case 'Tab':
                            e.preventDefault();
                            currentIndex = (currentIndex + (e.shiftKey ? -1 : 1) + elements.length) % elements.length;
                            elements[currentIndex].focus();
                            const label = elements[currentIndex].textContent || elements[currentIndex].getAttribute('aria-label') || 'Unnamed element';
                            announce(`Focused: ${label}`);
                            break;
                        case 'Enter':
                        case ' ':
                            if (elements[currentIndex].tagName === 'BUTTON') {
                                e.preventDefault();
                                elements[currentIndex].click();
                                announce(`Activated: ${elements[currentIndex].getAttribute('aria-label') || elements[currentIndex].textContent}`);
                            }
                            break;
                        case 'ArrowDown':
                            if (elements[currentIndex].tagName === 'SELECT') {
                                e.preventDefault();
                                const select = elements[currentIndex];
                                select.selectedIndex = Math.min(select.selectedIndex + 1, select.options.length - 1);
                                select.dispatchEvent(new Event('change'));
                                announce(`Selected: ${select.options[select.selectedIndex].textContent}`);
                            }
                            break;
                        case 'ArrowUp':
                            if (elements[currentIndex].tagName === 'SELECT') {
                                e.preventDefault();
                                const select = elements[currentIndex];
                                select.selectedIndex = Math.max(select.selectedIndex - 1, 0);
                                select.dispatchEvent(new Event('change'));
                                announce(`Selected: ${select.options[select.selectedIndex].textContent}`);
                            }
                            break;
                    }
                });

                elements.forEach((el, i) => {
                    if (!el.hasAttribute('aria-label')) {
                        el.setAttribute('aria-label', el.textContent || 'Interactive element');
                    }
                    el.addEventListener('focus', () => {
                        currentIndex = i;
                        el.style.outline = '2px solid #ffd700';
                        el.setAttribute('aria-selected', 'true');
                    });
                    el.addEventListener('blur', () => {
                        el.style.outline = '';
                        el.setAttribute('aria-selected', 'false');
                    });
                    if (!el.hasAttribute('tabindex')) el.tabIndex = 0;
                });
            });
        }

        document.querySelectorAll('button, select').forEach(element => {
            if (!element.hasAttribute('aria-label')) {
                element.setAttribute('aria-label', element.textContent || 'Interactive element');
            }
            element.addEventListener('focus', () => {
                element.style.outline = '2px solid #ffd700';
            });
            element.addEventListener('blur', () => {
                element.style.outline = 'none';
            });
        });

        // --- Event Handlers ---
        function startMusicOnInteraction() {
            if (!musicInitiated) {
                playMusic();
                musicInitiated = true;
            }
        }

        function handleKeyDown(e) {
            const gameArea = document.getElementById('game-area');
            const tutorialSection = document.getElementById('tutorial-section');
            const customPrompt = document.getElementById('custom-prompt');
            const gameAreaVisible = gameArea && gameArea.style.display === 'flex';
            const tutorialVisible = tutorialSection && tutorialSection.style.display === 'flex';
            const promptVisible = customPrompt && customPrompt.style.display === 'block';
            const moveDelay = 200;

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'q', 'e', 'z', 'c'].includes(e.key)) e.preventDefault();

            if ((gameAreaVisible || tutorialVisible) && !promptVisible) {
                if (state.paused) return;
                if (state.phase === 'waiting' && e.key === ' ') {
                    rollDice();
                    return;
                }
                if (state.phase === 'moving' && !e.repeat) {
                    const now = Date.now();
                    if (now - lastMoveTime < moveDelay) return;
                    const directions = {
                        'ArrowUp': [-1, 0], 'w': [-1, 0],
                        'ArrowDown': [1, 0], 's': [1, 0],
                        'ArrowLeft': [0, -1], 'a': [0, -1],
                        'ArrowRight': [0, 1], 'd': [0, 1],
                        'q': [-1, -1], 'e': [-1, 1],
                        'z': [1, -1], 'c': [1, 1]
                    };

                    // Diagonal movement with Shift + Arrow keys
                    if (e.shiftKey) {
                        if (e.key === 'ArrowUp' && keyState['ArrowLeft']) directions['Shift+ArrowUp+ArrowLeft'] = [-1, -1];
                        else if (e.key === 'ArrowUp' && keyState['ArrowRight']) directions['Shift+ArrowUp+ArrowRight'] = [-1, 1];
                        else if (e.key === 'ArrowDown' && keyState['ArrowLeft']) directions['Shift+ArrowDown+ArrowLeft'] = [1, -1];
                        else if (e.key === 'ArrowDown' && keyState['ArrowRight']) directions['Shift+ArrowDown+ArrowRight'] = [1, 1];
                    }

                    const move = directions[e.key];
                    if (move) {
                        const [dr, dc] = move;
                        const newRow = state.king[0] + dr;
                        const newCol = state.king[1] + dc;
                        const validMoves = getValidMoves();
                        if (validMoves.some(m => m[0] === newRow && m[1] === newCol)) {
                            moveKing(newRow, newCol);
                            lastMoveTime = now;
                        } else {
                            const info = tutorialVisible ? 'tutorial-info' : 'game-info';
                            if (newRow >= 0 && newRow < BOARD && newCol >= 0 && newCol < BOARD) {
                                state.invalidSquare = [newRow, newCol];
                                setTimeout(() => {
                                    state.invalidSquare = null;
                                    drawBoard();
                                }, 500);
                            }
                            document.getElementById(info).textContent = 'Invalid move. Use Shift + Arrows for diagonals or Q/E/Z/C';
                        }
                    }
                    if (e.key === 'h') {
                        useHeroAbility();
                    }
                    if (e.key === 'm') {
                        state.miniMapZoomed = !state.miniMapZoomed;
                        drawMiniMap();
                        document.getElementById('btn-toggle-minimap').textContent = state.miniMapZoomed ? 'Shrink Mini-Map' : 'Enlarge Mini-Map';
                    }
                    if (e.shiftkey === 'b') {
                        showSection('fugitive-menu');
                    }
                    if (e.ctrlKey && e.key === 'z') {
                        if (state.mode === 'creative') {
                            // Undo in creative mode
                            if (creativeState.history.length > 0) {
                                creativeState.redoStack.push({
                                    king: creativeState.king ? [...creativeState.king] : null,
                                    jail: creativeState.jail ? [...creativeState.jail] : null,
                                    escape: creativeState.escape ? [...creativeState.escape] : null,
                                    opponents: JSON.parse(JSON.stringify(creativeState.opponents)),
                                    blocked: JSON.parse(JSON.stringify(creativeState.blocked)),
                                    treasures: JSON.parse(JSON.stringify(creativeState.treasures)),
                                    portalsList: JSON.parse(JSON.stringify(creativeState.portalsList))
                                });
                                const lastState = creativeState.history.pop();
                                Object.assign(creativeState, lastState);
                                drawCreativeBoard();
                                showMessage('Undo action performed');
                            }
                        }
                    }
                    if (e.ctrlKey && e.key === 'y') {
                        if (state.mode === 'creative') {
                            // Redo in creative mode
                            if (creativeState.redoStack.length > 0) {
                                saveCreativeState();
                                const nextState = creativeState.redoStack.pop();
                                Object.assign(creativeState, nextState);
                                drawCreativeBoard();
                                showMessage('Redo action performed');
                            }
                        }
                    }
                }
            }

            // Standard Chess mode handling
            if (state.mode === 'standard' && !promptVisible) {
                const now = Date.now();
                if (now - lastCursorMoveTime > 100 && !e.repeat) {
                    if (e.key === 'ArrowUp') {
                        standardState.cursorRow = Math.max(0, standardState.cursorRow - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowDown') {
                        standardState.cursorRow = Math.min(7, standardState.cursorRow + 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowLeft') {
                        standardState.cursorCol = Math.max(0, standardState.cursorCol - 1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight') {
                        standardState.cursorCol = Math.min(7, standardState.cursorCol + 1);
                        e.preventDefault();
                    }
                    lastCursorMoveTime = now;
                    drawStandardBoard();
                    state.forceRedraw = true;
                }
                if (e.key === 'Enter' || e.key === ' ') {
                    handleStandardKeyboardSelect();
                    e.preventDefault();
                }
            }

            const ctrl = e.ctrlKey;
            const key = e.key.toLowerCase();
            const hotkeys = {
                'n': nextLevel, 'r': replayLevel, 's': saveGame, 'l': loadGame, 'm': () => showSection('fugitive-menu'),
                't': toggleMute, 'p': togglePause, 'k': skipTrack, 'h': shufflePlaylist, 'e': toggleRepeat
            };

            if (ctrl && hotkeys[key]) {
                e.preventDefault();
                hotkeys[key]();
            } else if (promptVisible && !ctrl) {
                if (key === 'r') replayLevel();
                else if (key === 'n') nextLevel();
                else if (key === 'm') showSection('fugitive-menu');
            }
        }

        // --- Game Logic Functions ---
        function startGame() {
            state.mode = 'fugitive';
            stats.gamesPlayed++;
            if (!validateState()) {
                console.warn('Invalid state in startGame, resetting king');
                state.king = [0, 0];
            }
            if (isCampaignMode) {
                const progress = loadCampaignProgress() || initializeCampaign();
                const currentPrison = getCurrentPrison(progress);
                loadMap(currentPrison);
                document.getElementById('level-info').textContent = `Campaign: ${currentPrison}`;
                state.arcadeMode = 'off'; // Default for Campaign Mode
                state.difficulty = prisonMaps[currentPrison].difficulty.toLowerCase();
                state.level = progress.prisons.findIndex(p => p.name === currentPrison) + 1;
            } else {
                const difficulty = document.getElementById('difficulty').value;
                const level = document.getElementById('level').value;
                const theme = document.getElementById('theme').value;
                const pieceStyle = document.getElementById('piece-style').value;
                const turnTimer = document.getElementById('turn-timer').value;
                const turnLimit = document.getElementById('turn-limit').value;
                const kingDisarmed = document.getElementById('king-disarmed').value;
                const guardsEnabled = document.getElementById('guards').value;
                const treasureDrops = document.getElementById('treasure-drops').value;
                const hiddenItems = document.getElementById('hidden-items').value;
                const heroAbility = document.getElementById('hero-ability').value;
                const portals = parseInt(document.getElementById('portals').value, 10);
                const arcadeMode = document.getElementById('arcade-mode').value;
                state.difficulty = difficulty;
                state.level = parseInt(level, 10) || 1;
                state.theme = theme;
                state.pieceStyle = pieceStyle;
                state.turnTimer = turnTimer;
                state.turnLimit = turnLimit;
                state.kingDisarmed = kingDisarmed;
                state.guardsEnabled = guardsEnabled;
                state.treasureDrops = treasureDrops;
                state.hiddenItems = hiddenItems;
                state.heroAbility = heroAbility;
                state.fogVision = document.getElementById('fog-vision').value;
                state.portals = isNaN(portals) ? 0 : portals;
                state.arcadeMode = arcadeMode;
                state.guardAggression = document.getElementById('guard-aggression').value;
                state.treasureSpawnRate = document.getElementById('treasure-spawn-rate').value;
                state.hintEnabled = document.getElementById('move-hints').value;
                localStorage.setItem('fugitiveSettings', JSON.stringify({
                    difficulty: state.difficulty,
                    level: state.level,
                    theme: state.theme,
                    pieceStyle: state.pieceStyle,
                    turnTimer: state.turnTimer,
                    turnLimit: state.turnLimit,
                    kingDisarmed: state.kingDisarmed,
                    guardsEnabled: state.guardsEnabled,
                    treasureDrops: state.treasureDrops,
                    hiddenItems: state.hiddenItems,
                    heroAbility: state.heroAbility,
                    fogVision: state.fogVision,
                    portals: state.portals,
                    arcadeMode: state.arcadeMode,
                    hintEnabled: state.hintEnabled
                }));
                initBoard(); // Only call for non-campaign modes
            }
            state.paused = false;
            state.timeAttack = document.getElementById('time-attack').value;
            if (state.timeAttack === 'on') {
                state.timeLeft = state.totalTime;
            }
            document.getElementById('paused-overlay').style.display = 'none';
            if (state.arcadeMode === 'on') state.score = 0; // Use state.arcadeMode consistently
            state.level = Math.max(1, Math.min(state.level, 100));
            turnCount = 0;
            showSection('game-area');
            updateStats();
            state.forceRedraw = true;
            drawBoard();
            displayModeRules();
            updateLeaderboard();
            updateHeroAbilityUI();
            document.getElementById('game-info').textContent = 'Game started! Press Space to roll dice';
            localStorage.setItem('fugitiveStats', JSON.stringify(stats));
        }

        function randomStart() {
            state.mode = 'fugitive'; // Explicitly set mode to fugitive
            if (!validateState()) {
                console.warn('Invalid state in randomStart, resetting king');
                state.king = [0, 0];
            }
            const difficulties = ['pawn', 'knight', 'rook', 'bishop', 'queen', 'king'];
            state.difficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
            state.level = Math.floor(Math.random() * 100) + 1;
            state.theme = document.getElementById('theme').value;
            state.pieceStyle = document.getElementById('piece-style').value;
            const heroKeys = Object.keys(heroes);
            const heroIndex = Math.floor(Math.random() * (heroKeys.length + 1)) - 1;
            state.hero = heroIndex >= 0 ? heroKeys[heroIndex] : null;
            state.turnTimer = Math.random() < 0.5 ? 'on' : 'off';
            state.turnLimit = ['none', '5', '10', '15'][Math.floor(Math.random() * 4)];
            state.kingDisarmed = Math.random() < 0.5 ? 'on' : 'off';
            state.guardsEnabled = Math.random() < 0.5 ? 'on' : 'off';
            state.treasureDrops = Math.random() < 0.5 ? 'on' : 'off';
            state.hiddenItems = Math.random() < 0.5 ? 'on' : 'off';
            state.heroAbility = Math.random() < 0.5 ? 'on' : 'off';
            state.fogVision = Math.random() < 0.5 ? 'on' : 'off';
            state.portals = Math.floor(Math.random() * 4);
            state.arcadeMode = Math.random() < 0.5 ? 'on' : 'off';
            document.getElementById('difficulty').value = state.difficulty;
            document.getElementById('level').value = state.level;
            document.getElementById('hero-select').value = state.hero || -1;
            document.getElementById('turn-timer').value = state.turnTimer;
            document.getElementById('turn-limit').value = state.turnLimit;
            document.getElementById('king-disarmed').value = state.kingDisarmed;
            document.getElementById('guards').value = state.guardsEnabled;
            document.getElementById('treasure-drops').value = state.treasureDrops;
            document.getElementById('hidden-items').value = state.hiddenItems;
            document.getElementById('arcade-mode').value = state.arcadeMode;
            document.getElementById('hero-ability').value = state.heroAbility;
            document.getElementById('hero-ability-creative').value = state.heroAbility;
            document.getElementById('portals').value = state.portals.toString();
            document.getElementById('level-info').textContent = `Level ${state.level}`;
            turnCount = 0;
            showSection('game-area');
            initBoard();
            updateStats();
            drawBoard();
            displayModeRules();
        }

        function rollDice() {
            if (state.phase !== 'waiting') return;
            if (!validateState()) {
                console.warn('Invalid state, resetting before rolling dice');
                initBoard();
                return;
            }
            const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
            let rollCount = 0;
            const maxRolls = 10;
            const rollInterval = setInterval(() => {
                const tempRoll = Math.floor(Math.random() * 6) + 1;
                document.getElementById(info).textContent = `Rolling... ${tempRoll}`;
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.roll.volume = state.music.sfxVolume;
                    sounds.roll.play();
                }
                rollCount++;
                if (rollCount >= maxRolls) {
                    clearInterval(rollInterval);
                    state.roll = Math.floor(Math.random() * 6) + 1;
                    state.moves = state.roll;
                    if (state.doubleMovesTurns > 0) state.moves *= 2;
                    state.rolls++;
                    state.phase = 'moving';
                    if (state.turnTimer === 'on') startTurnTimer();
                    updateStats();
                    drawBoard();
                    document.getElementById(info).textContent = `Rolled a ${state.roll}! Use arrow keys, WASD, or Q/E/Z/C to move`;
                    announce(`Rolled a ${state.roll}! Use arrow keys, WASD, or Q/E/Z/C to move`);
                    if (state.mode === 'tutorial' && tutorialSteps[tutorialStep].expectedAction === 'roll') {
                        advanceTutorial();
                    }
                }
            }, 100);
        }

        function startTurnTimer() {
            const TURN_TIME_LIMIT = 30; // seconds
            state.turnStartTime = Date.now(); // Record the turn start time in milliseconds
            const timerBar = document.getElementById('timer-bar');
            const timerProgress = document.getElementById('timer-progress');
            const timerText = document.getElementById('timer-text');
            
            // Initialize the timer display
            timerBar.style.display = 'block';
            timerProgress.style.width = '100%';
            timerText.textContent = `${TURN_TIME_LIMIT}s`;
            timerProgress.classList.remove('pulsing'); // Ensure pulsing is off at start
            
            // Start the interval to update the timer every second
            turnTimer = setInterval(() => {
                // Skip updates if the game is paused or turn hasn’t started
                if (state.paused || !state.turnStartTime) return;
                
                // Calculate elapsed time in milliseconds and remaining time in seconds
                const elapsed = Date.now() - state.turnStartTime;
                const timeLeft = Math.max(0, TURN_TIME_LIMIT - Math.floor(elapsed / 1000));
                const progress = (timeLeft / TURN_TIME_LIMIT) * 100;
                
                // Update the timer bar and text
                timerProgress.style.width = `${progress}%`;
                timerText.textContent = `${timeLeft}s`;
                
                // Handle color transitions based on remaining time
                if (timeLeft > 15) {
                    timerProgress.style.background = '#4CAF50'; // Green
                } else if (timeLeft > 5) {
                    timerProgress.style.background = '#FFD700'; // Yellow
                } else {
                    timerProgress.style.background = '#FF0000'; // Red
                    timerProgress.classList.add('pulsing'); // Add pulsing effect
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.timerTick.volume = state.music.sfxVolume;
                        sounds.timerTick.play(); // Play tick sound when time is low
                    }
                }
                
                // Check if time has run out
                if (timeLeft <= 0) {
                    clearInterval(turnTimer); // Stop the interval
                    timerBar.style.display = 'none'; // Hide the timer bar
                    timerProgress.classList.remove('pulsing'); // Remove pulsing effect
                    state.phase = 'lose'; // Set game phase to lose
                    showPrompt('Time’s up!'); // Show time-up message
                } else {
                    // Update game info with moves and time left
                    document.getElementById('game-info').textContent = 
                        `Moves: ${state.moves}. Use arrow keys or WASD to move | Time left: ${timeLeft}s`;
                }
            }, 1000); // Run every 1000 milliseconds (1 second)
        }

        function replayLevel() {
            const customPrompt = document.getElementById('custom-prompt');
            if (customPrompt) {
                customPrompt.style.display = 'none';
            } else {
                console.warn('Element with id "custom-prompt" not found.');
            }
            turnCount = 0;
            initBoard();
            updateStats();
            drawBoard();
            displayModeRules();
        }

        function nextLevel() {
            const customPrompt = document.getElementById('custom-prompt');
            if (customPrompt) {
                customPrompt.style.display = 'none';
            } else {
                console.warn('Element with id "custom-prompt" not found.');
            }
            state.levels++;
            stats.wins++;
            stats.totalMoves += state.moves;
            stats.totalRolls += state.rolls;
            stats.guardsDefeated += state.guards;
            stats.treasuresCollected += state.collectedTreasures.length;
            if (state.arcadeMode === 'on' && state.score > stats.highestScore) {
                stats.highestScore = state.score;
            }
            turnCount = 0;
            
            if (isCampaignMode) {
                const progress = loadCampaignProgress();
                const currentPrison = getCurrentPrison(progress);
                completePrison(progress, currentPrison);
                const currentIndex = progress.prisons.findIndex(p => p.name === currentPrison);
                if (currentIndex + 1 < progress.prisons.length) {
                    showCampaignCompletionScreen(currentPrison);
                } else {
                    alert("Congratulations! You’ve completed the campaign!");
                    showSection('fugitive-menu');
                }
            } else if (state.level >= 100) {
                updateLeaderboard();
                showSection('fugitive-menu');
                document.getElementById('level-info').textContent = 'You won all levels! Pick a new one';
                autosaveGame();
            } else {
                updateLeaderboard();
                state.level++;
                document.getElementById('level').value = state.level;
                initBoard();
                updateStats();
                state.forceRedraw = true;
                drawBoard();
                displayModeRules();
                autosaveGame();
            }
            
            globalStats.levelsCompleted++;
            globalStats.treasuresCollected += state.collectedTreasures.length;
            globalStats.guardsDefeated += state.guards;
            localStorage.setItem('fugitiveGlobalStats', JSON.stringify(globalStats));
            if (globalStats.levelsCompleted >= 50) unlockAchievement('level-conqueror');
            if (globalStats.treasuresCollected >= 100) unlockAchievement('treasure-hoarder');
            if (globalStats.guardsDefeated >= 100) unlockAchievement('guard-nemesis');
            if (!state.playerName) {
                state.playerName = prompt('Enter your name for the leaderboard:', 'Player') || 'Anonymous';
            }
            leaderboard.push({ name: state.playerName, score: state.score, level: state.level });
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard.splice(10); // Keep top 10
            localStorage.setItem('fugitiveLeaderboard', JSON.stringify(leaderboard));
        }

        function resetLevel() {
            if (confirm('Are you sure you want to reset the level? All progress will be lost.')) {
                turnCount = 0;
                initBoard();
                updateStats();
                drawBoard();
                displayModeRules();
                showMessage('Level reset!');
            }
        }

        function restartLevel() {
            if (confirm('Are you sure you want to restart the level?')) {
                if (state.initial) {
                    state.king = [...state.initial.king];
                    state.jail = [...state.initial.jail];
                    state.escape = [...state.initial.escape];
                    state.opponents = JSON.parse(JSON.stringify(state.initial.opponents));
                    state.blocked = JSON.parse(JSON.stringify(state.initial.blocked));
                    state.treasures = JSON.parse(JSON.stringify(state.initial.treasures));
                    state.pointItems = JSON.parse(JSON.stringify(state.initial.pointItems));
                    state.collectedTreasures = [];
                    state.roll = 0;
                    state.moves = 0;
                    state.phase = 'waiting';
                    turnCount = 0;
                    drawBoard();
                    const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                    document.getElementById(info).textContent = 'Press Space to roll dice';
                    updateStats();
                    displayModeRules();
                }
            }
        }

        function initializeStandardBoard() {
            const board = standardState.board;
            // Clear board
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    board[row][col] = null;
                }
            }
            // Pawns
            for (let col = 0; col < 8; col++) {
                board[6][col] = { type: 'pawn', color: 'white' };   // White pawns on row 6
                board[1][col] = { type: 'pawn', color: 'black' };   // Black pawns on row 1
            }
            // Rooks
            board[7][0] = board[7][7] = { type: 'rook', color: 'white' };   // White rooks on row 7
            board[0][0] = board[0][7] = { type: 'rook', color: 'black' };   // Black rooks on row 0
            // Knights
            board[7][1] = board[7][6] = { type: 'knight', color: 'white' };
            board[0][1] = board[0][6] = { type: 'knight', color: 'black' };
            // Bishops
            board[7][2] = board[7][5] = { type: 'bishop', color: 'white' };
            board[0][2] = board[0][5] = { type: 'bishop', color: 'black' };
            // Queens
            board[7][3] = { type: 'queen', color: 'white' };
            board[0][3] = { type: 'queen', color: 'black' };
            // Kings
            board[7][4] = { type: 'king', color: 'white' };
            board[0][4] = { type: 'king', color: 'black' };

            standardState.turn = 'white';
            standardState.selected = null;
            standardState.validMoves = [];
            standardState.castling = { 
                white: { king: true, kingRook: true, queenRook: true }, 
                black: { king: true, kingRook: true, queenRook: true } 
            };
            standardState.enPassant = null;
            standardState.whiteTime = 600;
            standardState.blackTime = 600;
        }

        function initBoard() {
            moveHistory = [];
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            if (!currentCtx) return;
            shuffleAvailableSquares();
            state.level = Math.max(1, Math.min(state.level, 100));
            let pathExists = false;
            let attempts = 0;
            const maxAttempts = 50;
            let blockCount = blocks[state.difficulty] || 8;

            do {
                state.opponents = [];
                state.blocked = [];
                state.treasures = [];
                state.collectedTreasures = [];
                state.roll = 0;
                state.moves = 0;
                state.phase = 'waiting';
                state.isStealth = false;
                state.selectingGuard = false;
                state.isSwapping = false;
                state.selectingTeleport = false;
                state.hasResurrection = false;
                state.wisdomActive = false;
                state.invincible = false;
                state.revealGuardVision = false;
                state.hiddenItemsOverride = false;
                state.canFly = false;
                state.seeThroughWalls = false;
                state.isDefeating = false;
                state.isRangedAttack = false;
                state.hintEnabled = document.getElementById('move-hints').value;
                const occupied = [];
                const levelData = levels[state.level - 1] || { pawns: 3, rooks: 0, knights: 0, bishops: 0, queen: 0 };

                state.jail = getRandomSquare(occupied) || [0, 0];
                occupied.push(state.jail);
                state.king = [...state.jail];
                occupied.push(state.king);

                state.escape = getRandomSquare(occupied, [state.jail]) || [7, 7];
                let jailEscapeAttempts = 0;
                do {
                    state.escape = getRandomSquare(occupied) || [7, 7];
                    jailEscapeAttempts++;
                    if (jailEscapeAttempts > 50) {
                        state.escape = [state.jail[0] > 3 ? 0 : 7, state.jail[1] > 3 ? 0 : 7];
                        break;
                    }
                } while (manhattanDistance(state.jail, state.escape) < 7);
                occupied.push(state.escape);

                for (let i = 0; i < blockCount; i++) {
                    const pos = getRandomSquare(occupied);
                    if (pos) {
                        state.blocked.push(pos);
                        occupied.push(pos);
                    } else {
                        console.warn(`Could not place blocked square ${i + 1}/${blockCount} - board full`);
                        break;
                    }
                }

                if (state.guardsEnabled === 'on') {
                    // Define guard counts by difficulty
                    const guardCounts = {
                        'pawn': 3,
                        'knight': 4,
                        'rook': 5,
                        'bishop': 6,
                        'queen': 7,
                        'king': 8
                    };
                    const numGuards = guardCounts[state.difficulty.toLowerCase()] || 3; // Default to 3 if difficulty invalid
                    console.log(`Generating ${numGuards} guards for difficulty: ${state.difficulty}`);

                    // Determine guard types based on difficulty
                    const guardTypes = ['pawn', 'knight', 'rook', 'bishop', 'queen'];
                    let typeWeights = { pawn: 0.5, knight: 0.2, rook: 0.15, bishop: 0.1, queen: 0.05 };
                    if (state.difficulty === 'knight') {
                        typeWeights = { pawn: 0.4, knight: 0.3, rook: 0.15, bishop: 0.1, queen: 0.05 };
                    } else if (state.difficulty === 'rook') {
                        typeWeights = { pawn: 0.3, knight: 0.25, rook: 0.25, bishop: 0.15, queen: 0.05 };
                    } else if (state.difficulty === 'bishop') {
                        typeWeights = { pawn: 0.25, knight: 0.2, rook: 0.2, bishop: 0.25, queen: 0.1 };
                    } else if (state.difficulty === 'queen') {
                        typeWeights = { pawn: 0.2, knight: 0.15, rook: 0.15, bishop: 0.25, queen: 0.25 };
                    } else if (state.difficulty === 'king') {
                        typeWeights = { pawn: 0.15, knight: 0.15, rook: 0.15, bishop: 0.2, queen: 0.35 };
                    }

                    // Generate guard types
                    const opponentTypes = [];
                    for (let i = 0; i < numGuards; i++) {
                        const rand = Math.random();
                        let cumulative = 0;
                        for (const type of guardTypes) {
                            cumulative += typeWeights[type];
                            if (rand <= cumulative) {
                                opponentTypes.push(type);
                                break;
                            }
                        }
                    }

                    // Place guards
                    for (const type of opponentTypes) {
                        const pos = getRandomSquare(occupied);
                        if (!pos) {
                            console.warn(`Could not place opponent ${type} - board full`);
                            continue;
                        }
                        const behaviors = ['chase', 'patrol', 'aggressive', 'defensive', 'stationary', 'intelligent'];
                        const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                        let patrolRoute = null;
                        if (behavior === 'patrol') {
                            const patrolPoints = Math.min(2, Math.floor(Math.random() * 3)); // 0-2 additional points
                            patrolRoute = [pos];
                            for (let i = 0; i < patrolPoints; i++) {
                                const nextPos = getRandomSquare(occupied);
                                if (nextPos) {
                                    patrolRoute.push(nextPos);
                                    occupied.push(nextPos);
                                } else {
                                    break;
                                }
                            }
                        }
                        state.opponents.push({ 
                            type, 
                            pos, 
                            behavior, 
                            patrolRoute, 
                            patrolIndex: 0,
                            distracted: false, 
                            peaceful: false, 
                            stunned: false, 
                            visionDisrupted: false,
                            vision: getGuardVision({ type, pos })
                        });
                        occupied.push(pos);
                    }
                    console.log(`Placed ${state.opponents.length} guards`);
                }

                if (state.treasureDrops === 'on') {
                    const treasureKeys = Object.keys(treasures);
                    for (let i = 0; i < 3; i++) {
                        const treasureType = treasureKeys[Math.floor(Math.random() * treasureKeys.length)];
                        const pos = getRandomSquare(occupied) || [0, 0];
                        state.treasures.push({ type: treasureType, pos });
                        occupied.push(pos);
                    }
                }
                if (state.arcadeMode === 'on') {
                    const pointTypes = ['①', '⑤', '⑩'];
                    for (let i = 0; i < 3; i++) {
                        const type = pointTypes[Math.floor(Math.random() * pointTypes.length)];
                        const pos = getRandomSquare(occupied) || [0, 0];
                        state.pointItems.push({ type, pos });
                        occupied.push(pos);
                    }
                }

                state.portalsList = [];
                for (let i = 0; i < state.portals; i++) {
                    const portal1 = getRandomSquare(occupied, [state.jail, state.escape]);
                    if (!portal1) break;
                    occupied.push(portal1);
                    const portal2 = getRandomSquare(occupied, [state.jail, state.escape]);
                    if (!portal2) break;
                    occupied.push(portal2);
                    state.portalsList.push([portal1, portal2]);
                }

                pathExists = hasPathToEscape();
                attempts++;
                if (attempts >= maxAttempts && !pathExists) {
                    console.warn('Max attempts reached. Reducing blocked squares.');
                    blockCount = Math.max(0, blockCount - 1);
                    attempts = 0;
                    state.blocked = [];
                    occupied.length = 3;
                }
            } while (!pathExists && blockCount > 0);

            state.initial = {
                king: [...state.king],
                jail: [...state.jail],
                escape: [...state.escape],
                opponents: JSON.parse(JSON.stringify(state.opponents)),
                blocked: JSON.parse(JSON.stringify(state.blocked)),
                treasures: JSON.parse(JSON.stringify(state.treasures)),
                portalsList: JSON.parse(JSON.stringify(state.portalsList)),
                pointItems: JSON.parse(JSON.stringify(state.pointItems))
            };

            drawBoard();
            const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
            document.getElementById(info).textContent = 'Press Space to roll dice';
            updateStats();
            displayModeRules();
        }

        function resetStandardState() {
            console.log('Resetting standardState.moveHistory'); // Debug log
            standardState.moveHistory = []; // Explicitly reset first
            initializeStandardBoard();
            Object.assign(standardState, {
                turn: 'white',
                selected: null,
                validMoves: [],
                whiteTime: 600,
                blackTime: 600,
                cursorRow: 0,
                cursorCol: 0,
                lastMove: null,
                capturedWhite: [],
                capturedBlack: []
            });
            console.log('After reset, moveHistory length:', standardState.moveHistory.length); // Verify
        }

        function getValidMoves() {
            if (!state.king) {
                console.warn('King position is undefined, returning empty moves.');
                return [];
            }
            const moves = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];
            const [kingRow, kingCol] = state.king;
            for (const [dr, dc] of directions) {
                const row = kingRow + dr;
                const col = kingCol + dc;
                if (row >= 0 && row < BOARD && col >= 0 && col < BOARD) {
                    if (state.canPhase > 0 || !state.blocked.some(b => b[0] === row && b[1] === col)) {
                        if (
                            (row === state.escape[0] && col === state.escape[1]) ||
                            state.treasures.some(t => t.pos[0] === row && t.pos[1] === col) ||
                            state.pointItems.some(item => item.pos[0] === row && item.pos[1] === col) ||
                            state.portalsList.some(pair => pair.some(p => p[0] === row && p[1] === col)) ||
                            (!isSquareOccupied(row, col) && !(row === state.escape[0] && col === state.escape[1])) ||
                            (state.mode === 'creative' && creativeState.terrain?.water.some(w => w[0] === row && w[1] === col)) ||
                            (state.mode !== 'creative' && state.terrain?.water.some(w => w[0] === row && w[1] === col))
                        ) {
                            moves.push([row, col]);
                        }
                        if (state.opponents.some(op => op.pos[0] === row && op.pos[1] === col) && state.kingDisarmed === 'off') {
                            moves.push([row, col]);
                        }
                    }
                }
            }
            return moves;
        }

        function getGuardVision(guard) {
            if (guard.visionDisabled || guard.visionDisrupted) return [];
            const vision = [];
            const [row, col] = guard.pos;

            function addVisionInDirection(dr, dc) {
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < BOARD && c >= 0 && c < BOARD) {
                    if (state.blocked.some(b => b[0] === r && b[1] === c) || 
                        (state.mode === 'creative' && creativeState.terrain?.forest.some(f => f[0] === r && f[1] === c)) ||
                        (state.mode !== 'creative' && state.terrain?.forest.some(f => f[0] === r && f[1] === c))) {
                        break;
                    }
                    vision.push([r, c]);
                    r += dr;
                    c += dc;
                }
            }

            switch (guard.type) {
                case 'pawn':
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]].forEach(([dr, dc]) => {
                        const r = row + dr;
                        const c = col + dc;
                        if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                            !state.blocked.some(b => b[0] === r && b[1] === c)) {
                            vision.push([r, c]);
                        }
                    });
                    break;
                case 'rook':
                    addVisionInDirection(-1, 0);
                    addVisionInDirection(1, 0);
                    addVisionInDirection(0, -1);
                    addVisionInDirection(0, 1);
                    break;
                case 'knight':
                    [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => {
                        const r = row + dr;
                        const c = col + dc;
                        if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                            !state.blocked.some(b => b[0] === r && b[1] === c)) {
                            vision.push([r, c]);
                        }
                    });
                    break;
                case 'bishop':
                    addVisionInDirection(-1, -1);
                    addVisionInDirection(-1, 1);
                    addVisionInDirection(1, -1);
                    addVisionInDirection(1, 1);
                    break;
                case 'queen':
                    addVisionInDirection(-1, 0);
                    addVisionInDirection(1, 0);
                    addVisionInDirection(0, -1);
                    addVisionInDirection(0, 1);
                    addVisionInDirection(-1, -1);
                    addVisionInDirection(-1, 1);
                    addVisionInDirection(1, -1);
                    addVisionInDirection(1, 1);
                    break;
                case 'sentry':
                    for (let dr = -2; dr <= 2; dr++) {
                        for (let dc = -2; dc <= 2; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const r = row + dr;
                            const c = col + dc;
                            if (r >= 0 && r < BOARD && c >= 0 && c < BOARD && 
                                !state.blocked.some(b => b[0] === r && b[1] === c)) {
                                vision.push([r, c]);
                            }
                        }
                    }
                    break;
            }
            return vision;
        }

        function getKingVision() {
            const vision = [];
            const [kingRow, kingCol] = state.king;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const r = kingRow + dr;
                    const c = kingCol + dc;
                    if (r >= 0 && r < BOARD && c >= 0 && c < BOARD) vision.push([r, c]);
                }
            }
            return vision;
        }

        function checkGuards() {
            if (state.guardsEnabled === 'off' || state.phase === 'win' || state.invincible || state.isStealth || state.invisible) return;
            let caught = false;
            let capturingGuard = null;
            state.opponents.forEach(op => {
                if (op.peaceful) return;
                if (op.vision.some(([r, c]) => r === state.king[0] && c === state.king[1])) {
                    caught = true;
                    capturingGuard = op;
                }
            });
            if (caught) {
                if (state.hasResurrection) {
                    state.hasResurrection = false;
                    state.king = [...state.jail];
                    const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                    document.getElementById(info).textContent = 'Jesus revives you at the jail!';
                    drawBoard();
                    updateStats();
                } else if (state.animations === 'on' && capturingGuard) {
                    animateGuardCapture(capturingGuard.pos, state.king);
                } else {
                    state.phase = 'lose';
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.lose.volume = state.music.sfxVolume;
                        sounds.lose.play();
                    }
                    showPrompt('A guard caught you!');
                }
            }
        }

        function enemyTurn() {
            if (state.guardsEnabled === 'off') return;
            state.opponents.forEach(guard => {
                if (guard.stunned) {
                    guard.stunned = false;
                    return;
                }
                if (!guard.distracted) moveGuard(guard);
            });
            drawBoard();
        }

        function aStarGuard(start, goal, guard) {
            const openSet = [start];
            const cameFrom = {};
            const gScore = { [start]: 0 };
            const fScore = { [start]: manhattanDistance(start, goal) };

            while (openSet.length > 0) {
                openSet.sort((a, b) => (fScore[a] || Infinity) - (fScore[b] || Infinity));
                const current = openSet.shift();

                if (current[0] === goal[0] && current[1] === goal[1]) {
                    const path = [];
                    let temp = current;
                    while (temp) {
                        path.push(temp);
                        temp = cameFrom[temp];
                    }
                    return path.reverse();
                }

                const neighbors = getGuardNeighbors(current, guard);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore[current] + 1;
                    if (!(neighbor in gScore) || tentativeGScore < gScore[neighbor]) {
                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + manhattanDistance(neighbor, goal);
                        if (!openSet.some(pos => pos[0] === neighbor[0] && pos[1] === neighbor[1])) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null; // No path found
        }

        function getGuardNeighbors(pos, guard) {
            const [row, col] = pos;
            const directions = guard.type === 'knight' ? [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]
            ] : [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];
            const neighbors = [];
            for (const [dr, dc] of directions) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                    !state.blocked.some(b => b[0] === r && b[1] === c) &&
                    !state.opponents.some(op => op.pos[0] === r && op.pos[1] === c && op !== guard)) {
                    neighbors.push([r, c]);
                }
            }
            return neighbors;
        }

        function moveGuard(guard) {
            const aggressionMap = { low: 0.3, medium: 0.6, high: 1.0 };
            if (Math.random() > aggressionMap[state.guardAggression]) return;
            if (guard.distracted || guard.stunned || guard.peaceful || guard.skipTurn) {
                guard.skipTurn = false; // Reset after skipping
                return;
            }

            let target;
            if (state.decoyTurns > 0 && state.decoyPos) {
                target = state.decoyPos;
            } else {
                target = state.king;
            }
            const kingPos = state.king;
            if (guard.behavior === 'patrol' && guard.patrolRoute && guard.patrolRoute.length > 1) {
                guard.patrolIndex = (guard.patrolIndex + 1) % guard.patrolRoute.length;
                target = guard.patrolRoute[guard.patrolIndex];
            } else if (guard.behavior === 'aggressive') {
                const moves = getGuardMoves(guard);
                target = moves.length > 0 ? moves[0] : guard.pos;
            } else if (guard.behavior === 'defensive') {
                const pathToEscape = aStarGuard(guard.pos, state.escape, guard);
                target = pathToEscape && pathToEscape.length > 1 ? pathToEscape[1] : guard.pos;
            } else if (guard.behavior === 'stationary') {
                return;
            } else if (guard.behavior === 'intelligent') {
                const path = aStarGuard(guard, target);
                target = path && path.length > 1 ? path[1] : guard.pos;
            } else { // 'chase' behavior uses A*
                const path = aStarGuard(guard.pos, kingPos, guard);
                target = path && path.length > 1 ? path[1] : guard.pos;
            }

            if (!isSquareOccupied(target[0], target[1]) && 
                !state.blocked.some(b => b[0] === target[0] && b[1] === target[1])) {
                const startX = guard.pos[1] * SQUARE;
                const startY = guard.pos[0] * SQUARE;
                const endX = target[1] * SQUARE;
                const endY = target[0] * SQUARE;

                if (state.animations === 'on' && state.music.animations === 'on') {
                    let progress = 0;
                    function animate() {
                        progress += 0.1;
                        const currentX = startX + (endX - startX) * progress;
                        const currentY = startY + (endY - startY) * progress;
                        guard.animatedPixelCenter = [currentX + SQUARE / 2, currentY + SQUARE / 2];
                        drawBoard();
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            guard.pos = target;
                            guard.vision = getGuardVision(guard);
                            guard.animatedPixelCenter = null;
                            drawBoard();
                        }
                    }
                    requestAnimationFrame(animate);
                } else {
                    guard.pos = target;
                    guard.vision = getGuardVision(guard);
                    drawBoard();
                }
            }
        }

        function saveStateForUndo() {
            moveHistory.push({
                king: [...state.king],
                opponents: state.opponents.map(op => ({ ...op, pos: [...op.pos] })),
                treasures: state.treasures.map(t => ({ ...t, pos: [...t.pos] })),
                moves: state.moves,
                phase: state.phase,
                roll: state.roll,
                guards: state.guards,
                score: state.score,
                portalsList: state.portalsList.map(pair => pair.map(p => [...p]))
            });
        }

        function moveKing(row, col) {
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep].expectedPosition && 
                (row !== tutorialSteps[tutorialStep].expectedPosition[0] || col !== tutorialSteps[tutorialStep].expectedPosition[1])) {
                document.getElementById('tutorial-info').textContent = 'Follow the tutorial: Move to the highlighted square!';
                flashInvalidSquare(row, col);
                return;
            }
            const validMoves = getValidMoves();
            if (!validMoves.some(m => m[0] === row && m[1] === col)) {
                flashInvalidSquare(row, col);
                const reason = state.blocked.some(b => b[0] === row && b[1] === col) ? 'Blocked by wall' :
                              state.opponents.some(op => op.pos[0] === row && op.pos[1] === col) && state.kingDisarmed === 'on' ? 'Guard present (King Disarmed)' :
                              'Out of range or invalid';
                document.getElementById('game-info').textContent = `Invalid move: ${reason}. Use arrow keys or WASD`;
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.invalid.volume = state.music.sfxVolume;
                    sounds.invalid.play();
                }
                return;
            }
            saveStateForUndo();
            const startPos = [...state.king];
            if (state.animations === 'on') {
                animateKingMove(startPos, [row, col], () => performMove(row, col));
                animateMoveIndicator(startPos, [row, col]);
                applyTerrainEffects(row, col);
            } else {
                performMove(row, col);
                animateMoveIndicator(startPos, [row, col]);
                applyTerrainEffects(row, col);
            }
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep].expectedPosition &&
                row === tutorialSteps[tutorialStep].expectedPosition[0] &&
                col === tutorialSteps[tutorialStep].expectedPosition[1]) {
                advanceTutorial();
            }
        }

        function animateGuardCapture(guardPos, kingPos) {
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            const startX = guardPos[1] * SQUARE;
            const startY = guardPos[0] * SQUARE;
            const endX = kingPos[1] * SQUARE;
            const endY = kingPos[0] * SQUARE;
            let progress = 0;
            const theme = themes[state.theme] || themes.light;
            const pieceStyle = pieceStyles[state.pieceStyle] || pieceStyles.classic;

            function animate() {
                progress += 0.05;
                currentCtx.clearRect(0, 0, BOARD * SQUARE, BOARD * SQUARE);
                drawBoard(); // Redraw base board
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                currentCtx.font = `28px ${theme.font}`;
                currentCtx.fillStyle = theme.btn;
                currentCtx.textAlign = 'center';
                currentCtx.textBaseline = 'middle';
                currentCtx.fillText(pieceStyle[guard.type], currentX + SQUARE / 2, currentY + SQUARE / 2);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    state.phase = 'lose';
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.lose.volume = state.music.sfxVolume;
                        sounds.lose.play();
                    }
                    showPrompt('A guard caught you!');
                }
            }
            requestAnimationFrame(animate);
        }

        let lastMoveState = null;
        function undoMove() {
            if (moveHistory.length > 0) {
                const lastState = moveHistory.pop();
                Object.assign(state, lastState);
                drawBoard();
                const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                document.getElementById(info).textContent = state.phase === 'waiting' ? 'Press Space to roll dice' : `Moves: ${state.moves}. Use arrow keys or WASD to move`;
                showMessage('Move undone');
            } else {
                alert('No moves to undo!');
            }
        }

        function performMove(row, col) {
            saveStateForUndo();
            const startPos = [...state.king];
            let target = [row, col];
            const startSquare = `${startPos[0] + 1},${startPos[1] + 1}`;
            
            if (state.portals > 0) {
                const linked = getLinkedPortal(target);
                if (linked) {
                    if (isSquareOccupied(linked[0], linked[1])) {
                        document.getElementById('game-info').textContent = 'Portal destination is occupied!';
                        state.invalidSquare = target;
                        setTimeout(() => {
                            state.invalidSquare = null;
                            drawBoard();
                        }, 500);
                        announceDetailed('Move aborted', `Portal at ${target[0] + 1},${target[1] + 1} leads to occupied square ${linked[0] + 1},${linked[1] + 1}`);
                        return;
                    }
                    target = linked;
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.teleport.volume = state.music.sfxVolume;
                        sounds.teleport.play();
                    }
                }
            }
            
            if (state.canPhase > 0 && state.blocked.some(b => b[0] === target[0] && b[1] === target[1])) {
                state.canPhase--;
                announceDetailed('King phased through wall', `Moved from ${startSquare} to ${target[0] + 1},${target[1] + 1}`);
            }
            
            const opponentIndex = state.opponents.findIndex(op => op.pos[0] === target[0] && op.pos[1] === target[1]);
            
            if (opponentIndex !== -1 && state.kingDisarmed === 'off') {
                const guardType = state.opponents[opponentIndex].type;
                state.opponents.splice(opponentIndex, 1);
                if (state.animations === 'on') animateCapture(target);
                state.guards++;
                state.score += 10;
                if (state.arcadeMode === 'on') state.score += 10;
                state.king = target;
                if (state.canPhase > 0 && state.blocked.some(b => b[0] === target[0] && b[1] === target[1])) {
                    state.canPhase--;
                }
                if (state.windwalkTurns > 0) return true;
                state.moves--;
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.capture.volume = state.music.sfxVolume;
                    sounds.capture.play();
                }
                announceDetailed('Guard defeated', `${guardType.charAt(0).toUpperCase() + guardType.slice(1)} at ${target[0] + 1},${target[1] + 1}. Moves left: ${state.moves}`);
                if (state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) {
                    state.phase = 'win';
                    state.score += 100 - turnCount * 5;
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.win.volume = state.music.sfxVolume;
                        sounds.win.play();
                    }
                    showPrompt('You reached the safe spot!');
                } else {
                    checkGuards();
                    if (state.phase !== 'lose') {
                        if (state.moves > 0) {
                            const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                            document.getElementById(info).textContent = `Moves: ${state.moves}. Use arrow keys, WASD, or Q/E/Z/C to move`;
                        } else {
                            endPlayerTurn();
                        }
                    }
                }
            } else if (opponentIndex === -1) {
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.move.volume = state.music.sfxVolume;
                    sounds.move.play();
                }
                
                const treasureIndex = state.treasures.findIndex(t => t.pos[0] === target[0] && t.pos[1] === target[1]);
                if (treasureIndex !== -1) {
                    const treasure = state.treasures[treasureIndex];
                    state.treasures.splice(treasureIndex, 1);
                    state.collectedTreasures.push(treasure);
                    state.score += 5;
                    if (state.animations === 'on') animateTreasureCollection(target);
                    else state.highlightSquare = target;
                    setTimeout(() => {
                        state.highlightSquare = null;
                        drawBoard();
                    }, 500);
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.collect.volume = state.music.sfxVolume;
                        sounds.collect.play();
                    }
                    applyTreasureEffect(treasure);
                    announceDetailed('Treasure collected', `${treasure.type.charAt(0).toUpperCase() + treasure.type.slice(1)} at ${target[0] + 1},${target[1] + 1}: ${treasures[treasure.type].description}`);
                    if (state.mode === 'tutorial' && tutorialSteps[tutorialStep].trigger === 'collect') advanceTutorial();
                }
                
                if (state.arcadeMode === 'on') {
                    const pointItemIndex = state.pointItems.findIndex(item => item.pos[0] === target[0] && item.pos[1] === target[1]);
                    if (pointItemIndex !== -1) {
                        const item = state.pointItems[pointItemIndex];
                        state.score += points[item.type];
                        state.pointItems.splice(pointItemIndex, 1);
                        announceDetailed('Points collected', `${points[item.type]} points at ${target[0] + 1},${target[1] + 1}`);
                    }
                }
                
                if (state.animations === 'on') {
                    animateKingMove(startPos, target);
                } else {
                    state.king = target;
                    drawBoard();
                    announceDetailed('King moved', `From ${startSquare} to ${target[0] + 1},${target[1] + 1}. Moves remaining: ${state.moves - 1}`);
                    if (state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) {
                        state.phase = 'win';
                        state.score += 100 - turnCount * 5;
                        if (!state.music.isMuted && state.music.sfxVolume > 0) {
                            sounds.win.volume = state.music.sfxVolume;
                            sounds.win.play();
                        }
                        showPrompt('You reached the safe spot!');
                    } else {
                        state.moves--;
                        checkGuards();
                        if (state.phase !== 'lose') {
                            if (state.moves > 0) {
                                const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                                document.getElementById(info).textContent = `Moves: ${state.moves}. Use arrow keys or WASD to move`;
                            } else {
                                endPlayerTurn();
                            }
                        }
                    }
                }
            }
            
            updateStats();
            drawBoard();
        }

        function animateKingMove(start, end, callback) {
            const startTime = performance.now();
            const duration = 500; // 500ms animation
            const startX = start[1] * SQUARE;
            const startY = start[0] * SQUARE;
            const endX = end[1] * SQUARE;
            const endY = end[0] * SQUARE;

            function step(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                state.kingAnimatedPixelCenter = [currentX + SQUARE / 2, currentY + SQUARE / 2];
                drawBoard();
                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    state.kingAnimatedPixelCenter = null;
                    state.king = end;
                    callback();
                }
            }
            requestAnimationFrame(step);
        }

        function saveStateForUndo() {
            moveHistory.push({
                king: [...state.king],
                opponents: JSON.parse(JSON.stringify(state.opponents)),
                treasures: JSON.parse(JSON.stringify(state.treasures)),
                pointItems: JSON.parse(JSON.stringify(state.pointItems)),
                moves: state.moves,
                phase: state.phase,
                roll: state.roll,
                guards: state.guards,
                score: state.score,
                collectedTreasures: [...state.collectedTreasures],
                isStealth: state.isStealth,
                invincible: state.invincible
            });
        }

        function endPlayerTurn() {
            clearInterval(turnTimer);
            document.getElementById('timer-bar').style.display = 'none';
            state.phase = 'waiting';
            turnCount++;
            if (state.heroCooldown > 0) state.heroCooldown--;
            if (state.turnLimit !== 'none' && turnCount >= parseInt(state.turnLimit)) {
                state.phase = 'lose';
                if (!state.music.isMuted) sounds.lose.play();
                showPrompt('Turn limit reached!');
                return;
            }
            if (state.guardsEnabled === 'on') enemyTurn();
            checkGuards();
            if (state.phase !== 'lose') {
                const info = state.mode === 'tutorial' ? 'tutorial-info' : 'game-info';
                let message = 'Press Space to roll dice';
                if (state.heroAbility === 'on' && state.hero) {
                    message += ' | Press H to use hero ability';
                }
                document.getElementById(info).textContent = message;
            }
            if (state.invisibilityTurns > 0) {
                state.invisibilityTurns--;
                if (state.invisibilityTurns === 0) {
                    state.invisible = false;
                    document.getElementById('game-info').textContent += ' Invisibility has worn off!';
                }
            }
            if (state.fogDisabledTurns > 0) {
                state.fogDisabledTurns--;
                if (state.fogDisabledTurns === 0) {
                    document.getElementById('game-info').textContent += ' Fog vision is back!';
                }
            }
            if (state.freezeTurns > 0) {
                state.freezeTurns--;
                if (state.freezeTurns === 0) {
                    state.opponents.forEach(op => op.stunned = false);
                    document.getElementById('game-info').textContent += ' Guards are no longer frozen!';
                }
            }
            state.isStealth = false;
            state.wisdomActive = false;
            state.revealGuardVision = false;
            state.hiddenItemsOverride = false;
            state.canFly = false;
            state.seeThroughWalls = false;
            state.revealGuardVision = false;
            state.opponents.forEach(op => {
                op.distracted = false;
                op.peaceful = false;
                op.stunned = false;
                op.visionDisrupted = false;
                op.visionDisabled = false;
            });
            if (state.invincibleTurns > 0) {
                state.invincibleTurns--;
                if (state.invincibleTurns === 0) {
                    state.invincible = false;
                    document.getElementById('game-info').textContent += ' Invincibility has worn off!';
                }
            }
            if (state.doubleMovesTurns > 0) {
                state.doubleMovesTurns--;
                if (state.doubleMovesTurns === 0) {
                    document.getElementById('game-info').textContent += ' Double moves effect has ended.';
                }
            }
            if (state.decoyTurns > 0) state.decoyTurns--;
            if (state.revealTurns > 0) state.revealTurns--;
            updateStats();
            checkAchievements();
            updateHeroAbilityUI();
        }

        function showFugitiveHint() {
            if (state.phase !== 'moving' || state.mode !== 'fugitive') return;
            const path = aStar(state.king, state.escape);
            if (path && path.length > 1) {
                state.hintSquare = path[1]; // Next move
                drawBoard();
                setTimeout(() => {
                    state.hintSquare = null;
                    drawBoard();
                }, 2000);
                document.getElementById('game-info').textContent = `Hint: Move to (${path[1][0] + 1}, ${path[1][1] + 1})`;
            } else {
                document.getElementById('game-info').textContent = 'No path to escape available!';
            }
        }

        function togglePauseGame() {
            if (state.paused) {
                state.paused = false;
                document.getElementById('btn-pause-game').textContent = 'Pause';
                document.getElementById('paused-overlay').style.display = 'none';
                if (state.turnTimer === 'on' && state.phase === 'moving') {
                    startTurnTimer();
                }
            } else {
                state.paused = true;
                document.getElementById('btn-pause-game').textContent = 'Resume';
                document.getElementById('paused-overlay').style.display = 'block';
                clearInterval(turnTimer);
            }
        }

        // Event listeners for pause overlay buttons
        document.getElementById('btn-resume-game').addEventListener('click', togglePauseGame);
        document.getElementById('btn-save-from-pause').addEventListener('click', () => {
            saveGame();
            togglePauseGame();
            showMessage('Game saved from pause!');
        });
        document.getElementById('btn-load-from-pause').addEventListener('click', () => {
            loadGame();
            togglePauseGame();
            drawBoard();
            showMessage('Game loaded from pause!');
        });
        document.getElementById('btn-menu-from-pause').addEventListener('click', () => {
            state.paused = false;
            showSection('start-page');
        });

        function resetStandardChess() {
            console.log('Resetting chess game'); // Debug log
            standardState.moveHistory = []; // Additional safeguard
            resetStandardState();
            if (standardState.turnTimer === 'on') {
                startStandardTimer();
            }
            drawStandardBoard();
            updateStandardInfo();
        }

        function showMoveHints() {
            if (!state.showHintPath || state.hintEnabled === 'off' || state.mode !== 'fugitive') return [];
            const path = aStar(state.king, state.escape);
            if (!path) return [];
            if (state.hintEnabled === 'next') {
                return path.length > 1 ? [path[1]] : [];
            }
            return path.slice(1);
        }

        function updateHighScore() {
            if (state.arcadeMode === 'on') {
                const highScore = parseInt(localStorage.getItem('fugitiveHighScore') || 0, 10);
                if (state.score > highScore) {
                    localStorage.setItem('fugitiveHighScore', state.score);
                    alert(`New high score: ${state.score}!`);
                }
            }
        }

        function updateStats() {
            document.getElementById('difficulty-stat').textContent = state.difficulty.charAt(0).toUpperCase() + state.difficulty.slice(1);
            document.getElementById('rolls-stat').textContent = state.rolls;
            document.getElementById('moves-stat').textContent = state.moves;
            document.getElementById('guards-stat').textContent = state.guards;
            document.getElementById('levels-stat').textContent = state.levels;

            const avgMoves = state.rolls > 0 ? (stats.totalMoves / state.rolls).toFixed(2) : 0;
            document.getElementById('avg-moves').textContent = avgMoves;

            const treasuresPerLevel = state.levels > 0 ? (stats.treasuresCollected / state.levels).toFixed(2) : 0;
            document.getElementById('treasures-per-level').textContent = treasuresPerLevel;

            // Update dynamic game stats
            document.getElementById('turn-count').textContent = turnCount;
            document.getElementById('moves-left').textContent = state.moves;
            document.getElementById('score').textContent = state.score;

            let extraStats = '';
            if (state.turnLimit !== 'none') extraStats += `<p>Turns Left: <span id="turns-left-stat">${parseInt(state.turnLimit) - turnCount}</span></p>`;
            extraStats += `<p>Score: <span id="score-stat">${state.score}</span></p>`;
            if (state.timeAttack === 'on') {
                const minutes = Math.floor(state.timeLeft / 60);
                const seconds = Math.floor(state.timeLeft % 60);
                extraStats += `<p>Time Left: <span id="time-left-stat">${minutes}:${seconds < 10 ? '0' : ''}${seconds}</span></p>`;
            }
            if (state.arcadeMode === 'on') {
                const highScore = parseInt(localStorage.getItem('fugitiveHighScore') || 0, 10);
                extraStats += `<p>High Score: <span id="high-score-stat">${highScore}</span></p>`;
            }
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = `
                <p>Difficulty: <span id="difficulty-stat">${state.difficulty.charAt(0).toUpperCase() + state.difficulty.slice(1)}</span></p>
                <p>Rolls: <span id="rolls-stat">${state.rolls}</span></p>
                <p>Moves: <span id="moves-stat">${state.moves}</span></p>
                <p>Guards: <span id="guards-stat">${state.guards}</span></p>
                <p>Levels: <span id="levels-stat">${state.levels}</span></p>
                <p>Avg Moves/Turn: <span id="avg-moves">${avgMoves}</span></p>
                <p>Treasures/Level: <span id="treasures-per-level">${treasuresPerLevel}</span></p>
                <p>Treasures: <span id="treasures-collected-stat">0/3</span></p>
                ${extraStats}
            `;
            updateStatsDisplay();
        }

        function updateStatsDisplay() {
            document.getElementById('games-played').textContent = stats.gamesPlayed;
            document.getElementById('wins').textContent = stats.wins;
            document.getElementById('losses').textContent = stats.losses;
            document.getElementById('total-moves').textContent = stats.totalMoves;
            document.getElementById('total-rolls').textContent = stats.totalRolls;
            document.getElementById('guards-defeated').textContent = stats.guardsDefeated;
            document.getElementById('treasures-collected').textContent = stats.treasuresCollected;
            document.getElementById('highest-score').textContent = stats.highestScore;
            document.getElementById('achievements-unlocked').textContent = achievements.filter(ach => ach.achieved).length;
            const totalTime = Math.floor(stats.totalTimePlayed);
            const hours = Math.floor(totalTime / 3600);
            const minutes = Math.floor((totalTime % 3600) / 60);
            const seconds = totalTime % 60;
            document.getElementById('total-time-played').textContent = `${hours}h ${minutes}m ${seconds}s`;
        }

        function updateTurnTimerBar(timeLeft, total) {
            const percent = Math.max(0, timeLeft / total) * 100;
            document.getElementById('turn-timer-bar').style.width = percent + '%';
            document.getElementById('turn-timer-bar').style.background = percent < 30 ? 'red' : percent < 60 ? 'orange' : 'green';
        }

        function updateLeaderboardDisplay() {
            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = '';
            leaderboard.forEach((entry, index) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td style="padding: 5px; text-align: center;">${index + 1}</td>
                    <td style="padding: 5px;">${entry.name}</td>
                    <td style="padding: 5px; text-align: center;">${entry.score}</td>
                    <td style="padding: 5px; text-align: center;">${entry.level}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function calculateScore() {
            const baseScore = 1000 - (state.rolls * 10); // Fewer rolls = higher score
            const treasureBonus = state.collectedTreasures.length * 50;
            const guardBonus = state.guards * 100;
            const totalScore = Math.max(0, baseScore + treasureBonus + guardBonus);
            return totalScore;
        }

        function updateLeaderboard() {
            const score = calculateScore();
            let leaderboard = JSON.parse(localStorage.getItem('fugitiveLeaderboard')) || [];
            leaderboard.push({ score, date: new Date().toLocaleString() });
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 5); // Keep top 5 scores
            localStorage.setItem('fugitiveLeaderboard', JSON.stringify(leaderboard));
            displayLeaderboard();
        }

        function displayLeaderboard() {
            const leaderboardDiv = document.getElementById('leaderboard') || document.createElement('div');
            if (!leaderboardDiv.id) {
                leaderboardDiv.id = 'leaderboard';
                leaderboardDiv.style.marginTop = '10px';
                document.getElementById('game-area').appendChild(leaderboardDiv);
            }
            const leaderboard = JSON.parse(localStorage.getItem('fugitiveLeaderboard')) || [];
            leaderboardDiv.innerHTML = '<h3>Leaderboard</h3><ul>' +
                leaderboard.map(entry => `<li>${entry.score} - ${entry.date}</li>`).join('') +
                '</ul>';
        }

        function showPrompt(content) {
            clearInterval(turnTimer);
            const customPromptText = document.getElementById('custom-prompt-text');
            if (customPromptText) {
                let displayContent = content;
                if (state.phase === 'win' && !isCampaignMode) {
                    const movesTaken = state.rolls > 0 ? state.moves : 0;
                    displayContent += `\nLevel ${state.level} completed!\nMoves: ${movesTaken}\nTreasures Collected: ${state.collectedTreasures.length}\nGuards Defeated: ${state.guards}\nScore: ${state.score}`;
                }
                customPromptText.textContent = displayContent;
            } else {
                console.warn('Custom prompt text element not found.');
            }
            const btnCustomReplay = document.getElementById('btn-custom-replay');
            const btnCustomNext = document.getElementById('btn-custom-next');
            const btnCustomMenu = document.getElementById('btn-custom-menu');
            if (btnCustomReplay && btnCustomNext && btnCustomMenu) {
                btnCustomReplay.style.display = 'inline';
                btnCustomNext.style.display = state.phase === 'win' && !isCampaignMode ? 'inline' : 'none';
                btnCustomMenu.style.display = 'inline';
            } else {
                console.warn('One or more custom prompt buttons not found.');
            }
            const customPrompt = document.getElementById('custom-prompt');
            if (content.includes('caught') || content.includes('Time') || content.includes('limit')) {
                stats.losses++;
                if (isCampaignMode) {
                    const progress = loadCampaignProgress();
                    const currentPrison = getCurrentPrison(progress);
                    showCampaignFailureScreen(currentPrison);
                    customPrompt.style.display = 'none';
                } else {
                    customPrompt.style.display = 'block';
                }
            } else if (state.phase === 'win' && isCampaignMode) {
                customPrompt.style.display = 'none'; // Handled by nextLevel
            } else {
                customPrompt.style.display = 'block';
            }
            updateHighScore();
            btnCustomReplay.onclick = replayLevel;
            btnCustomNext.onclick = nextLevel;
            btnCustomMenu.onclick = () => showSection('fugitive-menu');
            localStorage.setItem('fugitiveStats', JSON.stringify(stats));
        }

        function announce(message) {
            const announcements = document.getElementById('game-announcements');
            let detailedMessage = message;
            if (state.mode === 'fugitive' || state.mode === 'tutorial') {
                detailedMessage += `. King at ${state.king[0] + 1},${state.king[1] + 1}. Escape at ${state.escape[0] + 1},${state.escape[1] + 1}. Moves left: ${state.moves}.`;
            } else if (state.mode === 'standard') {
                const turn = standardState.turn;
                detailedMessage += `. ${turn.charAt(0).toUpperCase() + turn.slice(1)} to move.`;
            }
            announcements.textContent = detailedMessage;
            setTimeout(() => {
                announcements.textContent = '';
            }, 5000); // Clear after 5 seconds
        }

        function announceDetailed(message, details) {
            const announcements = document.getElementById('game-announcements');
            const fullMessage = `${message}. ${details}`;
            announcements.textContent = fullMessage;
            console.log('Announcement:', fullMessage); // For debugging
            setTimeout(() => {
                announcements.textContent = '';
            }, 5000);
        }

        function displayModeRules() {
            let rules = 'Escape from the jail (red) to the safe spot (green)';
            if (state.guardsEnabled === 'on') rules += ' while avoiding guards';
            if (state.turnTimer === 'on') rules += '. Turn Timer: 30s per turn';
            if (state.turnLimit !== 'none') rules += `. Turn Limit: ${state.turnLimit} turns`;
            if (state.kingDisarmed === 'on') rules += '. King Disarmed: Cannot attack';
            if (state.treasureDrops === 'on') rules += '. Treasures: Collect for abilities';
            if (state.hiddenItems === 'on') rules += '. Hidden Items: Treasures are invisible';
            if (state.heroAbility === 'on' && state.hero) rules += `. Hero Ability: ${heroes[state.hero].description}`;
            rules += '.';
            document.getElementById('mode-instructions').textContent = rules;
        }

        // --- Drawing Functions ---
        function drawMiniMap() {
            const miniCanvas = document.getElementById('mini-map');
            const miniCtx = miniCanvas.getContext('2d');
            const miniSquare = state.miniMapZoomed ? 25 : 12.5; // 200 / 8 or 100 / 8
            const size = state.miniMapZoomed ? 200 : 100;
            miniCanvas.width = size;
            miniCanvas.height = size;
            const theme = themes[state.theme] || themes.light;

            miniCtx.clearRect(0, 0, size, size);

            for (let row = 0; row < BOARD; row++) {
                for (let col = 0; col < BOARD; col++) {
                    if (state.fogVision === 'on' && state.fogDisabledTurns <= 0) {
                        const vision = getKingVision();
                        const visionSet = new Set(vision.map(([r, c]) => `${r},${c}`));
                        miniCtx.fillStyle = visionSet.has(`${row},${col}`) ? ((row + col) % 2 === 0 ? theme.light : theme.dark) : 'rgba(128, 128, 128, 0.7)';
                    } else {
                        miniCtx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;
                    }
                    miniCtx.fillRect(col * miniSquare, row * miniSquare, miniSquare, miniSquare);

                    if (state.king[0] === row && state.king[1] === col) {
                        miniCtx.fillStyle = 'blue';
                        miniCtx.fillRect(col * miniSquare + 2, row * miniSquare + 2, miniSquare - 4, miniSquare - 4);
                    }
                    if (state.jail[0] === row && state.jail[1] === col) {
                        miniCtx.fillStyle = 'red';
                        miniCtx.fillRect(col * miniSquare + 3, row * miniSquare + 3, miniSquare - 6, miniSquare - 6);
                    }
                    if (state.escape[0] === row && state.escape[1] === col) {
                        miniCtx.fillStyle = 'green';
                        miniCtx.fillRect(col * miniSquare + 3, row * miniSquare + 3, miniSquare - 6, miniSquare - 6);
                    }
                    state.opponents.forEach(op => {
                        if (op.pos[0] === row && op.pos[1] === col) {
                            miniCtx.fillStyle = 'purple';
                            miniCtx.fillRect(col * miniSquare + 4, row * miniSquare + 4, miniSquare - 8, miniSquare - 8);
                        }
                    });
                    state.treasures.forEach(t => {
                        if (t.pos[0] === row && t.pos[1] === col && (state.hiddenItems === 'off' || state.hiddenItemsOverride)) {
                            miniCtx.fillStyle = 'yellow';
                            miniCtx.fillRect(col * miniSquare + 4, row * miniSquare + 4, miniSquare - 8, miniSquare - 8);
                        }
                    });
                    state.portalsList.forEach((pair, index) => {
                        const colors = ['#800080', '#FFA500', '#0000FF'];
                        pair.forEach(([pr, pc]) => {
                            if (pr === row && pc === col) {
                                miniCtx.fillStyle = colors[index % colors.length];
                                miniCtx.fillRect(col * miniSquare + 3, row * miniSquare + 3, miniSquare - 6, miniSquare - 6);
                            }
                        });
                    });
                }
            }

            miniCtx.strokeStyle = theme.text;
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(0, 0, size, size);
        }

        document.getElementById('mini-map').addEventListener('click', (e) => {
            if (state.phase === 'moving') {
                const rect = e.target.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / 12.5);
                const row = Math.floor((e.clientY - rect.top) / 12.5);
                const validMoves = getValidMoves();
                if (validMoves.some(m => m[0] === row && m[1] === col)) {
                    moveKing(row, col);
                } else if (state.selectingTeleport) {
                    if (!isSquareOccupied(row, col) || (row === state.escape[0] && col === state.escape[1])) {
                        state.king = [row, col];
                        state.heroUses--;
                        state.selectingTeleport = false;
                        document.getElementById('game-info').textContent = 'Teleported via mini-map!';
                        if (state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) {
                            state.phase = 'win';
                            showPrompt('You reached the safe spot!');
                        }
                        state.moves--;
                        if (state.moves <= 0) endPlayerTurn();
                        updateStats();
                        drawBoard();
                    }
                }
            }
        });

        function unlockAchievement(id) {
            const ach = achievements.find(a => a.id === id);
            if (ach && !ach.achieved) {
                ach.achieved = true;
                savedAchievements[id] = true;
                localStorage.setItem('fugitiveAchievements', JSON.stringify(savedAchievements));
                showMessage(`Achievement Unlocked: ${ach.name}`);
            }
        }

        function checkAchievements() {
            if (state.phase === 'win') {
                if (state.guards === 0) unlockAchievement('pacifist');
                if (turnCount < 10) unlockAchievement('speedrunner');
                if (state.level === 1) unlockAchievement('level-novice');
                if (state.level === 10) unlockAchievement('level-apprentice');
                if (state.level === 50) unlockAchievement('level-expert');
                if (state.level === 100) unlockAchievement('level-master');
                if (state.difficulty === 'pawn') unlockAchievement('difficulty-pawn');
                if (state.difficulty === 'knight') unlockAchievement('difficulty-knight');
                if (state.difficulty === 'rook') unlockAchievement('difficulty-rook');
                if (state.difficulty === 'bishop') unlockAchievement('difficulty-bishop');
                if (state.difficulty === 'queen') unlockAchievement('difficulty-queen');
                if (state.difficulty === 'king') unlockAchievement('difficulty-king');
                if (turnCount < 5) unlockAchievement('quick-escape');
                if (!state.seenByGuard) unlockAchievement('stealthy-escape');
                if (state.treasures.length === 0 && state.collectedTreasures.length > 0) unlockAchievement('treasure-collector');
                if (state.collectedTreasures.length === 0) unlockAchievement('minimalist');
                if (state.hero && state.heroCooldown > 0) unlockAchievement('hero-user');
                if (state.kingDisarmed === 'on') unlockAchievement('disarmed-victory');
                if (state.turnTimer === 'on') unlockAchievement('time-pressure');
                if (state.turnLimit === '5') unlockAchievement('limited-turns');
                if (state.fogVision === 'on') unlockAchievement('fog-navigator');
                if (state.hiddenItems === 'on') unlockAchievement('hidden-treasures');
                if (state.portalsList.length > 0 && state.king[0] === state.escape[0] && state.king[1] === state.escape[1]) unlockAchievement('portal-jumper');
                if (state.guards >= 5) unlockAchievement('guard-slayer');
                if (!state.seenByGuard) unlockAchievement('untouchable');
                if (state.arcadeMode === 'on') {
                    if (state.score >= 100) unlockAchievement('arcade-beginner');
                    if (state.score >= 500) unlockAchievement('arcade-pro');
                    if (state.score >= 1000) unlockAchievement('arcade-master');
                }
                if (state.collectedTreasures.length >= 5) unlockAchievement('treasure-hunter');
                if (state.guards >= 10) unlockAchievement('guard-slayer-extreme');
                if (state.collectedTreasures.some(t => t.type === 'decoy') && !state.seenByGuard) unlockAchievement('decoy-master');
                if (state.portalsList.length >= 3) unlockAchievement('portal-explorer');
                if (state.timeAttack === 'on' && state.timeLeft > 900) unlockAchievement('time-attack-champ');
            }
        }

        function throttle(func, limit) {
            let lastCall = 0;
            return function (...args) {
                const now = Date.now();
                if (now - lastCall >= limit) {
                    lastCall = now;
                    func.apply(this, args);
                }
            };
        }

        const throttledDrawBoard = throttle(drawBoard, 100); // Limit to 10 FPS

        function gameLoop() {
            if (state.mode === 'creative') {
                drawCreativeBoard();
            } else if (state.mode === 'tutorial') {
                throttledDrawBoard();
            } else if (state.mode === 'standard') {
                drawStandardBoard();
            } else {
                throttledDrawBoard();
                drawMiniMap();
            }
            if (state.mode === 'fugitive' && state.phase !== 'waiting' && !state.paused) {
                stats.totalTimePlayed += 1 / 60;
            }
            if (state.timeAttack === 'on' && state.mode === 'fugitive' && state.phase !== 'waiting' && !state.paused) {
                state.timeLeft -= 1 / 60;
                if (state.timeLeft <= 0) {
                    state.phase = 'lose';
                    if (!state.music.isMuted && state.music.sfxVolume > 0) {
                        sounds.lose.volume = state.music.sfxVolume;
                        sounds.lose.play();
                    }
                    showPrompt('Time’s up for Time Attack!');
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function drawTutorialHighlights() {
            if (state.mode === 'tutorial' && tutorialSteps[tutorialStep]?.highlight) {
                const currentCtx = tutorialCtx;
                const theme = themes[state.theme] || themes.light;
                tutorialSteps[tutorialStep].highlight.forEach(([row, col]) => {
                    currentCtx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                    const pulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
                    currentCtx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);

                    // Draw animated arrow from king to target if expectedPosition exists
                    if (state.king && tutorialSteps[tutorialStep].expectedPosition) {
                        const [targetRow, targetCol] = tutorialSteps[tutorialStep].expectedPosition;
                        const [kingRow, kingCol] = state.king;
                        const dx = targetCol - kingCol;
                        const dy = targetRow - kingRow;
                        const length = Math.sqrt(dx * dx + dy * dy) * SQUARE;
                        const angle = Math.atan2(dy, dx);

                        currentCtx.save();
                        currentCtx.translate(kingCol * SQUARE + SQUARE / 2, kingRow * SQUARE + SQUARE / 2);
                        currentCtx.rotate(angle);
                        currentCtx.fillStyle = `rgba(0, 255, 0, ${pulse})`; // Green pulsing arrow
                        currentCtx.beginPath();
                        currentCtx.moveTo(0, -5);
                        currentCtx.lineTo(length / 2, -5);
                        currentCtx.lineTo(length / 2, 5);
                        currentCtx.lineTo(0, 5);
                        currentCtx.fill();
                        // Draw arrowhead
                        currentCtx.beginPath();
                        currentCtx.moveTo(length / 2, -10);
                        currentCtx.lineTo(length / 2 + 10, 0);
                        currentCtx.lineTo(length / 2, 10);
                        currentCtx.fill();
                        currentCtx.restore();
                    }
                });
            }
        }

        function drawBoard() {
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            if (!currentCtx) {
                console.error('Canvas context is null for mode:', state.mode);
                return;
            }
            if (!validateState()) {
                console.warn('Invalid state, attempting to draw with default king');
            }

            const dirty = getDirtySquares();
            const theme = themes[state.theme] || themes.light;
            const pieceStyle = pieceStyles[state.pieceStyle] || pieceStyles.classic;

            if (state.forceRedraw || !previousBoard) {
                currentCtx.clearRect(0, 0, BOARD * SQUARE, BOARD * SQUARE);
                for (let row = 0; row < BOARD; row++) {
                    for (let col = 0; col < BOARD; col++) {
                        drawSquare(currentCtx, row, col);
                    }
                }
                state.forceRedraw = false;
            } else if (dirty.size > 0) {
                dirty.forEach(key => {
                    const [row, col] = key.split(',').map(Number);
                    currentCtx.clearRect(col * SQUARE - 2, row * SQUARE - 2, SQUARE + 4, SQUARE + 4);
                    drawSquare(currentCtx, row, col);
                });
            } else {
                return;
            }

            state.opponents.forEach(op => {
                if (op.animatedPixelCenter) {
                    const [drawX, drawY] = op.animatedPixelCenter;
                    currentCtx.font = `28px ${theme.font}`;
                    currentCtx.fillStyle = theme.btn;
                    currentCtx.textAlign = 'center';
                    currentCtx.textBaseline = 'middle';
                    currentCtx.fillText(pieceStyle[op.type], drawX, drawY);
                }
            });

            if (state.kingAnimatedPixelCenter) {
                const [drawX, drawY] = state.kingAnimatedPixelCenter;
                currentCtx.font = `36px ${theme.font}`;
                currentCtx.fillStyle = theme.dark;
                currentCtx.textAlign = 'center';
                currentCtx.textBaseline = 'middle';
                const symbol = state.hero ? heroes[state.hero].emoji : pieceStyle.king;
                currentCtx.fillText(symbol, drawX, drawY);
            }

            // Handle special states
            if (state.selectingGuard || state.selectingTeleport) {
                if (state.selectingGuard) {
                    state.opponents.forEach(op => {
                        const [row, col] = op.pos;
                        currentCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                    });
                }
                if (state.selectingTeleport) {
                    for (let row = 0; row < BOARD; row++) {
                        for (let col = 0; col < BOARD; col++) {
                            if (!isSquareOccupied(row, col) || (row === state.escape[0] && col === state.escape[1])) {
                                currentCtx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                                currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                            }
                        }
                    }
                }
            }

            // Draw terrain
            if (state.mode !== 'creative') {
                state.terrain.forest.forEach(([row, col]) => {
                    currentCtx.fillStyle = '#228B22';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                });
                state.terrain.water.forEach(([row, col]) => {
                    currentCtx.fillStyle = '#00CED1';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                });
                state.terrain.sand.forEach(([row, col]) => {
                    currentCtx.fillStyle = '#C2B280';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                });
            }

            if (state.lastMove && state.animations === 'on') {
                // Animation handled by animateMoveIndicator, no static draw needed
            }

            if (state.decoyTurns > 0 && state.decoyPos) {
                currentCtx.font = `36px ${theme.font}`;
                currentCtx.fillStyle = 'rgba(0, 0, 255, 0.5)'; // Blue semi-transparent decoy
                currentCtx.textAlign = 'center';
                currentCtx.textBaseline = 'middle';
                currentCtx.fillText(pieceStyle.king, state.decoyPos[1] * SQUARE + SQUARE / 2, state.decoyPos[0] * SQUARE + SQUARE / 2);
            }
            if (state.revealTurns > 0) {
                state.opponents.forEach(op => {
                    const [row, col] = op.pos;
                    currentCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                });
            }

            if (state.canPhase > 0) {
                currentCtx.globalAlpha = 0.5; // Make king semi-transparent when intangible
                currentCtx.font = `36px ${theme.font}`;
                currentCtx.fillStyle = theme.dark;
                currentCtx.textAlign = 'center';
                currentCtx.textBaseline = 'middle';
                const symbol = state.hero ? heroes[state.hero].emoji : pieceStyle.king;
                currentCtx.fillText(symbol, state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                currentCtx.globalAlpha = 1.0;
            }

            drawTutorialHighlights();
            if (state.mode === 'fugitive' && state.heroAbility === 'on' && state.hero) {
                updateHeroAbilityUI();
            }

            previousState.king = [...state.king];
            previousState.jail = [...state.jail];
            previousState.escape = [...state.escape];
            previousState.opponents = state.opponents.map(op => ({ type: op.type, pos: [...op.pos] }));
            previousState.phase = state.phase;
            previousState.treasures = state.treasures.map(t => ({ type: t.type, pos: [...t.pos] }));
            previousState.pointItems = state.pointItems.map(item => ({ type: item.type, pos: [...item.pos] }));
            previousState.validMoves = state.phase === 'moving' ? getValidMoves() : [];
            previousState.hintPath = state.hintEnabled === 'on' ? showMoveHints() : [];

            const canvas = document.getElementById(state.mode === 'tutorial' ? 'tutorial-board' : 'board');
            let description = `King at ${state.king[0]},${state.king[1]}. Escape at ${state.escape[0]},${state.escape[1]}. `;
            description += `Guards: ${state.opponents.length}. Treasures: ${state.treasures.length}.`;
            canvas.setAttribute('aria-label', description);
            previousBoard = getCurrentBoardState();
        }

        function animateMoveIndicator(start, end) {
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            const startX = start[1] * SQUARE + SQUARE / 2;
            const startY = start[0] * SQUARE + SQUARE / 2;
            const endX = end[1] * SQUARE + SQUARE / 2;
            const endY = end[0] * SQUARE + SQUARE / 2;
            const dx = endX - startX;
            const dy = endY - startY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            let alpha = 1;

            function animate() {
                currentCtx.save();
                currentCtx.globalAlpha = alpha;
                currentCtx.translate(startX, startY);
                currentCtx.rotate(angle);
                currentCtx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                currentCtx.beginPath();
                currentCtx.moveTo(0, -5);
                currentCtx.lineTo(length - 10, -5);
                currentCtx.lineTo(length - 10, 5);
                currentCtx.lineTo(0, 5);
                currentCtx.fill();
                currentCtx.beginPath();
                currentCtx.moveTo(length - 10, -10);
                currentCtx.lineTo(length, 0);
                currentCtx.lineTo(length - 10, 10);
                currentCtx.fill();
                currentCtx.restore();
                alpha -= 0.02;
                if (alpha > 0) requestAnimationFrame(animate);
                else state.lastMove = null;
            }
            requestAnimationFrame(animate);
        }

        function getCurrentBoardState() {
            return {
                king: [...state.king],
                jail: [...state.jail],
                escape: [...state.escape],
                opponents: state.opponents.map(op => ({ ...op })),
                blocked: state.blocked.map(b => [...b]),
                treasures: state.treasures.map(t => ({ ...t })),
                portalsList: state.portalsList.map(pair => pair.map(p => [...p])),
                phase: state.phase
            };
        }

        function flashInvalidSquare(row, col) {
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            let flashCount = 0;
            const interval = setInterval(() => {
                if (flashCount % 2 === 0) {
                    currentCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                } else {
                    drawSquare(currentCtx, row, col);
                }
                flashCount++;
                if (flashCount >= 6) {
                    clearInterval(interval);
                    drawSquare(currentCtx, row, col);
                }
            }, 150);
        }

        /**
         * Animates the visual effect of a hero's ability on the game canvas.
         * @param {string} heroKey - The key identifying the hero in the heroes object
         * @param {number[]|null} targetPos - The target position for abilities requiring a target (e.g., [row, col])
         */
        function animateHeroAbility(heroKey, targetPos = null) {
            // Determine the appropriate canvas context based on game mode
            const currentContext = state.mode === 'tutorial' ? tutorialCtx : ctx;

            // Retrieve the current theme, defaulting to light if not found
            const currentTheme = themes[state.theme] || themes.light;

            // Get the hero object based on the provided key
            const hero = heroes[heroKey];

            // Variable to store the animation frame ID
            let animationFrame;

            // Handle different hero effects with corresponding animations
            switch (hero.effect) {
                case 'strength':
                    // Hercules: Explosion effect on adjacent squares
                    let explosionRadius = 0;
                    const maxExplosionRadius = SQUARE * 1.5; // Maximum radius of the explosion
                    function animateExplosion() {
                        currentContext.save();
                        getValidMoves().forEach(([row, col]) => {
                            currentContext.beginPath();
                            currentContext.arc(
                                col * SQUARE + SQUARE / 2,
                                row * SQUARE + SQUARE / 2,
                                explosionRadius,
                                0,
                                Math.PI * 2
                            );
                            currentContext.fillStyle = `rgba(255, 0, 0, ${1 - explosionRadius / maxExplosionRadius})`;
                            currentContext.fill();
                        });
                        currentContext.restore();
                        explosionRadius += 5;
                        if (explosionRadius < maxExplosionRadius) {
                            animationFrame = requestAnimationFrame(animateExplosion);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateExplosion);
                    break;

                case 'magic':
                    // Merlin: Sparkle effect at the king's position
                    let sparkleParticles = [];
                    for (let i = 0; i < 30; i++) {
                        sparkleParticles.push({
                            x: state.king[1] * SQUARE + SQUARE / 2,
                            y: state.king[0] * SQUARE + SQUARE / 2,
                            vx: (Math.random() - 0.5) * 6, // Velocity X
                            vy: (Math.random() - 0.5) * 6, // Velocity Y
                            life: 1 // Particle lifespan
                        });
                    }
                    function animateSparkle() {
                        currentContext.save();
                        sparkleParticles = sparkleParticles.filter(p => p.life > 0);
                        sparkleParticles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= 0.05;
                            currentContext.fillStyle = `rgba(255, 215, 0, ${p.life})`;
                            currentContext.beginPath();
                            currentContext.arc(p.x, p.y, 4 * p.life, 0, Math.PI * 2);
                            currentContext.fill();
                        });
                        currentContext.restore();
                        if (sparkleParticles.length > 0) {
                            animationFrame = requestAnimationFrame(animateSparkle);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSparkle);
                    break;

                case 'rangedAttack':
                case 'assassinate':
                    // Robin Hood/Assassin/Zeus: Arrow animation to target
                    const arrowStartX = state.king[1] * SQUARE + SQUARE / 2;
                    const arrowStartY = state.king[0] * SQUARE + SQUARE / 2;
                    const arrowEndX = targetPos[1] * SQUARE + SQUARE / 2;
                    const arrowEndY = targetPos[0] * SQUARE + SQUARE / 2;
                    let arrowProgress = 0;
                    function animateArrow() {
                        currentContext.save();
                        const x = arrowStartX + (arrowEndX - arrowStartX) * arrowProgress;
                        const y = arrowStartY + (arrowEndY - arrowStartY) * arrowProgress;
                        currentContext.fillStyle = '#8B4513'; // Brown color for arrow
                        currentContext.beginPath();
                        currentContext.moveTo(x - 5, y - 5);
                        currentContext.lineTo(x + 5, y + 5);
                        currentContext.lineTo(x - 5, y + 5);
                        currentContext.fill();
                        currentContext.restore();
                        arrowProgress += 0.1;
                        if (arrowProgress < 1) {
                            animationFrame = requestAnimationFrame(animateArrow);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateArrow);
                    break;

                case 'stealth':
                    // Hanzo: Fading shadow effect
                    let shadowOpacity = 1;
                    function animateShadow() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
                        currentContext.fillRect(
                            state.king[1] * SQUARE,
                            state.king[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        shadowOpacity -= 0.05;
                        if (shadowOpacity > 0) {
                            animationFrame = requestAnimationFrame(animateShadow);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateShadow);
                    break;

                case 'duel':
                    // Musashi: Sword slash animation
                    let slashAngle = 0;
                    function animateSlash() {
                        currentContext.save();
                        currentContext.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentContext.rotate(slashAngle);
                        currentContext.strokeStyle = 'silver';
                        currentContext.lineWidth = 2;
                        currentContext.beginPath();
                        currentContext.moveTo(-SQUARE / 2, 0);
                        currentContext.lineTo(SQUARE / 2, 0);
                        currentContext.stroke();
                        currentContext.restore();
                        slashAngle += Math.PI / 20;
                        if (slashAngle < Math.PI) {
                            animationFrame = requestAnimationFrame(animateSlash);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSlash);
                    break;

                case 'charge':
                    // Alexander: Speed lines
                    let lineProgress = 0;
                    function animateSpeedLines() {
                        currentContext.save();
                        currentContext.strokeStyle = 'gray';
                        currentContext.lineWidth = 1;
                        for (let i = 0; i < 5; i++) {
                            currentContext.beginPath();
                            currentContext.moveTo(
                                state.king[1] * SQUARE + SQUARE / 2,
                                state.king[0] * SQUARE + SQUARE / 2
                            );
                            currentContext.lineTo(
                                state.king[1] * SQUARE + SQUARE / 2 - lineProgress * 20,
                                state.king[0] * SQUARE + SQUARE / 2 + (Math.random() - 0.5) * 20
                            );
                            currentContext.stroke();
                        }
                        currentContext.restore();
                        lineProgress += 0.1;
                        if (lineProgress < 1) {
                            animationFrame = requestAnimationFrame(animateSpeedLines);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSpeedLines);
                    break;

                case 'charm':
                    // Cleopatra: Heart particles
                    let hearts = [];
                    for (let i = 0; i < 10; i++) {
                        hearts.push({
                            x: state.king[1] * SQUARE + SQUARE / 2,
                            y: state.king[0] * SQUARE + SQUARE / 2,
                            vy: -Math.random() * 3,
                            life: 1
                        });
                    }
                    function animateHearts() {
                        currentContext.save();
                        hearts = hearts.filter(h => h.life > 0);
                        hearts.forEach(h => {
                            h.y += h.vy;
                            h.life -= 0.05;
                            currentContext.fillStyle = `rgba(255, 105, 180, ${h.life})`;
                            currentContext.beginPath();
                            currentContext.arc(h.x, h.y, 5 * h.life, 0, Math.PI * 2);
                            currentContext.fill();
                        });
                        currentContext.restore();
                        if (hearts.length > 0) {
                            animationFrame = requestAnimationFrame(animateHearts);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateHearts);
                    break;

                case 'peace':
                    // Siddhartha: Peaceful glow
                    let glowRadius = 0;
                    function animateGlow() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(255, 255, 224, ${0.5 - glowRadius / SQUARE})`;
                        currentContext.beginPath();
                        currentContext.arc(
                            state.king[1] * SQUARE + SQUARE / 2,
                            state.king[0] * SQUARE + SQUARE / 2,
                            glowRadius,
                            0,
                            Math.PI * 2
                        );
                        currentContext.fill();
                        currentContext.restore();
                        glowRadius += 2;
                        if (glowRadius < SQUARE / 2) {
                            animationFrame = requestAnimationFrame(animateGlow);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateGlow);
                    break;

                case 'protection':
                    // Michael: Shield effect
                    let shieldOpacity = 1;
                    function animateShield() {
                        currentContext.save();
                        currentContext.strokeStyle = `rgba(0, 191, 255, ${shieldOpacity})`;
                        currentContext.lineWidth = 2;
                        currentContext.beginPath();
                        currentContext.arc(
                            state.king[1] * SQUARE + SQUARE / 2,
                            state.king[0] * SQUARE + SQUARE / 2,
                            SQUARE / 2,
                            0,
                            Math.PI * 2
                        );
                        currentContext.stroke();
                        currentContext.restore();
                        shieldOpacity -= 0.05;
                        if (shieldOpacity > 0) {
                            animationFrame = requestAnimationFrame(animateShield);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateShield);
                    break;

                case 'wisdom':
                    // Solomon: Path highlight (simplified as a pulse)
                    let pulseSize = 0;
                    function animatePulse() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(0, 255, 0, ${0.5 - pulseSize / SQUARE})`;
                        currentContext.fillRect(
                            state.king[1] * SQUARE,
                            state.king[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        pulseSize += 2;
                        if (pulseSize < SQUARE) {
                            animationFrame = requestAnimationFrame(animatePulse);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animatePulse);
                    break;

                case 'explore':
                case 'teleport':
                    // Gagarin/Odin: Portal effect
                    let portalRadius = 0;
                    function animatePortal() {
                        currentContext.save();
                        currentContext.strokeStyle = `rgba(75, 0, 130, ${1 - portalRadius / SQUARE})`;
                        currentContext.lineWidth = 3;
                        currentContext.beginPath();
                        currentContext.arc(
                            state.king[1] * SQUARE + SQUARE / 2,
                            state.king[0] * SQUARE + SQUARE / 2,
                            portalRadius,
                            0,
                            Math.PI * 2
                        );
                        currentContext.stroke();
                        currentContext.restore();
                        portalRadius += 3;
                        if (portalRadius < SQUARE) {
                            animationFrame = requestAnimationFrame(animatePortal);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animatePortal);
                    break;

                case 'resurrection':
                    // Jesus: Holy light
                    let lightOpacity = 1;
                    function animateLight() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(255, 255, 255, ${lightOpacity})`;
                        currentContext.fillRect(
                            state.king[1] * SQUARE,
                            state.king[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        lightOpacity -= 0.05;
                        if (lightOpacity > 0) {
                            animationFrame = requestAnimationFrame(animateLight);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateLight);
                    break;

                case 'trickery':
                    // Loki: Swap swirl
                    let swirlAngle = 0;
                    function animateSwirl() {
                        currentContext.save();
                        currentContext.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentContext.rotate(swirlAngle);
                        currentContext.strokeStyle = 'purple';
                        currentContext.beginPath();
                        currentContext.arc(0, 0, SQUARE / 3, 0, Math.PI * 2);
                        currentContext.stroke();
                        currentContext.restore();
                        swirlAngle += Math.PI / 20;
                        if (swirlAngle < Math.PI * 2) {
                            animationFrame = requestAnimationFrame(animateSwirl);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateSwirl);
                    break;

                case 'reveal':
                    // Oracle: Vision pulse
                    let visionRadius = 0;
                    function animateVision() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(135, 206, 235, ${0.5 - visionRadius / (SQUARE * 2)})`;
                        currentContext.beginPath();
                        currentContext.arc(
                            state.king[1] * SQUARE + SQUARE / 2,
                            state.king[0] * SQUARE + SQUARE / 2,
                            visionRadius,
                            0,
                            Math.PI * 2
                        );
                        currentContext.fill();
                        currentContext.restore();
                        visionRadius += 5;
                        if (visionRadius < SQUARE * 2) {
                            animationFrame = requestAnimationFrame(animateVision);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateVision);
                    break;

                case 'disableVision':
                    // Shadow: Dark mist
                    let mistOpacity = 1;
                    function animateMist() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(50, 50, 50, ${mistOpacity})`;
                        currentContext.fillRect(
                            targetPos[1] * SQUARE,
                            targetPos[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        mistOpacity -= 0.05;
                        if (mistOpacity > 0) {
                            animationFrame = requestAnimationFrame(animateMist);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateMist);
                    break;

                case 'timeWarp':
                case 'spell':
                case 'freeze':
                    // Time Wizard/Wizard/Frost Mage: Time distortion rings
                    let ringRadius = 0;
                    function animateRings() {
                        currentContext.save();
                        currentContext.strokeStyle = 'cyan';
                        currentContext.lineWidth = 2;
                        currentContext.beginPath();
                        currentContext.arc(
                            state.king[1] * SQUARE + SQUARE / 2,
                            state.king[0] * SQUARE + SQUARE / 2,
                            ringRadius,
                            0,
                            Math.PI * 2
                        );
                        currentContext.stroke();
                        currentContext.restore();
                        ringRadius += 5;
                        if (ringRadius < SQUARE * 2) {
                            animationFrame = requestAnimationFrame(animateRings);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateRings);
                    break;

                case 'steal':
                    // Thief: Treasure grab sparkle
                    let grabParticles = [];
                    for (let i = 0; i < 15; i++) {
                        grabParticles.push({
                            x: state.king[1] * SQUARE + SQUARE / 2,
                            y: state.king[0] * SQUARE + SQUARE / 2,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 1
                        });
                    }
                    function animateGrab() {
                        currentContext.save();
                        grabParticles = grabParticles.filter(p => p.life > 0);
                        grabParticles.forEach(p => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= 0.1;
                            currentContext.fillStyle = `rgba(255, 215, 0, ${p.life})`;
                            currentContext.beginPath();
                            currentContext.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                            currentContext.fill();
                        });
                        currentContext.restore();
                        if (grabParticles.length > 0) {
                            animationFrame = requestAnimationFrame(animateGrab);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateGrab);
                    break;

                case 'timeSkip':
                    // Chronomancer: Clock tick
                    let tickAngle = 0;
                    function animateClock() {
                        currentContext.save();
                        currentContext.translate(state.king[1] * SQUARE + SQUARE / 2, state.king[0] * SQUARE + SQUARE / 2);
                        currentContext.rotate(tickAngle);
                        currentContext.strokeStyle = 'black';
                        currentContext.beginPath();
                        currentContext.moveTo(0, 0);
                        currentContext.lineTo(SQUARE / 3, 0);
                        currentContext.stroke();
                        currentContext.restore();
                        tickAngle += Math.PI / 6;
                        if (tickAngle < Math.PI * 2) {
                            animationFrame = requestAnimationFrame(animateClock);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateClock);
                    break;

                case 'decoy':
                    // Illusionist: Decoy fade-in
                    let decoyOpacity = 0;
                    function animateDecoy() {
                        currentContext.save();
                        currentContext.fillStyle = `rgba(128, 128, 128, ${decoyOpacity})`;
                        currentContext.fillRect(
                            state.decoyPos[1] * SQUARE,
                            state.decoyPos[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        decoyOpacity += 0.1;
                        if (decoyOpacity < 1) {
                            animationFrame = requestAnimationFrame(animateDecoy);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateDecoy);
                    break;

                case 'intangibility':
                    // Phantom: Ghostly flicker
                    let flickerPhase = 0;
                    function animateFlicker() {
                        currentContext.save();
                        currentContext.globalAlpha = Math.sin(flickerPhase);
                        currentContext.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        currentContext.fillRect(
                            state.king[1] * SQUARE,
                            state.king[0] * SQUARE,
                            SQUARE,
                            SQUARE
                        );
                        currentContext.restore();
                        flickerPhase += 0.2;
                        if (flickerPhase < Math.PI * 2) {
                            animationFrame = requestAnimationFrame(animateFlicker);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateFlicker);
                    break;

                case 'windwalk':
                    // Zephyr: Wind gusts
                    let gustOffset = 0;
                    function animateGusts() {
                        currentContext.save();
                        currentContext.strokeStyle = 'rgba(173, 216, 230, 0.7)';
                        currentContext.beginPath();
                        currentContext.moveTo(state.king[1] * SQUARE, state.king[0] * SQUARE + gustOffset);
                        currentContext.lineTo(state.king[1] * SQUARE + SQUARE, state.king[0] * SQUARE + gustOffset);
                        currentContext.stroke();
                        currentContext.restore();
                        gustOffset += 5;
                        if (gustOffset < SQUARE) {
                            animationFrame = requestAnimationFrame(animateGusts);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateGusts);
                    break;

                case 'destroyWalls':
                    // Bomb: Explosion debris
                    let debris = [];
                    for (let i = 0; i < 20; i++) {
                        debris.push({
                            x: state.king[1] * SQUARE + SQUARE / 2,
                            y: state.king[0] * SQUARE + SQUARE / 2,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 1
                        });
                    }
                    function animateDebris() {
                        currentContext.save();
                        debris = debris.filter(d => d.life > 0);
                        debris.forEach(d => {
                            d.x += d.vx;
                            d.y += d.vy;
                            d.life -= 0.1;
                            currentContext.fillStyle = `rgba(139, 69, 19, ${d.life})`;
                            currentContext.fillRect(d.x, d.y, 3, 3);
                        });
                        currentContext.restore();
                        if (debris.length > 0) {
                            animationFrame = requestAnimationFrame(animateDebris);
                        } else {
                            cancelAnimationFrame(animationFrame);
                            drawBoard();
                        }
                    }
                    animationFrame = requestAnimationFrame(animateDebris);
                    break;

                default:
                    // Fallback for unhandled effects
                    drawBoard();
                    break;
            }
        }

        function applyTerrainEffects(row, col) {
            if (state.terrain.forest.some(([r, c]) => r === row && c === col)) {
                state.moves -= 1; // Forest slows movement
                document.getElementById('game-info').textContent = 'Forest terrain slowed you down!';
            }
            if (state.terrain.water.some(([r, c]) => r === row && c === col)) {
                state.moves = 0; // Water ends turn
                document.getElementById('game-info').textContent = 'Water terrain stopped your turn!';
            }
            if (state.terrain.sand.some(([r, c]) => r === row && c === col)) {
                state.moves -= 1; // Sand slows movement
                document.getElementById('game-info').textContent = 'Sand terrain slowed you down!';
            }
        }

        function applyTheme() {
            const theme = themes[state.theme] || themes.light;
            document.body.style.background = theme.bg;
            document.body.style.color = theme.text;
            document.body.style.fontFamily = theme.font;
            document.querySelectorAll('button').forEach(btn => {
                btn.style.background = theme.btn;
                btn.style.color = theme.text;
                btn.style.fontFamily = theme.font;
                btn.onmouseover = () => btn.style.background = theme.btnHover;
                btn.onmouseout = () => btn.style.background = theme.btn;
            });
            document.querySelectorAll('#music-controls button').forEach(btn => {
                btn.style.background = theme.btn;
                btn.style.color = 'white';
                btn.style.border = '1px solid #333';
                btn.onmouseover = () => btn.style.background = theme.btnHover;
                btn.onmouseout = () => btn.style.background = theme.btn;
            });
            document.querySelectorAll('h1, h2, h3, f1, f2, f3, #level-info, #game-info, #stats, #track-info, #mode-instructions, header, footer, .custom-modal').forEach(el => {
                el.style.color = theme.text;
                el.style.fontFamily = theme.font;
            });
            document.querySelectorAll('select').forEach(sel => {
                sel.style.background = theme.bg;
                sel.style.color = theme.text;
                sel.style.fontFamily = theme.font;
                sel.style.border = `1px solid ${theme.text}`;
            });
            document.querySelectorAll('canvas').forEach(canvas => {
                canvas.style.border = `2px solid ${theme.text}`;
            });
        }

        function setRandomTheme() {
            const randColor = () => `#${Math.floor(Math.random() * 16777216).toString(16).padStart(6, '0')}`;
            state.theme = 'random';
            themes.random = {
                light: randColor(),
                dark: randColor(),
                bg: `linear-gradient(45deg, ${randColor()}, ${randColor()})`,
                btn: randColor(),
                btnHover: randColor(),
                text: randColor(),
                font: Object.values(themes)[Math.floor(Math.random() * (Object.keys(themes).length - 1))].font
            };
            document.getElementById('theme').value = 'random';
            document.getElementById('standard-theme').value = 'random';
            applyTheme();
            if (document.getElementById('game-area').style.display === 'flex') {
                drawBoard();
            } else if (state.mode === 'standard') {
                drawStandardBoard();
                state.forceRedraw = true;
            }
        }

        // --- Music Control Functions ---
        function toggleMute() {
            state.music.isMuted = !state.music.isMuted;
            state.music.audio.muted = state.music.isMuted;
            Object.values(sounds).forEach(sound => {
                sound.muted = state.music.isMuted;
            });
            document.getElementById('btn-mute').textContent = state.music.isMuted ? 'Unmute' : 'Mute';
        }

        function togglePause() {
            if (state.music.isPlaying) {
                state.music.audio.pause();
                state.music.isPlaying = false;
                document.getElementById('btn-pause').textContent = 'Play';
            } else {
                playMusic();
            }
        }

        function playMusic() {
            if (state.music.currentPlaylist.length === 0) {
                alert('No songs selected!');
                return;
            }
            const track = state.music.currentPlaylist[state.music.currentTrack];
            state.music.audio.src = track.url;
            state.music.audio.play().then(() => {
                state.music.isPlaying = true;
                document.getElementById('btn-pause').textContent = 'Pause';
                document.getElementById('track-info').textContent = `Now Playing: ${getSongDisplayName(track)}`;
            }).catch(console.error);
        }

        function skipTrack() {
            if (state.music.currentPlaylist.length === 0) return;
            state.music.currentTrack = (state.music.currentTrack + 1) % state.music.currentPlaylist.length;
            playMusic();
        }

        function shufflePlaylist() {
            const playlist = state.music.playlist;
            for (let i = playlist.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
            }
            state.music.currentTrack = 0;
            document.getElementById('song-select').innerHTML = '';
            initSongSelect();
            playMusic();
        }

        function toggleRepeat() {
            state.music.isRepeating = !state.music.isRepeating;
            document.getElementById('btn-repeat').style.background =
                state.music.isRepeating ? '#ff4444' : themes[state.theme].btn;
        }

        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function populateSongList() {
            const songListDiv = document.getElementById('song-list');
            songListDiv.innerHTML = '';
            state.music.playlist.forEach((song, index) => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = index;
                checkbox.checked = state.music.selectedSongs.includes(index);
                checkbox.addEventListener('change', updateSelectedSongs);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(` ${song.name}`));
                songListDiv.appendChild(label);
                songListDiv.appendChild(document.createElement('br'));
            });
            document.getElementById('play-order').value = state.music.playOrder;
        }

        function updateSelectedSongs() {
            state.music.selectedSongs = Array.from(document.querySelectorAll('#song-list input[type="checkbox"]:checked'))
                .map(cb => parseInt(cb.value));
            generateCurrentPlaylist();
            saveMusicSettings();
        }

        function generateCurrentPlaylist() {
            let songs = state.music.selectedSongs.map(index => state.music.playlist[index]);
            if (state.music.playOrder === 'random') {
                songs = shuffle(songs);
            }
            state.music.currentPlaylist = songs;
            if (state.music.currentTrack >= songs.length) {
                state.music.currentTrack = 0;
            }
        }

        function saveMusicSettings() {
            localStorage.setItem('fugitiveMusicSettings', JSON.stringify({
                selectedSongs: state.music.selectedSongs,
                playOrder: state.music.playOrder
            }));
        }

        function loadMusicSettings() {
            const settings = JSON.parse(localStorage.getItem('fugitiveMusicSettings')) || {
                selectedSongs: state.music.playlist.map((_, i) => i),
                playOrder: 'normal'
            };
            state.music.selectedSongs = settings.selectedSongs;
            state.music.playOrder = settings.playOrder;
            generateCurrentPlaylist();
        }

        // --- Tutorial Logic ---
        let tutorialStep = 0;
        const tutorialSteps = [
            {
                message: "Welcome to Fugitive Chess! Your goal is to move the King from the jail (red) to the safe spot (green). Press Space to roll the dice.",
                board: { king: [0, 0], jail: [0, 0], escape: [2, 2], opponents: [], blocked: [], treasures: [], portalsList: [] },
                expectedAction: 'roll'
            },
            {
                message: "You rolled the dice! Use arrow keys or WASD to move right.",
                board: null,
                expectedPosition: [0, 1],
                highlight: [[0, 1]]
            },
            {
                message: "Good! Guards can catch you. Move down to avoid this Pawn.",
                board: { opponents: [{ type: 'pawn', pos: [0, 2] }] },
                expectedPosition: [1, 1],
                highlight: [[1, 1]]
            },
            {
                message: "Treasures give abilities. Move to collect the shield.",
                board: { treasures: [{ type: 'shield', pos: [2, 1] }] },
                expectedPosition: [2, 1],
                highlight: [[2, 1]],
                trigger: 'collect'
            },
            {
                message: "Heroes have abilities. Select Hercules and press 'H' to defeat adjacent guards.",
                board: { hero: 'hercules', opponents: [{ type: 'pawn', pos: [2, 0] }, { type: 'pawn', pos: [2, 2] }] },
                expectedAction: 'useHeroAbility'
            },
            {
                message: "Reach the safe spot to win! Move there now.",
                board: null,
                expectedPosition: [2, 2],
                highlight: [[2, 2]],
                trigger: 'win'
            },
            {
                message: "Portals can teleport you to another location. Move to the portal to teleport.",
                board: { portalsList: [[[3,3], [5,5]]] },
                expectedPosition: [5,5],
                highlight: [[3,3]]
            },
            {
                message: "With Fog Vision, you can only see adjacent squares. Move carefully to the escape.",
                board: { fogVision: 'on' },
                expectedPosition: [7,7],
                highlight: []
            },
            {
                message: "Guards can have different behaviors. This guard is patrolling between two points.",
                board: { opponents: [{ type: 'rook', pos: [4,0], behavior: 'patrol', patrolRoute: [[4,0], [4,7]] }] },
                expectedAction: 'observe'
            },
            {
                message: "Treasures like the Bomb can destroy walls. Move to collect it and see the effect.",
                board: { treasures: [{ type: 'bomb', pos: [3, 3] }], blocked: [[2, 3], [3, 2], [3, 4], [4, 3]] },
                expectedPosition: [3, 3],
                highlight: [[3, 3]],
                trigger: 'collect'
            },
            {
                message: "Reach the safe spot to win! Move there now.",
                board: null,
                expectedPosition: [2, 2],
                highlight: [[2, 2]],
                trigger: 'win'
            }
        ];

        function toggleTutorialButtons(showNext) {
            document.getElementById('btn-start-tutorial').style.display = showNext ? 'none' : 'inline';
            document.getElementById('btn-next-tutorial').style.display = showNext ? 'inline' : 'none';
        }

        function startTutorial() {
            state.mode = 'tutorial';
            tutorialStep = 0;
            showSection('tutorial-section');
            document.getElementById('tutorial-info').textContent = tutorialSteps[0].message;
            toggleTutorialButtons(false);
            state.forceRedraw = true;
            drawBoard();
        }

        function setupTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            if (step.board) {
                Object.assign(state, step.board);
                state.hero = step.board.hero || null;
            }
            state.phase = step.expectedAction === 'roll' ? 'waiting' : 'moving';
            state.moves = step.expectedAction === 'roll' ? 0 : 3;
            state.roll = step.expectedAction === 'roll' ? 0 : 3;
            document.getElementById('tutorial-info').innerHTML = `${step.message} <span id="key-hint"></span>`;
            toggleTutorialButtons(true);
            updateKeyHint(step);
            state.forceRedraw = true;
            drawBoard();
        }

        function updateKeyHint(step) {
            const hint = document.getElementById('key-hint');
            if (step.expectedAction === 'roll') hint.textContent = '(Press Space)';
            else if (step.expectedPosition) {
                const [tr, tc] = step.expectedPosition;
                const [kr, kc] = state.king;
                if (tr < kr) hint.textContent = '(Press W or ↑)';
                else if (tr > kr) hint.textContent = '(Press S or ↓)';
                else if (tc < kc) hint.textContent = '(Press A or ←)';
                else if (tc > kc) hint.textContent = '(Press D or →)';
            } else if (step.expectedAction === 'useHeroAbility') hint.textContent = '(Press H)';
        }

        function advanceTutorial() {
            const step = tutorialSteps[tutorialStep];
            if (tutorialStep >= tutorialSteps.length - 1 && step.trigger === 'win') {
                showPrompt("Tutorial complete! Start playing or explore Creative Mode.");
                toggleTutorialButtons(false);
                return;
            }
            tutorialStep++;
            setupTutorialStep();
        }

        // --- Creative Mode ---
        const creativeState = {
            king: null,
            jail: null,
            escape: null,
            opponents: [],
            blocked: [],
            treasures: [],
            lastGuardIndex: null,
            portalsList: [],
            placing: null,
            history: [],
            redoStack: [],
            lastPlaced: null,
            terrain: { forest: [], water: [], sand: [] }
        };

        function startCreativeMode() {
            state.mode = 'creative';
            showSection('creative-mode');
            requestAnimationFrame(() => {
                const canvas = document.getElementById('creative-board');
                if (!canvas) {
                    console.error('Creative canvas not found after RAF');
                    return;
                }
                if (!creativeCtx) {
                    creativeCtx = canvas.getContext('2d');
                    if (!creativeCtx) {
                        console.error('Failed to initialize creative canvas context');
                        return;
                    }
                }
                resetCreativeState();
                updateSavedMapsList();
                setupCreativeEvents();
                state.forceRedraw = true;
            });
        }

        function resetCreativeState() {
            creativeState.king = null;
            creativeState.jail = null;
            creativeState.escape = null;
            creativeState.opponents = [];
            creativeState.blocked = [];
            creativeState.treasures = [];
            creativeState.portalsList = [];
            creativeState.placing = null;
        }

        function setupCreativeEvents() {
            const creativeCanvas = document.getElementById('creative-board');
            if (!creativeCanvas) return;
            creativeCanvas.addEventListener('click', (e) => {
                const rect = creativeCanvas.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / SQUARE);
                const row = Math.floor((e.clientY - rect.top) / SQUARE);
                if (creativeState.placing) {
                    if (isSquareOccupied(row, col, creativeState)) {
                        alert('Square already occupied!');
                        return;
                    }
                    saveCreativeState();
                    const pos = [row, col];
                    if (creativeState.placing === 'guard-patrol-start') {
                        const guardType = document.getElementById('guard-type').value;
                        creativeState.opponents.push({
                            type: guardType,
                            pos,
                            behavior: 'patrolling',
                            patrolRoute: [pos],
                            patrolIndex: 0
                        });
                        creativeState.placing = 'guard-patrol-path';
                        creativeState.lastGuardIndex = creativeState.opponents.length - 1;
                    } else if (creativeState.placing === 'guard-patrol-path') {
                        creativeState.opponents[creativeState.lastGuardIndex].patrolRoute.push(pos);
                        creativeState.lastPlaced = pos;
                    } else {
                        switch (creativeState.placing) {
                            case 'king':
                                creativeState.king = pos;
                                break;
                            case 'jail':
                                creativeState.jail = pos;
                                break;
                            case 'escape':
                                creativeState.escape = pos;
                                break;
                            case 'guard':
                                const guardType = document.getElementById('guard-type').value;
                                creativeState.opponents.push({
                                    type: guardType,
                                    pos,
                                    behavior: document.getElementById('guard-behavior').value
                                });
                                break;
                            case 'block':
                                creativeState.blocked.push(pos);
                                break;
                            case 'treasure':
                                const treasureType = document.getElementById('treasure-type').value;
                                creativeState.treasures.push({ type: treasureType, pos });
                                break;
                            case 'portal':
                                if (creativeState.portalsList.length && creativeState.portalsList[creativeState.portalsList.length - 1].length === 1) {
                                    creativeState.portalsList[creativeState.portalsList.length - 1].push(pos);
                                } else {
                                    creativeState.portalsList.push([pos]);
                                }
                                break;
                            case 'terrain':
                                if (creativeState.terrainType === 'forest') {
                                    creativeState.terrain.forest.push(pos);
                                } else if (creativeState.terrainType === 'water') {
                                    creativeState.terrain.water.push(pos);
                                } else if (creativeState.terrainType === 'sand') {
                                   creativeState.terrain.sand.push(pos);
                                }
                                break;
                            case 'remove':
                                if (creativeState.king && creativeState.king[0] === row && creativeState.king[1] === col) {
                                    creativeState.king = null;
                                } else if (creativeState.jail && creativeState.jail[0] === row && creativeState.jail[1] === col) {
                                    creativeState.jail = null;
                                } else if (creativeState.escape && creativeState.escape[0] === row && creativeState.escape[1] === col) {
                                    creativeState.escape = null;
                                } else {
                                    creativeState.opponents = creativeState.opponents.filter(op => op.pos[0] !== row || op.pos[1] !== col);
                                    creativeState.blocked = creativeState.blocked.filter(b => b[0] !== row || b[1] !== col);
                                    creativeState.treasures = creativeState.treasures.filter(t => t.pos[0] !== row || t.pos[1] !== col);
                                    creativeState.portalsList = creativeState.portalsList.map(pair => pair.filter(p => p[0] !== row || p[1] !== col)).filter(pair => pair.length > 0);
                                }
                                break;
                        }
                    }
                    creativeState.lastPlaced = pos;
                    drawCreativeBoard();
                    state.forceRedraw = true;
                }
            });
            creativeCanvas.addEventListener('mousemove', (e) => {
                const rect = creativeCanvas.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / SQUARE);
                const row = Math.floor((e.clientY - rect.top) / SQUARE);
                if (creativeState.placing && creativeState.placing !== 'remove') {
                    drawCreativeBoard();
                    if (row >= 0 && row < BOARD && col >= 0 && col < BOARD && !isSquareOccupied(row, col, creativeState)) {
                        const theme = themes[state.theme] || themes.light;
                        const pieceStyle = pieceStyles[state.pieceStyle] || pieceStyles.classic;
                        creativeCtx.globalAlpha = 0.5;
                        if (creativeState.placing === 'king') {
                            creativeCtx.font = `36px ${theme.font}`;
                            creativeCtx.fillStyle = theme.dark;
                            creativeCtx.textAlign = 'center';
                            creativeCtx.textBaseline = 'middle';
                            creativeCtx.fillText(pieceStyle.king, col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2);
                        } else if (creativeState.placing === 'guard') {
                            const guardType = document.getElementById('guard-type').value;
                            creativeCtx.font = `28px ${theme.font}`;
                            creativeCtx.fillStyle = theme.btn;
                            creativeCtx.textAlign = 'center';
                            creativeCtx.textBaseline = 'middle';
                            creativeCtx.fillText(pieceStyle[guardType], col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2);
                        } else if (creativeState.placing === 'treasure') {
                            const treasureType = document.getElementById('treasure-type').value;
                            creativeCtx.font = `24px ${theme.font}`;
                            creativeCtx.fillStyle = '#FFD700';
                            creativeCtx.textAlign = 'center';
                            creativeCtx.textBaseline = 'middle';
                            creativeCtx.fillText(treasures[treasureType].symbol, col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2);
                        } else if (creativeState.placing === 'portal') {
                            creativeCtx.fillStyle = '#800080';
                            creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                        } else if (creativeState.placing === 'block') {
                            creativeCtx.fillStyle = '#000';
                            creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                        } else if (creativeState.placing === 'jail') {
                            creativeCtx.fillStyle = '#f00';
                            creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                        } else if (creativeState.placing === 'escape') {
                            creativeCtx.fillStyle = '#0f0';
                            creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                        }
                        creativeCtx.globalAlpha = 1.0;
                    }
                }
            });

            creativeCanvas.addEventListener('mouseout', () => {
                drawCreativeBoard();
            });

            document.getElementById('btn-place-king').addEventListener('click', () => creativeState.placing = 'king');
            document.getElementById('btn-place-jail').addEventListener('click', () => creativeState.placing = 'jail');
            document.getElementById('btn-place-escape').addEventListener('click', () => creativeState.placing = 'escape');
            document.getElementById('btn-place-guard').addEventListener('click', () => {
                creativeState.placing = 'guard';
                const behavior = document.getElementById('guard-behavior').value;
                if (behavior === 'patrolling') {
                    creativeState.placing = 'guard-patrol-start';
                    alert('Click to place the guard, then click additional squares to define its patrol path. Click "Finish Patrol" to complete.');
                    const finishPatrolBtn = document.createElement('button');
                    finishPatrolBtn.id = 'btn-finish-patrol';
                    finishPatrolBtn.textContent = 'Finish Patrol';
                    finishPatrolBtn.onclick = () => {
                        creativeState.placing = null;
                        finishPatrolBtn.remove();
                        drawCreativeBoard();
                    };
                    document.getElementById('creative-tools').appendChild(finishPatrolBtn);
                }
            });
            document.getElementById('btn-place-block').addEventListener('click', () => creativeState.placing = 'block');
            document.getElementById('btn-place-treasure').addEventListener('click', () => creativeState.placing = 'treasure');
            document.getElementById('btn-place-portal').addEventListener('click', () => creativeState.placing = 'portal');
            document.getElementById('btn-remove').addEventListener('click', () => creativeState.placing = 'remove');
            document.getElementById('btn-undo').addEventListener('click', () => {
                if (creativeState.history.length > 0) {
                    creativeState.redoStack.push({
                        king: creativeState.king ? [...creativeState.king] : null,
                        jail: creativeState.jail ? [...creativeState.jail] : null,
                        escape: creativeState.escape ? [...creativeState.escape] : null,
                        opponents: JSON.parse(JSON.stringify(creativeState.opponents)),
                        blocked: JSON.parse(JSON.stringify(creativeState.blocked)),
                        treasures: JSON.parse(JSON.stringify(creativeState.treasures)),
                        portalsList: JSON.parse(JSON.stringify(creativeState.portalsList))
                    });
                    const lastState = creativeState.history.pop();
                    Object.assign(creativeState, lastState);
                    drawCreativeBoard();
                    state.forceRedraw = true;
                    showMessage('Undo action performed');
                } else {
                    alert('No actions to undo!');
                }
            });

            document.getElementById('btn-redo').addEventListener('click', () => {
                if (creativeState.redoStack.length > 0) {
                    saveCreativeState();
                    const nextState = creativeState.redoStack.pop();
                    Object.assign(creativeState, nextState);
                    drawCreativeBoard();
                    state.forceRedraw = true;
                    showMessage('Redo action performed');
                } else {
                    alert('No actions to redo!');
                }
            });
            document.getElementById('btn-test-map').addEventListener('click', () => {
                if (creativeState.king && creativeState.jail && creativeState.escape) {
                    const tempState = JSON.parse(JSON.stringify(state));
                    state.king = [...creativeState.king];
                    state.jail = [...creativeState.jail];
                    state.escape = [...creativeState.escape];
                    state.opponents = JSON.parse(JSON.stringify(creativeState.opponents));
                    state.blocked = JSON.parse(JSON.stringify(creativeState.blocked));
                    state.treasures = JSON.parse(JSON.stringify(creativeState.treasures));
                    state.portalsList = JSON.parse(JSON.stringify(creativeState.portalsList));
                    state.portals = state.portalsList.length > 0 ? 'on' : 'off';
                    state.mode = 'fugitive';
                    state.phase = 'waiting';
                    state.roll = 0;
                    state.moves = 0;
                    state.guards = 0;
                    state.score = 0;
                    showSection('game-area');
                    drawBoard();
                    displayModeRules();
                    document.getElementById('game-info').textContent = 'Testing map. Press Space to roll dice';
                    document.getElementById('btn-back-to-start-game').textContent = 'Back to Creative';
                    document.getElementById('btn-back-to-start-game').onclick = () => {
                        Object.assign(state, tempState);
                        state.mode = 'creative';
                        showSection('creative-mode');
                        drawCreativeBoard();
                        document.getElementById('btn-back-to-start-game').textContent = 'Back to Start Page';
                        document.getElementById('btn-back-to-start-game').onclick = showStartPage;
                    };
                } else {
                    alert('Please place King, Jail, and Escape before testing.');
                }
            });
            document.getElementById('btn-save-map').addEventListener('click', saveCreativeMap);
            document.getElementById('btn-load-map').addEventListener('click', loadCreativeMap);
            document.getElementById('btn-export-map').addEventListener('click', exportMap);
            document.getElementById('btn-import-map').addEventListener('click', importMap);
            document.getElementById('btn-random-map').addEventListener('click', generateRandomMap);
            document.getElementById('btn-play-creative').addEventListener('click', () => {
                if (creativeState.king && creativeState.jail && creativeState.escape) {
                    state.king = [...creativeState.king];
                    state.jail = [...creativeState.jail];
                    state.escape = [...creativeState.escape];
                    state.opponents = JSON.parse(JSON.stringify(creativeState.opponents));
                    state.blocked = JSON.parse(JSON.stringify(creativeState.blocked));
                    state.treasures = JSON.parse(JSON.stringify(creativeState.treasures));
                    state.portalsList = JSON.parse(JSON.stringify(creativeState.portalsList));
                    state.terrain = JSON.parse(JSON.stringify(creativeState.terrain));
                    state.portals = state.portalsList.length > 0 ? 'on' : 'off';
                    state.mode = 'fugitive';
                    state.phase = 'waiting';
                    state.roll = 0;
                    state.moves = 0;
                    state.initial = {
                        king: [...state.king],
                        jail: [...state.jail],
                        escape: [...state.escape],
                        opponents: JSON.parse(JSON.stringify(state.opponents)),
                        blocked: JSON.parse(JSON.stringify(state.blocked)),
                        treasures: JSON.parse(JSON.stringify(state.treasures)),
                        portalsList: JSON.parse(JSON.stringify(state.portalsList)),
                        pointItems: JSON.parse(JSON.stringify(state.pointItems || []))
                    };
                    document.getElementById('creative-mode').style.display = 'none';
                    document.getElementById('game-area').style.display = 'flex';
                    if (!validateState()) {
                        console.warn('Invalid state after creative transition, initializing board');
                        initBoard();
                    }
                    drawBoard();
                    displayModeRules();
                } else {
                    alert('Please place King, Jail, and Escape before playing.');
                }
            });
            document.getElementById('btn-undo').addEventListener('click', () => {
                if (creativeState.history.length > 0) {
                    const lastState = creativeState.history.pop();
                    Object.assign(creativeState, lastState);
                    drawCreativeBoard();
                    state.forceRedraw = true;
                }
            });
            document.getElementById('treasure-type').addEventListener('change', (e) => {
                const treasureType = e.target.value;
                showTooltip('treasure-type', treasures[treasureType].description);
            });

            document.getElementById('btn-batch-block').addEventListener('click', () => {
                creativeState.placing = 'batch-block';
                const count = parseInt(document.getElementById('batch-count').value);
                if (isNaN(count) || count <= 0) {
                    alert('Please enter a valid number of blocks.');
                    creativeState.placing = null;
                    return;
                }
                let placed = 0;
                function placeBatch(e) {
                    const rect = creativeCanvas.getBoundingClientRect();
                    const col = Math.floor((e.clientX - rect.left) / SQUARE);
                    const row = Math.floor((e.clientY - rect.top) / SQUARE);
                    if (isSquareOccupied(row, col, creativeState)) {
                        alert('Square already occupied!');
                        return;
                    }
                    saveCreativeState();
                    creativeState.blocked.push([row, col]);
                    creativeState.lastPlaced = [row, col];
                    placed++;
                    drawCreativeBoard();
                    if (placed >= count) {
                        creativeCanvas.removeEventListener('click', placeBatch);
                        creativeState.placing = null;
                        showMessage(`Placed ${count} blocks`);
                    }
                }
                creativeCanvas.addEventListener('click', placeBatch);
            });

            document.getElementById('btn-clear-board').addEventListener('click', () => {
                if (confirm('Are you sure you want to clear the board?')) {
                    resetCreativeState();
                    drawCreativeBoard();
                }
            });

            document.getElementById('btn-place-terrain').addEventListener('click', () => {
                creativeState.placing = 'terrain';
                creativeState.terrainType = document.getElementById('terrain-type').value;
            });
        }

        function drawCreativeBoard() {
            if (!creativeCtx) {
                console.error('Creative canvas context is null');
                return;
            }
            const theme = themes[state.theme] || themes.light;
            const pieceStyle = pieceStyles[state.pieceStyle] || pieceStyles.classic;
            creativeCtx.clearRect(0, 0, BOARD * SQUARE, BOARD * SQUARE);
            for (let row = 0; row < BOARD; row++) {
                for (let col = 0; col < BOARD; col++) {
                    creativeCtx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;
                    creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                }
            }
            creativeState.blocked.forEach(([row, col]) => {
                creativeCtx.fillStyle = '#000';
                creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
            });
            if (creativeState.jail) {
                creativeCtx.fillStyle = '#f00';
                creativeCtx.fillRect(creativeState.jail[1] * SQUARE, creativeState.jail[0] * SQUARE, SQUARE, SQUARE);
            }
            if (creativeState.escape) {
                creativeCtx.fillStyle = '#0f0';
                creativeCtx.fillRect(creativeState.escape[1] * SQUARE, creativeState.escape[0] * SQUARE, SQUARE, SQUARE);
            }
            creativeState.treasures.forEach(t => {
                creativeCtx.font = `24px ${theme.font}`;
                creativeCtx.fillStyle = '#FFD700';
                creativeCtx.textAlign = 'center';
                creativeCtx.textBaseline = 'middle';
                creativeCtx.fillText(treasures[t.type].symbol, t.pos[1] * SQUARE + SQUARE / 2, t.pos[0] * SQUARE + SQUARE / 2);
            });
            creativeState.opponents.forEach(op => {
                creativeCtx.font = `28px ${theme.font}`;
                creativeCtx.fillStyle = theme.btn;
                creativeCtx.textAlign = 'center';
                creativeCtx.textBaseline = 'middle';
                creativeCtx.fillText(pieceStyle[op.type], op.pos[1] * SQUARE + SQUARE / 2, op.pos[0] * SQUARE + SQUARE / 2);
            });
            creativeState.portalsList.forEach(pair => {
                if (pair.length === 2) {
                    pair.forEach(([row, col]) => {
                        creativeCtx.fillStyle = '#800080';
                        creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                    });
                }
            });
            if (creativeState.king) {
                creativeCtx.font = `36px ${theme.font}`;
                creativeCtx.fillStyle = theme.dark;
                creativeCtx.textAlign = 'center';
                creativeCtx.textBaseline = 'middle';
                creativeCtx.fillText(pieceStyle.king, creativeState.king[1] * SQUARE + SQUARE / 2, creativeState.king[0] * SQUARE + SQUARE / 2);
            }
            if (creativeState.lastPlaced) {
                const [row, col] = creativeState.lastPlaced;
                creativeCtx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                setTimeout(() => {
                    creativeState.lastPlaced = null;
                    drawCreativeBoard();
                }, 500);
            }

            creativeState.terrain.forest.forEach(([row, col]) => {
                creativeCtx.fillStyle = '#228B22'; // Green for forest
                creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
            });
            creativeState.terrain.water.forEach(([row, col]) => {
                creativeCtx.fillStyle = '#00CED1'; // Blue for water
                creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
            });
            creativeState.terrain.sand.forEach(([row, col]) => {
                creativeCtx.fillStyle = '#C2B280'; // Sandy color for sand
                creativeCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
            });
            document.getElementById('btn-batch-terrain').addEventListener('click', () => {
                const count = parseInt(document.getElementById('batch-terrain-count').value);
                if (isNaN(count) || count <= 0) {
                    alert('Please enter a valid number of terrain tiles.');
                    return;
                }
                placeBatchTerrain(count);
            });
        }

        function exportMap() {
            const mapData = JSON.stringify(creativeState);
            const blob = new Blob([mapData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fugitive_map.json';
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Map exported! Share the JSON file.');
        }

        function importMap() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const loadedState = JSON.parse(event.target.result);
                            Object.assign(creativeState, loadedState);
                            drawCreativeBoard();
                            showMessage('Map imported successfully!');
                        } catch (err) {
                            alert('Invalid map data: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function generateRandomMap() {
            resetCreativeState();
            const occupied = [];
            creativeState.jail = getRandomSquare(occupied);
            occupied.push(creativeState.jail);
            creativeState.king = [...creativeState.jail];
            occupied.push(creativeState.king);
            creativeState.escape = getRandomSquare(occupied);
            occupied.push(creativeState.escape);
            const blockCount = Math.floor(Math.random() * 10) + 5; // 5-14 blocks
            for (let i = 0; i < blockCount; i++) {
                const pos = getRandomSquare(occupied);
                if (pos) {
                    creativeState.blocked.push(pos);
                    occupied.push(pos);
                }
            }
            const guardCount = Math.floor(Math.random() * 5) + 1; // 1-5 guards
            const guardTypes = ['pawn', 'rook', 'knight', 'bishop', 'queen'];
            for (let i = 0; i < guardCount; i++) {
                const type = guardTypes[Math.floor(Math.random() * guardTypes.length)];
                const pos = getRandomSquare(occupied);
                if (pos) {
                    creativeState.opponents.push({ type, pos, behavior: 'chase' });
                    occupied.push(pos);
                }
            }
            const treasureCount = Math.floor(Math.random() * 3) + 1; // 1-3 treasures
            const treasureKeys = Object.keys(treasures);
            for (let i = 0; i < treasureCount; i++) {
                const type = treasureKeys[Math.floor(Math.random() * treasureKeys.length)];
                const pos = getRandomSquare(occupied);
                if (pos) {
                    creativeState.treasures.push({ type, pos });
                    occupied.push(pos);
                }
            }
            if (!hasPathToEscapeCreative()) {
                alert('Generated map has no path to escape. Adjust manually or generate again.');
            }
            drawCreativeBoard();
            showMessage('Random map generated!');
        }

        function animateCapture(pos) {
            const [row, col] = pos;
            let alpha = 1;
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            const theme = themes[state.theme] || themes.light;

            function fade() {
                alpha -= 0.05;
                currentCtx.save();
                currentCtx.globalAlpha = alpha;
                currentCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                currentCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                currentCtx.restore();
                if (alpha > 0) requestAnimationFrame(fade);
                else drawBoard();
            }
            requestAnimationFrame(fade);
        }

        function animateTreasureCollection(pos) {
            const [row, col] = pos;
            const currentCtx = state.mode === 'tutorial' ? tutorialCtx : ctx;
            const theme = themes[state.theme] || themes.light;
            let particles = [];
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: col * SQUARE + SQUARE / 2,
                    y: row * SQUARE + SQUARE / 2,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1
                });
            }
            function animate() {
                currentCtx.save();
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    currentCtx.fillStyle = `rgba(255, 215, 0, ${p.life})`;
                    currentCtx.beginPath();
                    currentCtx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                    currentCtx.fill();
                });
                currentCtx.restore();
                drawBoard();
                if (particles.length > 0) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
        }

        function isSquareOccupied(row, col, modeState = state) {
            console.log('isSquareOccupied: modeState.king =', modeState === state ? state.king : creativeState.king);
            if (modeState === state || modeState.mode === 'tutorial') {
                return (
                    state.blocked.some(b => b[0] === row && b[1] === col) ||
                    state.opponents.some(op => op.pos[0] === row && op.pos[1] === col) ||
                    state.treasures.some(t => t.pos[0] === row && t.pos[1] === col) ||
                    (state.king && state.king[0] === row && state.king[1] === col) ||
                    (state.jail[0] === row && state.jail[1] === col) ||
                    (state.escape[0] === row && state.escape[1] === col) ||
                    state.portalsList.some(pair => pair.some(p => p[0] === row && p[1] === col))
                );
            } else if (modeState === creativeState) {
                return (
                    (creativeState.king && creativeState.king[0] === row && creativeState.king[1] === col) ||
                    (creativeState.jail && creativeState.jail[0] === row && creativeState.jail[1] === col) ||
                    (creativeState.escape && creativeState.escape[0] === row && creativeState.escape[1] === col) ||
                    creativeState.opponents.some(op => op.pos[0] === row && op.pos[1] === col) ||
                    creativeState.blocked.some(b => b[0] === row && b[1] === col) ||
                    creativeState.treasures.some(t => t.pos[0] === row && t.pos[1] === col) ||
                    creativeState.portalsList.some(pair => pair.some(p => p[0] === row && p[1] === col))
                );
            }
            return false;
        }

        function startStandardChess() {
            state.mode = 'standard';
            standardState.difficulty = document.getElementById('standard-difficulty').value;
            standardState.theme = document.getElementById('standard-theme').value;
            standardState.whitePieceStyle = document.getElementById('standard-white-piece-style').value;
            standardState.blackPieceStyle = document.getElementById('standard-black-piece-style').value;
            standardState.turnTimer = document.getElementById('standard-turn-timer').value;
            standardState.hero = document.getElementById('standard-hero-select').value !== '-1' ? document.getElementById('standard-hero-select').value : null;
            standardState.opponent = document.getElementById('standard-opponent').value;
            standardState.aiPlaysAs = standardState.opponent === 'ai' ? 'black' : null;
            standardState.moveHistory = [];
            resetStandardState();
            showSection('standard-chess-section');
            setTimeout(() => {
                drawStandardBoard();
                isDirty = true;
                if (standardState.aiPlaysAs === 'white') {
                    setTimeout(makeAIMove, 500);
                }
            }, 100);
            if (standardState.turnTimer === 'on') startStandardTimer();
        }

        function startStandardTimer() {
            clearInterval(standardState.timer);
            standardState.timer = setInterval(() => {
                if (standardState.turn === 'white') {
                    standardState.whiteTime--;
                    if (standardState.whiteTime <= 0) endStandardGame('Black wins by time!');
                } else {
                    standardState.blackTime--;
                    if (standardState.blackTime <= 0) endStandardGame('White wins by time!');
                }
                updateStandardInfo();
            }, 1000);
        }

        function calculateScores() {
            const whiteScore = standardState.capturedBlack.reduce((sum, piece) => sum + pieceValues[piece.type], 0);
            const blackScore = standardState.capturedWhite.reduce((sum, piece) => sum + pieceValues[piece.type], 0);
            return { white: whiteScore, black: blackScore };
        }

        function updateStandardInfo() {
            const whiteMin = Math.floor(standardState.whiteTime / 60);
            const whiteSec = standardState.whiteTime % 60;
            const blackMin = Math.floor(standardState.blackTime / 60);
            const blackSec = standardState.blackTime % 60;
            const scores = calculateScores();
            document.getElementById('standard-game-info').textContent = `${standardState.turn === 'white' ? 'White' : 'Black'} to move | White: ${whiteMin}:${whiteSec < 10 ? '0' : ''}${whiteSec} | Black: ${blackMin}:${blackSec < 10 ? '0' : ''}${blackSec} | Scores: White ${scores.white} - Black ${scores.black}`;
        }

        function updateMoveHistory() {
            const historyDiv = document.getElementById('move-history');
            if (!historyDiv || !standardState.moveHistory) return;
            let historyText = '';
            const notation = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            standardState.moveHistory.forEach((move, index) => {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                const piece = standardState.board[toRow][toCol];
                if (!piece) return;
                const moveNum = Math.floor(index / 2) + 1;
                const fromSquare = `${notation[fromCol]}${8 - fromRow}`;
                const toSquare = `${notation[toCol]}${8 - toRow}`;
                if (index % 2 === 0) historyText += `${moveNum}. `;
                historyText += `${fromSquare}-${toSquare} `;
            });
            historyDiv.textContent = historyText.trim();
        }

        function initStandardCanvasEvents() {
            const canvas = document.getElementById('standard-chess-board');
            canvas.addEventListener('click', (e) => {
                if (state.mode !== 'standard') return;
                const rect = canvas.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / SQUARE);
                const row = Math.floor((e.clientY - rect.top) / SQUARE);
                if (row >= 0 && row < 8 && col >= 0 && col < 8) {
                    handleStandardClick(row, col);
                }
            });
        }

        function handleStandardClick(row, col) {
            const piece = standardState.board[row][col];
            if (standardState.selected) {
                if (standardState.validMoves.some(([r, c]) => r === row && c === col)) {
                    moveStandardPiece(standardState.selected, [row, col]);
                    standardState.selected = null;
                    standardState.validMoves = [];
                    drawStandardBoard();
                    const opponentColor = getOpponentColor(standardState.turn);
                    if (isCheckmate(opponentColor)) {
                        endStandardGame(`${standardState.turn} wins by checkmate!`);
                    } else if (isStalemate(opponentColor)) {
                        endStandardGame('Draw by stalemate!');
                    } else {
                        standardState.turn = opponentColor;
                        updateStandardInfo();
                        if (standardState.aiPlaysAs === standardState.turn) {
                            setTimeout(makeAIMove, 500);
                        }
                    }
                } else {
                    standardState.selected = null;
                    standardState.validMoves = [];
                    drawStandardBoard();
                }
            } else if (piece && piece.color === standardState.turn) {
                standardState.selected = [row, col];
                standardState.validMoves = getStandardValidMoves(piece, row, col);
                drawStandardBoard();
            }
        }

        function handleStandardKeyboardSelect() {
            const row = standardState.cursorRow;
            const col = standardState.cursorCol;
            const piece = standardState.board[row][col];
            if (standardState.selected) {
                if (standardState.validMoves.some(([r, c]) => r === row && c === col)) {
                    moveStandardPiece(standardState.selected, [row, col]);
                    standardState.selected = null;
                    standardState.validMoves = [];
                    drawStandardBoard();
                    const opponentColor = getOpponentColor(standardState.turn);
                    if (isCheckmate(opponentColor)) {
                        endStandardGame(`${standardState.turn} wins by checkmate!`);
                    } else if (isStalemate(opponentColor)) {
                        endStandardGame('Draw by stalemate!');
                    } else {
                        standardState.turn = opponentColor;
                        updateStandardInfo();
                        if (standardState.aiPlaysAs === standardState.turn) {
                            setTimeout(makeAIMove, 500);
                        }
                    }
                } else {
                    standardState.selected = null;
                    standardState.validMoves = [];
                    drawStandardBoard();
                }
            } else if (piece && piece.color === standardState.turn) {
                standardState.selected = [row, col];
                standardState.validMoves = getStandardValidMoves(piece, row, col);
                drawStandardBoard();
            }
        }

        function getStandardValidMoves(piece, row, col) {
            const moves = [];
            const direction = piece.color === 'white' ? -1 : 1;
            switch (piece.type) {
                case 'pawn':
                    if (isStandardEmpty(row + direction, col)) {
                        moves.push([row + direction, col]);
                        if ((piece.color === 'white' && row === 6) || (piece.color === 'black' && row === 1)) {
                            if (isStandardEmpty(row + 2 * direction, col)) moves.push([row + 2 * direction, col]);
                        }
                    }
                    if (isStandardOpponent(row + direction, col - 1, piece.color)) moves.push([row + direction, col - 1]);
                    if (isStandardOpponent(row + direction, col + 1, piece.color)) moves.push([row + direction, col + 1]);
                    if (standardState.enPassant && standardState.enPassant[0] === row + direction && Math.abs(standardState.enPassant[1] - col) === 1) {
                        moves.push([row + direction, standardState.enPassant[1]]);
                    }
                    break;
                case 'rook':
                    addLinearMoves(moves, row, col, [0, 1]);
                    addLinearMoves(moves, row, col, [0, -1]);
                    addLinearMoves(moves, row, col, [1, 0]);
                    addLinearMoves(moves, row, col, [-1, 0]);
                    break;
                case 'knight':
                    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightMoves.forEach(([dr, dc]) => {
                        const r = row + dr, c = col + dc;
                        if (isStandardValidSquare(r, c) && (!standardState.board[r][c] || standardState.board[r][c].color !== piece.color)) {
                            moves.push([r, c]);
                        }
                    });
                    break;
                case 'bishop':
                    addLinearMoves(moves, row, col, [1, 1]);
                    addLinearMoves(moves, row, col, [1, -1]);
                    addLinearMoves(moves, row, col, [-1, 1]);
                    addLinearMoves(moves, row, col, [-1, -1]);
                    break;
                case 'queen':
                    addLinearMoves(moves, row, col, [0, 1]);
                    addLinearMoves(moves, row, col, [0, -1]);
                    addLinearMoves(moves, row, col, [1, 0]);
                    addLinearMoves(moves, row, col, [-1, 0]);
                    addLinearMoves(moves, row, col, [1, 1]);
                    addLinearMoves(moves, row, col, [1, -1]);
                    addLinearMoves(moves, row, col, [-1, 1]);
                    addLinearMoves(moves, row, col, [-1, -1]);
                    break;
                case 'king':
                    const kingMoves = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                    kingMoves.forEach(([dr, dc]) => {
                        const r = row + dr, c = col + dc;
                        if (isStandardValidSquare(r, c) && (!standardState.board[r][c] || standardState.board[r][c].color !== piece.color)) {
                            moves.push([r, c]);
                        }
                    });
                    if (standardState.castling[piece.color].king) {
                        const opponentColor = getOpponentColor(piece.color);
                        if (standardState.castling[piece.color].kingRook && 
                            isStandardEmpty(row, 5) && isStandardEmpty(row, 6) && 
                            !isKingInCheck(piece.color) && 
                            !isSquareUnderAttack(row, 5, opponentColor) && 
                            !isSquareUnderAttack(row, 6, opponentColor)) {
                            moves.push([row, 6]);
                        }
                        if (standardState.castling[piece.color].queenRook && 
                            isStandardEmpty(row, 3) && isStandardEmpty(row, 2) && isStandardEmpty(row, 1) && 
                            !isKingInCheck(piece.color) && 
                            !isSquareUnderAttack(row, 3, opponentColor) && 
                            !isSquareUnderAttack(row, 2, opponentColor)) {
                            moves.push([row, 2]);
                        }
                    }
                    break;
            }
            const validMoves = moves.filter(move => !wouldPutKingInCheck([row, col], move));
            return validMoves;
        }

        function wouldPutKingInCheck(from, to) {
            const [fromRow, fromCol] = from;
            const [toRow, toCol] = to;
            const piece = standardState.board[fromRow][fromCol];
            const capturedPiece = standardState.board[toRow][toCol];
            const newBoard = copyBoard(standardState.board);

            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;

            const opponentColor = piece.color === 'white' ? 'black' : 'white';
            const kingPos = getKingPosition(piece.color, newBoard);
            return isSquareUnderAttack(kingPos[0], kingPos[1], opponentColor, newBoard);
        }

        function copyBoard(board) {
            return board.map(row => row.slice());
        }

        function isCheckmate(color) {
            if (!isKingInCheck(color)) return false;
            const moves = getAllLegalMoves(color);
            return moves.length === 0;
        }
        
        function isStalemate(color) {
            if (isKingInCheck(color)) return false;
            const moves = getAllLegalMoves(color);
            return moves.length === 0;
        }

        function addLinearMoves(moves, row, col, [dr, dc]) {
            let r = row + dr, c = col + dc;
            while (isStandardValidSquare(r, c)) {
                if (!standardState.board[r][c]) moves.push([r, c]);
                else {
                    if (standardState.board[r][c].color !== standardState.board[row][col].color) moves.push([r, c]);
                    break;
                }
                r += dr;
                c += dc;
            }
        }

        function moveStandardPiece(from, to, board = standardState.board) {
            if (standardState.moveHistory.length > 100) {
                console.warn('moveHistory exceeds 100 entries, trimming');
                standardState.moveHistory = standardState.moveHistory.slice(-100);
            }
            standardState.moveHistory.push({
                board: copyBoard(standardState.board),
                turn: standardState.turn,
                castling: JSON.parse(JSON.stringify(standardState.castling)),
                enPassant: standardState.enPassant ? [...standardState.enPassant] : null,
                from: from,
                to: to
            });
            console.log('Move added, moveHistory length:', standardState.moveHistory.length);
            const [fromRow, fromCol] = from;
            const [toRow, toCol] = to;
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            standardState.enPassant = null;

            if (capturedPiece) {
                if (piece.color === 'white') standardState.capturedBlack.push(capturedPiece);
                else standardState.capturedWhite.push(capturedPiece);
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.capture.volume = state.music.sfxVolume;
                    sounds.capture.play();
                }
            } else {
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.move.volume = state.music.sfxVolume;
                    sounds.move.play();
                }
            }

            if (piece.type === 'pawn') {
                if ((piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7)) {
                    showPromotionModal(piece.color, toRow, toCol);
                    board[fromRow][fromCol] = null;
                    return;
                }
                if (Math.abs(fromRow - toRow) === 2) {
                    standardState.enPassant = [(fromRow + toRow) / 2, fromCol];
                }
            }
            if (piece.type === 'pawn' && toRow === standardState.enPassant?.[0] && toCol === standardState.enPassant?.[1]) {
                board[fromRow][toCol] = null;
            }
            if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {
                if (toCol === 6) {
                    board[fromRow][5] = board[fromRow][7];
                    board[fromRow][7] = null;
                } else if (toCol === 2) {
                    board[fromRow][3] = board[fromRow][0];
                    board[fromRow][0] = null;
                }
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            standardState.lastMove = { from: from, to: to };

            if (piece.type === 'king') standardState.castling[piece.color].king = false;
            if (piece.type === 'rook') {
                if (fromCol === 0) standardState.castling[piece.color].queenRook = false;
                if (fromCol === 7) standardState.castling[piece.color].kingRook = false;
            }
            updateMoveHistory();
        }

        function showPromotionModal(color, row, col) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <h3>Promote Pawn (${color})</h3>
                <button onclick="promotePawn('queen', ${row}, ${col}, '${color}'); this.parentElement.remove()">Queen</button>
                <button onclick="promotePawn('rook', ${row}, ${col}, '${color}'); this.parentElement.remove()">Rook</button>
                <button onclick="promotePawn('knight', ${row}, ${col}, '${color}'); this.parentElement.remove()">Knight</button>
                <button onclick="promotePawn('bishop', ${row}, ${col}, '${color}'); this.parentElement.remove()">Bishop</button>
            `;
            document.body.appendChild(modal);
        }

        function promotePawn(type, row, col, color) {
            standardState.board[row][col] = { type, color };
            drawStandardBoard();
            const opponentColor = getOpponentColor(color);
            if (isCheckmate(opponentColor)) {
                endStandardGame(`${color} wins by checkmate!`);
            } else if (isStalemate(opponentColor)) {
                endStandardGame('Draw by stalemate!');
            } else {
                standardState.turn = opponentColor;
                updateStandardInfo();
                if (standardState.aiPlaysAs === standardState.turn) {
                    setTimeout(makeAIMove, 500);
                }
            }
        }

        function isStandardValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function isStandardEmpty(row, col) {
            return isStandardValidSquare(row, col) && !standardState.board[row][col];
        }

        function isStandardOpponent(row, col, color) {
            return isStandardValidSquare(row, col) && standardState.board[row][col] && standardState.board[row][col].color !== color;
        }

        function drawStandardBoard() {
            if (!standardChessCtx) {
                console.error('standardChessCtx is null');
                return;
            }
            const theme = themes[standardState.theme] || themes.light;
            const pieceStyle = pieceStyles[standardState.pieceStyle] || pieceStyles.classic;

            standardChessCtx.clearRect(0, 0, 400, 400);

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    standardChessCtx.fillStyle = (row + col) % 2 === 0 ? theme.light : theme.dark;
                    standardChessCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                }
            }
            if (standardState.selected) {
                const [row, col] = standardState.selected;
                standardChessCtx.strokeStyle = 'yellow';
                standardChessCtx.lineWidth = 3;
                standardChessCtx.strokeRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
            }

            standardChessCtx.fillStyle = 'rgba(255, 255, 0, 0.5)';
            standardChessCtx.fillRect(standardState.cursorCol * SQUARE, standardState.cursorRow * SQUARE, SQUARE, SQUARE);

            // Highlight selected piece with glow effect
            if (standardState.selected) {
                const [row, col] = standardState.selected;
                standardChessCtx.fillStyle = 'rgba(255, 255, 0, 0.3)'; // Light yellow background
                standardChessCtx.fillRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                standardChessCtx.strokeStyle = 'yellow';
                standardChessCtx.lineWidth = 3;
                standardChessCtx.strokeRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                // Add glow effect
                standardChessCtx.shadowColor = 'yellow';
                standardChessCtx.shadowBlur = 10;
                standardChessCtx.strokeRect(col * SQUARE, row * SQUARE, SQUARE, SQUARE);
                standardChessCtx.shadowBlur = 0;

                standardState.validMoves.forEach(([r, c]) => {
                    standardChessCtx.fillStyle = 'rgba(0, 0, 255, 0.3)'; // Light blue background
                    standardChessCtx.fillRect(c * SQUARE, r * SQUARE, SQUARE, SQUARE);
                    standardChessCtx.beginPath();
                    standardChessCtx.arc(c * SQUARE + SQUARE / 2, r * SQUARE + SQUARE / 2, 10, 0, 2 * Math.PI);
                    standardChessCtx.fillStyle = 'blue';
                    standardChessCtx.fill();
                });
            }
            
            if (standardState.lastMove) {
                const { from, to } = standardState.lastMove;
                standardChessCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                standardChessCtx.fillRect(from[1] * SQUARE, from[0] * SQUARE, SQUARE, SQUARE);
                standardChessCtx.fillRect(to[1] * SQUARE, to[0] * SQUARE, SQUARE, SQUARE);
            }

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = standardState.board[row][col];
                    if (piece) {
                        standardChessCtx.font = `28px ${theme.font}`;
                        standardChessCtx.fillStyle = piece.color === 'white' ? '#fff' : '#000';
                        standardChessCtx.shadowColor = 'black';
                        standardChessCtx.shadowBlur = 2;
                        standardChessCtx.textAlign = 'center';
                        standardChessCtx.textBaseline = 'middle';
                        let symbol;
                        if (piece.type === 'king' && piece.color === 'white' && standardState.hero) {
                            symbol = heroes[standardState.hero].emoji;
                        } else {
                            const style = piece.color === 'white' ? standardState.whitePieceStyle : standardState.blackPieceStyle;
                            symbol = pieceStyles[style][piece.type];
                        }
                        standardChessCtx.fillText(symbol, col * SQUARE + SQUARE / 2, row * SQUARE + SQUARE / 2);
                        standardChessCtx.shadowBlur = 0;
                    }
                }
            }

            updateStandardInfo();
            if (standardState.moveHistory) {
                try {
                    updateMoveHistory();
                } catch (e) {
                    console.error('Failed to update move history:', e);
                    standardState.moveHistory = [];
                    updateMoveHistory();
                }
            } else {
                console.warn('moveHistory is undefined in drawStandardBoard, initializing');
                standardState.moveHistory = [];
            }
        }

        function endStandardGame(message) {
            clearInterval(standardState.timer);
            document.getElementById('custom-prompt-text').textContent = message;
            document.getElementById('btn-custom-replay').style.display = 'inline';
            document.getElementById('btn-custom-next').style.display = 'none';
            document.getElementById('btn-custom-menu').style.display = 'inline';
            document.getElementById('custom-prompt').style.display = 'block';
            document.getElementById('btn-custom-replay').onclick = () => startStandardChess();
            document.getElementById('btn-custom-menu').onclick = () => showSection('start-page');
            if (message.startsWith('White wins')) {
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.win.volume = state.music.sfxVolume;
                    sounds.win.play();
                }
            } else if (message.startsWith('Black wins')) {
                if (!state.music.isMuted && state.music.sfxVolume > 0) {
                    sounds.lose.volume = state.music.sfxVolume;
                    sounds.lose.play();
                }
            }
        }

        function showHint() {
            if (standardState.turn !== 'white') return;
            const moves = getAllLegalMoves('white');
            if (moves.length === 0) return;
            let bestMove;
            let bestValue = -Infinity;
            const depth = 2;
            for (const move of moves) {
                const [fr, fc, tr, tc] = move;
                const newBoard = copyBoard(standardState.board);
                moveStandardPiece([fr, fc], [tr, tc], newBoard);
                const value = minimax(newBoard, depth - 1, false, 'white', -Infinity, Infinity);
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }
            if (bestMove) {
                const [fromRow, fromCol, toRow, toCol] = bestMove;
                standardState.selected = [fromRow, fromCol];
                standardState.validMoves = [[toRow, toCol]];
                drawStandardBoard();
                setTimeout(() => {
                    standardState.selected = null;
                    standardState.validMoves = [];
                    drawStandardBoard();
                }, 2000);
            }
        }

        function getKingPosition(color, board = standardState.board) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        function isKingInCheck(color, board = standardState.board) {
            const kingPos = getKingPosition(color, board);
            const opponentColor = color === 'white' ? 'black' : 'white';
            return isSquareUnderAttack(kingPos[0], kingPos[1], opponentColor, board);
        }

        function isSquareUnderAttack(row, col, attackerColor, board = standardState.board) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === attackerColor) {
                        if (canPieceAttack(piece, r, c, row, col, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPieceAttack(piece, row, col, targetRow, targetCol, board = standardState.board) {
            if (row === targetRow && col === targetCol) return false;
            switch (piece.type) {
                case 'pawn':
                    const direction = piece.color === 'white' ? 1 : -1;
                    return (row + direction === targetRow) && (Math.abs(col - targetCol) === 1);
                case 'knight':
                    const dr = Math.abs(row - targetRow);
                    const dc = Math.abs(col - targetCol);
                    return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
                case 'bishop':
                    return isSameDiagonal(row, col, targetRow, targetCol) && isPathClear(row, col, targetRow, targetCol, board);
                case 'rook':
                    return (isSameRow(row, targetRow) || isSameCol(col, targetCol)) && isPathClear(row, col, targetRow, targetCol, board);
                case 'queen':
                    return (isSameRow(row, targetRow) || isSameCol(col, targetCol) || isSameDiagonal(row, col, targetRow, targetCol)) && 
                          isPathClear(row, col, targetRow, targetCol, board);
                case 'king':
                    return Math.abs(row - targetRow) <= 1 && Math.abs(col - targetCol) <= 1;
            }
            return false;
        }

        function isSameRow(r1, r2) { return r1 === r2; }
        function isSameCol(c1, c2) { return c1 === c2; }
        function isSameDiagonal(r1, c1, r2, c2) { return Math.abs(r1 - r2) === Math.abs(c1 - c2); }

        function isPathClear(fromRow, fromCol, toRow, toCol, board = standardState.board) {
            if (fromRow === toRow) {
                const minCol = Math.min(fromCol, toCol) + 1;
                const maxCol = Math.max(fromCol, toCol) - 1;
                for (let c = minCol; c <= maxCol; c++) {
                    if (board[fromRow][c]) return false;
                }
            } else if (fromCol === toCol) {
                const minRow = Math.min(fromRow, toRow) + 1;
                const maxRow = Math.max(fromRow, toRow) - 1;
                for (let r = minRow; r <= maxRow; r++) {
                    if (board[r][fromCol]) return false;
                }
            } else if (isSameDiagonal(fromRow, fromCol, toRow, toCol)) {
                const rowStep = fromRow < toRow ? 1 : -1;
                const colStep = fromCol < toCol ? 1 : -1;
                let r = fromRow + rowStep;
                let c = fromCol + colStep;
                while (r !== toRow && c !== toCol) {
                    if (board[r][c]) return false;
                    r += rowStep;
                    c += colStep;
                }
            }
            return true;
        }

        function getAllLegalMoves(color) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = standardState.board[row][col];
                    if (piece && piece.color === color) {
                        const pieceMoves = getStandardValidMoves(piece, row, col);
                        pieceMoves.forEach(([toRow, toCol]) => {
                            moves.push([row, col, toRow, toCol]);
                        });
                    }
                }
            }
            return moves;
        }

        function getOpeningMove(color) {
            const book = openingBook[color];
            if (!book || standardState.turn !== color) return null;
            for (const entry of book) {
                if (!entry.condition || standardState.board[entry.condition[0]][entry.condition[1]] === null) {
                    return entry.move;
                }
            }
            return null;
        }

        function makeAIMove() {
            const color = standardState.turn;
            const openingMove = standardState.levels < 2 ? getOpeningMove(color) : null;
            if (openingMove) {
                const [fromRow, fromCol, toRow, toCol] = openingMove;
                moveStandardPiece([fromRow, fromCol], [toRow, toCol]);
                drawStandardBoard();
                const opponentColor = getOpponentColor(color);
                if (isCheckmate(opponentColor)) {
                    endStandardGame(`${color} wins by checkmate!`);
                } else if (isStalemate(opponentColor)) {
                    endStandardGame('Draw by stalemate!');
                } else {
                    standardState.turn = opponentColor;
                    updateStandardInfo();
                    if (standardState.aiPlaysAs === standardState.turn) {
                        setTimeout(makeAIMove, 500);
                    }
                }
                return;
            }

            const moves = getAllLegalMoves(color);
            if (moves.length === 0) {
                console.error('No legal moves for AI');
                return;
            }

            let bestMoves = [];
            let bestValue = -Infinity;
            const depth = standardState.difficulty === 'easy' ? 1 : standardState.difficulty === 'medium' ? 2 : 4;

            for (const move of moves) {
                const [fr, fc, tr, tc] = move;
                const newBoard = copyBoard(standardState.board);
                moveStandardPiece([fr, fc], [tr, tc], newBoard);
                const value = minimax(newBoard, depth - 1, false, color, -Infinity, Infinity);
                if (value > bestValue) {
                    bestValue = value;
                    bestMoves = [move];
                } else if (value === bestValue) {
                    bestMoves.push(move); 
                }
            }

            if (bestMoves.length > 0) {
                const randomIndex = Math.floor(Math.random() * bestMoves.length);
                const [fromRow, fromCol, toRow, toCol] = bestMoves[randomIndex];
                moveStandardPiece([fromRow, fromCol], [toRow, toCol]);
                drawStandardBoard();
                const opponentColor = getOpponentColor(color);
                if (isCheckmate(opponentColor)) {
                    endStandardGame(`${color} wins by checkmate!`);
                } else if (isStalemate(opponentColor)) {
                    endStandardGame('Draw by stalemate!');
                } else {
                    standardState.turn = opponentColor;
                    updateStandardInfo();
                    if (standardState.aiPlaysAs === standardState.turn) {
                        setTimeout(makeAIMove, 500);
                    }
                }
            }
        }

        function aStar(start, goal) {
            const openSet = [start];
            const cameFrom = {};
            const gScore = { [start]: 0 };
            const fScore = { [start]: manhattanDistance(start, goal) };

            while (openSet.length > 0) {
                openSet.sort((a, b) => (fScore[a] || Infinity) - (fScore[b] || Infinity));
                const current = openSet.shift();

                if (current[0] === goal[0] && current[1] === goal[1]) {
                    const path = [];
                    let temp = current;
                    while (temp) {
                        path.push(temp);
                        temp = cameFrom[temp];
                    }
                    return path.reverse();
                }

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore[current] + 1;
                    if (!(neighbor in gScore) || tentativeGScore < gScore[neighbor]) {
                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + manhattanDistance(neighbor, goal);
                        if (!openSet.some(pos => pos[0] === neighbor[0] && pos[1] === neighbor[1])) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }

        function getNeighbors(pos) {
            const [row, col] = pos;
            const directions = [
                [0, 1], [1, 0], [0, -1], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];
            const neighbors = [];
            for (const [dr, dc] of directions) {
                const r = row + dr;
                const c = col + dc;
                if (r >= 0 && r < BOARD && c >= 0 && c < BOARD &&
                    !state.blocked.some(b => b[0] === r && b[1] === c) &&
                    !state.opponents.some(op => op.pos[0] === r && op.pos[1] === c)) {
                    neighbors.push([r, c]);
                }
            }
            return neighbors;
        }

        function evaluateBoard(board, color) {
            let score = 0;
            const pieceValues = { pawn: 1, knight: 3, bishop: 3, rook: 5, queen: 9, king: 0 };
            const centerSquares = [[3, 3], [3, 4], [4, 3], [4, 4]];
            const opponentColor = color === 'white' ? 'black' : 'white';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = pieceValues[piece.type];
                        score += piece.color === color ? value : -value;


                        if (centerSquares.some(([r, c]) => r === row && c === col)) {
                            score += piece.color === color ? 0.5 : -0.5;
                        }

                        if (piece.type === 'pawn') {
                            const filePawns = board.filter((_, r) => board[r][col]?.type === 'pawn' && board[r][col]?.color === piece.color).length;
                            if (filePawns > 1) score += piece.color === color ? -0.5 : 0.5;
                        } else if (piece.type === 'king') {
                            const isCenter = row >= 2 && row <= 5 && col >= 2 && col <= 5;
                            if (isCenter) score += piece.color === color ? -1 : 1;
                            const kingRow = piece.color === 'white' ? 7 : 0;
                            const distanceFromHome = Math.abs(row - kingRow);
                            score += piece.color === color ? -distanceFromHome * 0.5 : distanceFromHome * 0.5;
                        }
                    }
                }
            }

            const moves = getAllLegalMoves(color);
            score += moves.length * 0.1;
            const opponentMoves = getAllLegalMoves(opponentColor);
            score -= opponentMoves.length * 0.1;

            return score;
        }

        function minimax(board, depth, isMaximizing, color, alpha, beta) {
            if (depth === 0) return evaluateBoard(board, color);

            const moves = getAllLegalMoves(isMaximizing ? color : getOpponentColor(color));
            if (moves.length === 0) return isMaximizing ? -Infinity : Infinity;

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const [fr, fc, tr, tc] = move;
                    const newBoard = copyBoard(board);
                    moveStandardPiece([fr, fc], [tr, tc], newBoard);
                    const eval = minimax(newBoard, depth - 1, false, color, alpha, beta);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const [fr, fc, tr, tc] = move;
                    const newBoard = copyBoard(board);
                    moveStandardPiece([fr, fc], [tr, tc], newBoard);
                    const eval = minimax(newBoard, depth - 1, true, color, alpha, beta);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getOpponentColor(color) {
            return color === 'white' ? 'black' : 'white';
        }

        function saveGame() {
            const saveData = {
                state: {
                    ...state,
                    music: {
                        ...state.music,
                        audio: undefined
                    }
                },
                creativeState: { ...creativeState }
            };
            localStorage.setItem('fugitiveChessSave', JSON.stringify(saveData));
            alert('Game saved!');
        }

        function saveCurrentTheme() {
            if (state.theme && themes[state.theme]) {
                const name = prompt('Enter a name for this theme:');
                if (name) {
                    const themeData = themes[state.theme];
                    const customThemes = JSON.parse(localStorage.getItem('fugitiveCustomThemes')) || {};
                    customThemes[name] = themeData;
                    localStorage.setItem('fugitiveCustomThemes', JSON.stringify(customThemes));
                    themes[`custom:${name}`] = themeData;
                    alert('Theme saved!');
                    initThemeDropdown();
                    initStandardDropdowns();
                }
            } else {
                alert('No theme to save.');
            }
        }

        function customizeTheme() {
            const name = prompt('Enter theme name:');
            if (!name) return;
            const light = document.getElementById('light-color').value;
            const dark = document.getElementById('dark-color').value;
            const bg = prompt('Enter background (e.g., #e0e0e0 or linear-gradient(...)):', '#e0e0e0');
            const btn = prompt('Enter button color (e.g., #4CAF50):') || '#4CAF50';
            const btnHover = prompt('Enter button hover color (e.g., #45a049):') || '#45a049';
            const text = prompt('Enter text color (e.g., #333):') || '#333';
            const newTheme = { light, dark, bg, btn, btnHover, text, font: 'Arial, sans-serif' };
            themes[`custom:${name}`] = newTheme;
            state.theme = `custom:${name}`;
            localStorage.setItem('fugitiveCustomThemes', JSON.stringify(themes));
            initThemeDropdown();
            applyTheme();
            drawBoard();
            showMessage(`Theme "${name}" created!`);
        }

        function saveCreativeState() {
            creativeState.history.push({
                king: creativeState.king ? [...creativeState.king] : null,
                jail: creativeState.jail ? [...creativeState.jail] : null,
                escape: creativeState.escape ? [...creativeState.escape] : null,
                opponents: JSON.parse(JSON.stringify(creativeState.opponents)),
                blocked: JSON.parse(JSON.stringify(creativeState.blocked)),
                treasures: JSON.parse(JSON.stringify(creativeState.treasures)),
                portalsList: JSON.parse(JSON.stringify(creativeState.portalsList))
            });
            creativeState.redoStack = [];
        }

        function saveCreativeMap() {
            const mapName = prompt('Enter a name for this map:');
            if (mapName) {
                const mapData = JSON.stringify(creativeState);
                let savedMaps = JSON.parse(localStorage.getItem('fugitiveCreativeMaps')) || {};
                savedMaps[mapName] = mapData;
                localStorage.setItem('fugitiveCreativeMaps', JSON.stringify(savedMaps));
                alert('Map saved!');
                updateSavedMapsList();
            }
        }

        function loadCreativeMap() {
            const savedMaps = JSON.parse(localStorage.getItem('fugitiveCreativeMaps')) || {};
            const mapNames = Object.keys(savedMaps);
            if (mapNames.length === 0) {
                alert('No saved maps found.');
                return;
            }
            const mapName = prompt('Enter the name of the map to load:\nAvailable maps: ' + mapNames.join(', '));
            if (mapName && savedMaps[mapName]) {
                const loadedState = JSON.parse(savedMaps[mapName]);
                Object.assign(creativeState, loadedState);
                drawCreativeBoard();
                alert('Map loaded!');
                state.forceRedraw = true;
            } else {
                alert('Map not found.');
            }
        }

        function updateSavedMapsList() {
            const savedMaps = JSON.parse(localStorage.getItem('fugitiveCreativeMaps')) || {};
            const mapsList = document.getElementById('maps-list');
            mapsList.innerHTML = '';
            Object.keys(savedMaps).forEach(mapName => {
                const mapDiv = document.createElement('div');
                mapDiv.textContent = mapName;
                const loadBtn = document.createElement('button');
                loadBtn.textContent = 'Load';
                loadBtn.onclick = () => {
                    const loadedState = JSON.parse(savedMaps[mapName]);
                    Object.assign(creativeState, loadedState);
                    drawCreativeBoard();
                    alert('Map loaded!');
                    state.forceRedraw = true;
                };
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => {
                    if (confirm(`Delete map "${mapName}"?`)) {
                        delete savedMaps[mapName];
                        localStorage.setItem('fugitiveCreativeMaps', JSON.stringify(savedMaps));
                        updateSavedMapsList();
                    }
                };
                mapDiv.appendChild(loadBtn);
                mapDiv.appendChild(deleteBtn);
                mapsList.appendChild(mapDiv);
            });
        }

        function autosaveGame() {
            const saveData = {
                state: {
                    ...state,
                    music: {
                        ...state.music,
                        audio: undefined
                    }
                },
                creativeState: { ...creativeState }
            };
            localStorage.setItem('fugitiveChessAutosave', JSON.stringify(saveData));
        }

        function loadGame() {
            const saved = localStorage.getItem('fugitiveChessSave');
            const autosaved = localStorage.getItem('fugitiveChessAutosave');
            if (saved || autosaved) {
                if (confirm('Loading a game will overwrite your current progress. Continue?')) {
                    const choice = confirm('Load manual save? Click Cancel to load autosave.');
                    const data = choice && saved ? JSON.parse(saved) : JSON.parse(autosaved);
                    const loadedState = data.state;
                    if (!loadedState.king || !Array.isArray(loadedState.king) || loadedState.king.length !== 2) loadedState.king = [0, 0];
                    if (!loadedState.jail || !Array.isArray(loadedState.jail)) loadedState.jail = [0, 0];
                    if (!loadedState.escape || !Array.isArray(loadedState.escape)) loadedState.escape = [7, 7];
                    Object.assign(state, loadedState);
                    if (data.standardState) {
                        Object.assign(standardState, data.standardState);
                        standardState.moveHistory = Array.isArray(standardState.moveHistory) ? standardState.moveHistory : [];
                    }
                    state.music.audio = new Audio();
                    state.music.audio.volume = state.music.audioVolume || 0.5;
                    Object.values(sounds).forEach(sound => {
                        sound.volume = state.music.sfxVolume || 0.5;
                        sound.muted = state.music.isMuted;
                    });
                    Object.assign(creativeState, data.creativeState);
                    applyTheme();
                    if (state.mode === 'standard') drawStandardBoard();
                    else drawBoard();
                    alert(choice ? 'Manual save loaded!' : 'Autosave loaded!');
                }
            } else {
                alert('No saved game found.');
            }
        }

        function saveGameState() {
            const gameState = {
                fugitive: { ...state },
                creative: { ...creativeState },
                standard: { ...standardState }
            };
            localStorage.setItem('fugitiveGameStates', JSON.stringify(gameState));
        }

        function loadGameState(mode) {
            const savedStates = JSON.parse(localStorage.getItem('fugitiveGameStates')) || {};
            if (savedStates[mode]) {
                if (mode === 'fugitive') Object.assign(state, savedStates.fugitive);
                else if (mode === 'creative') Object.assign(creativeState, savedStates.creative);
                else if (mode === 'standard') Object.assign(standardState, savedStates.standard);
            }
        }

        function showMessage(msg) {
            const div = document.createElement('div');
            div.className = 'flash-message';
            div.textContent = msg;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 3000);
        }

        function provideHint() {
            const playerPosition = document.querySelector('.king') || document.querySelector('.hero');
            const escapePosition = document.querySelector('.escape');
            if (!playerPosition || !escapePosition) return;

            const path = findShortestPath(playerPosition.parentNode, escapePosition.parentNode);
            if (path.length > 0) {
                highlightPath(path);
            } else {
                console.log('No path found');
            }
        }

        function findShortestPath(startSquare, endSquare) {
            const board = document.querySelectorAll('.board-square');
            const gridSize = Math.sqrt(board.length); // Assuming square board
            const startIndex = Array.from(board).indexOf(startSquare);
            const endIndex = Array.from(board).indexOf(endSquare);

            const queue = [{ index: startIndex, path: [startIndex] }];
            const visited = new Set([startIndex]);

            const directions = [-1, 1, -gridSize, gridSize]; // Left, Right, Up, Down

            while (queue.length > 0) {
                const { index, path } = queue.shift();
                if (index === endIndex) return path.map(i => board[i]);

                for (let dir of directions) {
                    const newIndex = index + dir;
                    if (
                        newIndex >= 0 && newIndex < board.length &&
                        !visited.has(newIndex) &&
                        !board[newIndex].querySelector('.block, .guard') // Avoid obstacles
                    ) {
                        visited.add(newIndex);
                        queue.push({ index: newIndex, path: [...path, newIndex] });
                    }
                }
            }
            return [];
        }

        function highlightPath(path) {
            document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));
            path.forEach(square => square.classList.add('hint-highlight'));
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
</body>
</html>